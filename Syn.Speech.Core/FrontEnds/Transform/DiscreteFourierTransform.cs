using System;
using System.Numerics;
using Syn.Speech.Logging;
using Syn.Speech.Util.Props;
//PATROLLED + REFACTORED
namespace Syn.Speech.FrontEnds.Transform
{
    /// <summary>
    /// Computes the Discrete Fourier Transform (FT) of an input sequence, using Fast Fourier Transform (FFT). Fourier
    /// Transform is the process of analyzing a signal into its frequency components. In speech, rather than analyzing the
    /// signal over its entire duration, we analyze one <b>window</b> of audio data. This window is the product of applying a
    /// sliding Hamming window to the signal. Moreover, since the amplitude is a lot more important than the phase for speech
    /// recognition, this class returns the power spectrum of that window of data instead of the complex spectrum. Each value
    /// in the returned spectrum represents the strength of that particular frequency for that window of data.
    /// <p/>
    /// By default, the number of FFT points is the closest power of 2 that is equal to or larger than the number of samples
    /// in the incoming window of data. The FFT points can also be set by the user with the property defined by {@link
    /// #PROP_NUMBER_FFT_POINTS}. The length of the returned power spectrum is the number of FFT points, divided by 2, plus
    /// 1. Since the input signal is real, the FFT is symmetric, and the information contained in the whole vector is already
    /// present in its first half.
    /// <p/>
    /// Note that each call to {@link #getData() getData} only returns the spectrum of one window of data. To display the
    /// spectrogram of the entire original audio, one has to collect all the spectra from all the windows generated from the
    /// original data. A spectrogram is a two dimensional representation of three dimensional information. The horizontal
    /// axis represents time. The vertical axis represents the frequency. If we slice the spectrogram at a given time, we get
    /// the spectrum computed as the short term Fourier transform of the signal windowed around that time stamp. The
    /// intensity of the spectrum for each time frame is given by the color in the graph, or by the darkness in a gray scale
    /// plot. The spectrogram can be thought of as a view from the top of a surface generated by concatenating the spectral
    /// vectors obtained from the windowed signal.
    /// <p/>
    /// For example, Figure 1 below shows the audio signal of the utterance "one three nine oh", and Figure 2 shows its
    /// spectrogram, produced by putting together all the spectra returned by this FFT. Frequency is on the vertical axis,
    /// and time is on the horizontal axis. The darkness of the shade represents the strength of that frequency at that point
    /// in time: <p> <br><img src="doc-files/139o.jpg"> <br><b>Figure 1: The audio signal of the utterance "one three nine
    /// oh".</b> <p> <br><img src="doc-files/139ospectrum.jpg"> <br><b>Figure 2: The spectrogram of the utterance "one three
    /// nine oh" in Figure 1.</b>
    /// </summary>
    public class DiscreteFourierTransform : BaseDataProcessor
    {
        /// <summary>
        /// The property for the number of points in the Fourier Transform.
        /// </summary>
        [S4Integer(DefaultValue = -1)]
        public static string PropNumberFFTPoints = "numberFftPoints";

        /// <summary>
        /// The property for the invert transform.
        /// </summary>
        [S4Boolean(DefaultValue = false)]
        public static string PropInvert = "invert";

        private Boolean _isNumberFftPointsSet;
        private int _numberFftPoints;
        private int _logBase2NumberFftPoints;
        private int _numberDataPoints;
        private Boolean _invert;

        private Complex[] _weightFft;
        private Complex[] _inputFrame;
        private Complex[] _from;
        private Complex[] _to;

        private Complex _weightFftTimesFrom2;
        private Complex _tempComplex;

        public DiscreteFourierTransform(int numberFftPoints, Boolean invert)
        {
            this._numberFftPoints = numberFftPoints;
            _isNumberFftPointsSet = (numberFftPoints != -1);
            this._invert = invert;
        }

        public DiscreteFourierTransform()
        {
        }

        public override void NewProperties(PropertySheet ps)
        {
            base.NewProperties(ps);
            _numberFftPoints = ps.GetInt(PropNumberFFTPoints);
            _isNumberFftPointsSet = (_numberFftPoints != -1);
            _invert = ps.GetBoolean(PropInvert);
        }


        /// <summary>
        /// @see Sphincs.frontend.DataProcessor#initialize(Sphincs.frontend.CommonConfig)
        /// </summary>
        public override void Initialize()
        {
            base.Initialize();
            if (_isNumberFftPointsSet)
            {
                InitializeFFT();
            }
        }


        /// <summary>
        /// Initialize all the data structures necessary for computing FFT.
        /// </summary>
        private void InitializeFFT()
        {
            /**
            /// Number of points in the FFT. By default, the value is 512,
            /// which means that we compute 512 values around a circle in the
            /// complex plane. Complex conjugate pairs will yield the same
            /// power, therefore the power produced by indices 256 through
            /// 511 are symmetrical with the ones between 1 and 254. Therefore,
            /// we need only return values between 0 and 255.
             */
            ComputeLogBase2(_numberFftPoints);
            CreateWeightFft(_numberFftPoints, _invert);
            InitComplexArrays();
            _weightFftTimesFrom2 = new Complex();
            _tempComplex = new Complex();
        }


        /// <summary>
        /// Initialize all the Complex arrays that will be necessary for FFT.
        /// </summary>
        private void InitComplexArrays()
        {

            _inputFrame = new Complex[_numberFftPoints];
            _from = new Complex[_numberFftPoints];
            _to = new Complex[_numberFftPoints];

            for (var i = 0; i < _numberFftPoints; i++)
            {
                _inputFrame[i] = new Complex();
                _from[i] = new Complex();
                _to[i] = new Complex();
            }
        }


        /// <summary>
        /// Process data, creating the power spectrum from an input frame.
        /// </summary>
        /// <param name="input">the input frame</param>
        /// <returns>a DoubleData that is the power spectrum of the input frame</returns>
        private DoubleData Process(DoubleData input)
        {
            /// Create complex input sequence equivalent to the real
            /// input sequence.
            /// If the number of points is less than the window size,
            /// we incur in aliasing. If it's greater, we pad the input
            /// sequence with zeros.

            var _in = input.Values;

            if (_numberFftPoints < _in.Length)
            {
                var i = 0;
                for (; i < _numberFftPoints; i++)
                {
                    _inputFrame[i] = new Complex(_in[i], 0.0f);
                }
                for (; i < _in.Length; i++)
                {
                    _tempComplex = new Complex(_in[i], 0.0f);

                    _inputFrame[i % _numberFftPoints] = Complex.Add
                            (_inputFrame[i % _numberFftPoints], _tempComplex);
                }
            }
            else
            {
                var i = 0;
                for (; i < _in.Length; i++)
                {
                    _inputFrame[i] = new Complex(_in[i], 0.0f);
                }
                for (; i < _numberFftPoints; i++)
                {
                    _inputFrame[i] = new Complex(0.0d, 0.0d);
                }
            }


            // Create output sequence.

            var outputSpectrum = new double[(_numberFftPoints >> 1) + 1];

            // Start Fast Fourier Transform recursion

            RecurseFft(_inputFrame, outputSpectrum, _numberFftPoints, _invert);


            /// Return the power spectrum
            var output = new DoubleData
                    (outputSpectrum, input.SampleRate,
                            input.FirstSampleNumber);

            return output;
        }


        /// <summary>
        /// Make sure the number of points in the FFT is a power of 2 by computing its log base 2 and checking for
        /// remainders.
        /// </summary>
        /// <param name="numberFftPoints">The number of points in the FFT.</param>
        /// <exception cref="System.ArgumentException">Not a power of 2:  + numberFftPoints</exception>
        private void ComputeLogBase2(int numberFftPoints)
        {
            _logBase2NumberFftPoints = 0;
            for (var k = numberFftPoints; k > 1; k >>= 1, _logBase2NumberFftPoints++)
            {
                if (((k % 2) != 0) || (numberFftPoints < 0))
                {
                    throw new ArgumentException("Not a power of 2: " + numberFftPoints);
                }
            }
        }


        /**
        /// Initializes the <b>weightFft[]</b> vector. <p><b>weightFft[k] = w ^ k</b></p> where: <p><b>w = exp(-2/// PI/// i /
        /// N)</b></p> <p><b>i</b> is a complex number such that <b>i/// i = -1</b> and <b>N</b> is the number of points in
        /// the FFT. Since <b>w</b> is complex, this is the same as</p> <p><b>Re(weightFft[k]) = cos ( -2/// PI/// k /
        /// N)</b></p> <p><b>Im(weightFft[k]) = sin ( -2/// PI/// k / N)</b></p>
         *
        /// @param numberFftPoints number of points in the FFT
        /// @param invert          whether it's direct (false) or inverse (true) FFT
         */
        private void CreateWeightFft(int numberFftPoints, Boolean invert)
        {
            /**
            /// weightFFT will have numberFftPoints/2 complex elements.
             */
            _weightFft = new Complex[numberFftPoints >> 1];

            /**
            /// For the inverse FFT,
            /// w = 2* PI / numberFftPoints;
             */
            var w = -2 * Math.PI / numberFftPoints;
            if (invert)
            {
                w = -w;
            }

            for (var k = 0; k < (numberFftPoints >> 1); k++)
            {
                _weightFft[k] = new Complex(Math.Cos(w * k), Math.Sin(w * k));
            }
        }

        /// <summary>
        /// Reads the next DoubleData object, which is a data frame from which we'll compute the power spectrum. Signal
        /// objects just pass through unmodified.
        /// </summary>
        /// <returns>the next available power spectrum DoubleData object, or null if no Spectrum object is available</returns>
        public override IData GetData()
        {
            var input = Predecessor.GetData();


            if ((input != null) && (input is DoubleData))
            {
                var data = (DoubleData)input;
                if (!_isNumberFftPointsSet)
                {
                    /*
                    /// If numberFftPoints is not set by the user,
                    /// figure out the numberFftPoints and initialize the
                    /// data structures appropriately.
                     */
                    if (_numberDataPoints != data.Values.Length)
                    {
                        _numberDataPoints = data.Values.Length;
                        _numberFftPoints = GetNumberFftPoints(_numberDataPoints);
                        InitializeFFT();
                    }
                }
                else
                {
                    /*
                    /// Warn if the user-set numberFftPoints is not ideal.
                     */
                    if (_numberDataPoints != data.Values.Length)
                    {
                        _numberDataPoints = data.Values.Length;
                        var idealFftPoints = GetNumberFftPoints(_numberDataPoints);
                        if (idealFftPoints != _numberFftPoints)
                        {
                            this.LogInfo("User set numberFftPoints (" +
                                    _numberFftPoints + ") is not ideal (" +
                                    idealFftPoints + ')');
                        }
                    }
                }
                input = Process(data);
            }

            // At this point - or in the call immediatelly preceding
            // this -, we should have created a cepstrum frame with
            // whatever data came last, even if we had less than
            // window size of data.



            return input;
        }


   

        /// <summary>
        /// Returns the ideal number of FFT points given the number of samples. The ideal number of FFT points is the closest
        /// power of 2 that is equal to or larger than the number of samples in the incoming window.
        /// </summary>
        /// <param name="numberSamples">The number of samples in the incoming window.</param>
        /// <returns>The closest power of 2 that is equal to or larger than the number of samples in the incoming window.</returns>
        /// <exception cref="System.Exception">Invalid # of FFT points:  + fftPoints</exception>
        private static int GetNumberFftPoints(int numberSamples)
        {
            var fftPoints = 1;

            while (fftPoints < numberSamples)
            {
                fftPoints <<= 1;
                if (fftPoints < 1)
                {
                    throw new Exception("Invalid # of FFT points: " + fftPoints);
                }
            }
            return fftPoints;
        }

        /// <summary>
        /// Establish the recursion. The FFT computation will be computed by as a recursion. Each stage in the butterfly will
        /// be fully computed during recursion. In fact, we use the mechanism of recursion only because it's the simplest way
        /// of switching the "input" and "output" vectors. The output of a stage is the input to the next stage. The
        /// butterfly computes elements in place, but we still need to switch the vectors. We could copy it (not very
        /// efficient...) or, in C, switch the pointers. We can avoid the pointers by using recursion.
        /// </summary>
        /// <param name="input">The input sequence.</param>
        /// <param name="output">The output sequence.</param>
        /// <param name="numberFftPoints">The number of points in the FFT.</param>
        /// <param name="invert">Whether it's direct (false) or inverse (true) FFT.</param>
        private void RecurseFft(Complex[] input, double[] output, int numberFftPoints, Boolean invert)
        {

            double divisor;

            /**
            /// The direct and inverse FFT are essentially the same
            /// algorithm, except for two difference: a scaling factor of
            /// "numberFftPoints" and the signal of the exponent in the
            /// weightFft vectors, defined in the method
            /// <code>createWeightFft</code>.
             */

            if (!invert)
            {
                divisor = 1.0;
            }
            else
            {
                divisor = numberFftPoints;
            }

            /**
            /// Initialize the "from" and "to" variables.
             */
            for (var i = 0; i < numberFftPoints; i++)
            {
                _to[i] = new Complex(0.0d, 0.0d);
                _from[i] = new Complex(input[i].Real / divisor, input[i].Imaginary / divisor);
            }

            /**
            /// Repeat the recursion log2(numberFftPoints) times,
            /// i.e., we have log2(numberFftPoints) butterfly stages.
             */
            ButterflyStage(_from, _to, numberFftPoints, numberFftPoints >> 1);

            /**
            /// Compute energy ("float") for each frequency point
            /// from the fft ("complex")
             */
            if ((_logBase2NumberFftPoints & 1) == 0)
            {
                for (var i = 0; i <= (numberFftPoints >> 1); i++)
                {
                    output[i] = SquaredMagnitudeComplex(_from[i]);
                }
            }
            else
            {
                for (var i = 0; i <= (numberFftPoints >> 1); i++)
                {
                    output[i] = SquaredMagnitudeComplex(_to[i]);
                }
            }
        }

        /// <summary>
        /// Method to compute the squared magnitude of a complex number.
        /// </summary>
        /// <param name="_this">The _this.</param>
        /// <returns>the squared magnitude of the complex number</returns>
        public double SquaredMagnitudeComplex(Complex _this)
        {
            double squaredMag = _this.Real * _this.Real + _this.Imaginary * _this.Imaginary;
            return squaredMag;
        }

        /**
        /// Compute one stage in the FFT butterfly. The name "butterfly" appears because this method computes elements in
        /// pairs, and a flowgraph of the computation (output "0" comes from input "0" and "1" and output "1" comes from
        /// input "0" and "1") resembles a butterfly.
        /// <p/>
        /// We repeat <code>butterflyStage</code> for <b>log_2(numberFftPoints)</b> stages, by calling the recursion with the
        /// argument <code>currentDistance</code> divided by 2 at each call, and checking if it's still > 0.
         *
        /// @param from            the input sequence at each stage
        /// @param to              the output sequence
        /// @param numberFftPoints the total number of points
        /// @param currentDistance the "distance" between elements in the butterfly
         */
        private void ButterflyStage(Complex[] from, Complex[] to, int numberFftPoints, int currentDistance)
        {
            int ndx1From;
            int ndx2From;
            int ndx1To;
            int ndx2To;
            int ndxWeightFft;

            if (currentDistance > 0)
            {

                var twiceCurrentDistance = 2 * currentDistance;

                for (var s = 0; s < currentDistance; s++)
                {
                    ndx1From = s;
                    ndx2From = s + currentDistance;
                    ndx1To = s;
                    ndx2To = s + (numberFftPoints >> 1);
                    ndxWeightFft = 0;
                    while (ndxWeightFft < (numberFftPoints >> 1))
                    {
                        /**
                        /// <b>weightFftTimesFrom2 = weightFft[k]   </b>
                        /// <b>                      *from[ndx2From]</b>
                         */
                        _weightFftTimesFrom2 = Complex.Multiply
                                (_weightFft[ndxWeightFft], from[ndx2From]);
                        /**
                        /// <b>to[ndx1To] = from[ndx1From]       </b>
                        /// <b>             + weightFftTimesFrom2</b>
                         */
                        to[ndx1To] = Complex.Add
                                (from[ndx1From], _weightFftTimesFrom2);
                        /**
                        /// <b>to[ndx2To] = from[ndx1From]       </b>
                        /// <b>             - weightFftTimesFrom2</b>
                         */
                        to[ndx2To] = Complex.Subtract
                                (from[ndx1From], _weightFftTimesFrom2);
                        ndx1From += twiceCurrentDistance;
                        ndx2From += twiceCurrentDistance;
                        ndx1To += currentDistance;
                        ndx2To += currentDistance;
                        ndxWeightFft += currentDistance;
                    }
                }

                /**
                /// This call'd better be the last call in this block, so when
                /// it returns we go straight into the return line below.
                 *
                /// We switch the <i>to</i> and <i>from</i> variables,
                /// the total number of points remains the same, and
                /// the <i>currentDistance</i> is divided by 2.
                 */
                ButterflyStage(to, from, numberFftPoints, (currentDistance >> 1));
            }
        }

    }
}
