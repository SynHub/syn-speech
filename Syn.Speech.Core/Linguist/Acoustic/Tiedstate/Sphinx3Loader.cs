using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using Syn.Speech.Logging;
using Syn.Speech.Decoders.Adaptation;
using Syn.Speech.Helper;
using Syn.Speech.Linguist.Acoustic.Tiedstate.Tiedmixture;
using Syn.Speech.Util;
using Syn.Speech.Util.Props;
//REFACTORED
namespace Syn.Speech.Linguist.Acoustic.Tiedstate
{
    /**
    /// Loads a tied-state acoustic model generated by the Sphinx-3 trainer.
    /// <p>
    /// The acoustic model is stored as a directory specified by a URL. The
    /// dictionary and language model files are not required to be in the package.
    /// You can specify their locations separately.
    /// </p>
    /// <p>
    /// Configuration file should set mandatory property of component:
    /// <ul>
    /// <li><b>location</b> - this specifies the directory where the actual model
    /// data files are. You can use <b>resource:</b> prefix to refer to files packed
    /// inside jar or any other URI scheme.
    /// </ul>
    /// The actual model data files are named "mdef", "means", "variances",
    /// "transition_matrices", "mixture_weights".
    /// </p>
    /// <p>
    /// If model has some layout that is different default generated by SphinxTrain,
    /// you may specify additional properties like <b>dataLocation</b> to set the
    /// path to the binary files, <b>mdef</b> to set the path to the model definition
    /// file.
    /// </p>
    /// <p>
    /// As an example, lets look at the Wall Street Journal acoustic model JAR file,
    /// which is located at the <code>sphinx4/lib</code> directory. If you run
    /// <code>"jar tf lib/WSJ_8gau_13dCep_16k_40mel_130Hz_6800Hz.jar"</code>, you
    /// will find that its internal structure looks roughly like:
    /// <p/>
    /// 
    /// <pre>
    /// WSJ_8gau_13dCep_16k_40mel_130Hz_6800Hz.jar
    ///   |
    ///   +- license.terms
    ///   +- cd_continuous_8gau
    ///   |   |
    ///   |   +- means
    ///   |   +- variances
    ///   |   +- mixture_weights
    ///   |   +- transition_matrices
    ///   |
    ///   +- dict
    ///   |   |
    ///   |   +- alpha.dict
    ///   |   +- cmudict.0.6d
    ///   |   +- digits.dict
    ///   |   +- fillerdict
    ///   |
    ///   +- etc
    ///       |
    ///       +- WSJ_clean_13dCep_16k_40mel_130Hz_6800Hz.4000.mdef
    ///       +- WSJ_clean_13dCep_16k_40mel_130Hz_6800Hz.ci.mdef
    ///       +- variables.def
    /// </pre>
    /// <p/>
    /// <p>
    /// So the configuration to load this model should look like
    /// 
    /// <pre>
    ///  &lt;component name="wsjLoader" type="edu.cmu.sphinx.linguist.acoustic.tiedstate.Sphinx3Loader"&gt;
    ///     &lt;property name="logMath" value="logMath"/&gt;
    ///        &lt;property name="unitManager" value="unitManager"/&gt;
    ///        &lt;property name="location" value="resource:/WSJ_8gau_13dCep_16k_40mel_130Hz_6800Hz"/&gt;
    ///        &lt;property name="modelDefinition" value="etc/WSJ_clean_13dCep_16k_40mel_130Hz_6800Hz.4000.mdef"/&gt;
    ///        &lt;property name="dataLocation" value="cd_continuous_8gau/"/&gt;
    ///    &lt;/component&gt;
    /// </pre>
    /// 
    /// </p>
    /// <p>
    /// For more details on using SphinxTrain models in sphinx4, see <a
    /// href="../../../../../../../doc/UsingSphinxTrainModels.html">documentation</a>
    /// </p>
     */
    public class Sphinx3Loader : ILoader
    {
        /**
       /// The unit manager
        */
        [S4Component(Type = typeof(UnitManager))]
        public static string PropUnitManager = "unitManager";

        /**
        /// The root location of the model directory structure
         */
        [S4String(Mandatory = true)]
        public static string PropLocation = "location";

        /**
        /// The name of the model definition file (contains the HMM data)
         */
        [S4String(Mandatory = false, DefaultValue = "mdef")]
        public static string PropModel = "modelDefinition";

        /**
        /// Subfolder where the acoustic model can be found
         */
        [S4String(Mandatory = false, DefaultValue = "")]
        public static string PropDataLocation = "dataLocation";

        /**
        /// The property specifying whether context-dependent units should be used.
         */
        [S4Boolean(DefaultValue = true)]
        public static string PropUseCdUnits = "useCDUnits";

        /**
        /// Mixture component score floor.
         */
        [S4Double(DefaultValue = 0.0f)]
        public static string PropMcFloor = "MixtureComponentScoreFloor";

        /**
        /// Variance floor.
         */
        [S4Double(DefaultValue = 0.0001f)]
        public static string PropVarianceFloor = "varianceFloor";

        /**
        /// Mixture weight floor.
         */
        [S4Double(DefaultValue = 1e-7f)]
        public static string PropMwFloor = "mixtureWeightFloor";


        /**
     * Number of top Gaussians to use in scoring
     */
        [S4Integer(DefaultValue = 4)]
        public readonly static string PropTopn = "topGaussiansNum";

        protected static string Filler = "filler";
        protected static string SilenceCiphone = "SIL";
        protected static int ByteOrderMagic = 0x11223344;

        /// <summary>
        /// Supports this version of the acoustic model
        /// </summary>
        public static string ModelVersion = "0.3";

        private const int ContextSize = 1;
        private int _numBase;

        private MixtureComponentSet[] _phoneticTiedMixtures;

        protected LogMath LogMath;
        private UnitManager _unitManager;
        private Boolean _swap;

        private const string DensityFileVersion = "1.0";
        private const string MixwFileVersion = "1.0";
        private const string TmatFileVersion = "1.0";
        private const string TransformFileVersion = "0.1";
        // --------------------------------------
        // Configuration variables
        // --------------------------------------
        protected string Model;
        protected string DataLocation;
        protected float DistFloor;
        protected float MixtureWeightFloor;
        protected float VarianceFloor;
        private int _topGauNum;
        protected Boolean UseCDUnits;
        private Boolean _loaded;

        public Sphinx3Loader(URL location, string model, string dataLocation,
                UnitManager unitManager, float distFloor, float mixtureWeightFloor,
                float varianceFloor, int topGauNum, Boolean useCDUnits)
        {

            Init(location, model, dataLocation, unitManager, distFloor,
                    mixtureWeightFloor, varianceFloor, topGauNum, useCDUnits);
        }


        protected void Init(URL location, string model, string dataLocatoin,
                UnitManager unitManager, float distFloor, float mixtureWeightFloor,
                float varianceFloor, int topGauNum, Boolean useCDUnits)
        {
            LogMath = LogMath.GetLogMath();
            Location = location;
            Model = model;
            DataLocation = dataLocatoin;
            _unitManager = unitManager;
            DistFloor = distFloor;
            MixtureWeightFloor = mixtureWeightFloor;
            VarianceFloor = varianceFloor;
            _topGauNum = topGauNum;
            UseCDUnits = useCDUnits;
        }

        public Sphinx3Loader()
        {

        }

        public int NumStates { get; private set; }

        public int NumStreams { get; private set; }

        public int NumGaussiansPerState { get; private set; }

        public int[] VectorLength { get; private set; }

        public int[] Senone2Ci { get; private set; }

        public URL Location { get; private set; }

        public bool HasTiedMixtures()
        {
            var modelType = Properties.GetProperty("-model", "cont");
            return modelType.Equals("ptm");
        }

        public void NewProperties(PropertySheet ps)
        {

            Init(ConfigurationManagerUtils.GetResource(PropLocation, ps),
                    ps.GetString(PropModel), ps.GetString(PropDataLocation),
                    (UnitManager)ps.GetComponent(PropUnitManager),
                    ps.GetFloat(PropMcFloor), ps.GetFloat(PropMwFloor),
                    ps.GetFloat(PropVarianceFloor),
                    ps.GetInt(PropTopn),
                    ps.GetBoolean(PropUseCdUnits));
        }

        // This function is a bit different from the
        // ConfigurationManagerUtils.getResource
        // for compatibility reasons. By default it looks for the resources, not
        // for the files.
        protected Stream GetDataStream(String path)
        {
            return new FileStream(path, FileMode.Open);
        }

        public void Load()
        {
            if (!_loaded)
            {
                TimerPool.GetTimer(this, "Load AM").Start();

                HmmManager = new HMMManager();
                ContextIndependentUnits = new LinkedHashMap<String, Unit>();

                // dummy pools for these elements
                MeansTransformationMatrixPool = null;
                MeansTransformationVectorPool = null;
                VarianceTransformationMatrixPool = null;
                VarianceTransformationVectorPool = null;
                TransformMatrix = null;

                // do the actual acoustic model loading
                try
                {
                    LoadModelFiles(Model);
                }
                catch (UriFormatException e)
                {
                    this.LogInfo(e.Message);
                    throw new RuntimeException(e);
                }

                // done
                _loaded = true;
                TimerPool.GetTimer(this, "Load AM").Stop();
            }
        }

        /**
        /// Return the HmmManager.
        /// 
        /// @return the hmmManager
         */

        protected HMMManager HmmManager { get; private set; }

        /**
        /// Return the MatrixPool.
        /// 
        /// @return the matrixPool
         */

        protected Pool<float[][]> MatrixPool { get; set; }

        /**
        /// Return the MixtureWeightsPool.
        /// 
        /// @return the mixtureWeightsPool
         */

        public GaussianWeights MixtureWeightsPool { get; protected set; }

        /// <summary>
        ///  Loads the AcousticModel from a directory in the file system.
        /// </summary>
        /// <param name="modelDef">the name of the acoustic modelDef; if null we just load from the default location</param>
        protected void LoadModelFiles(String modelDef)
        {

            this.LogInfo("Loading Sphinx3 acoustic model: " + modelDef);
            this.LogInfo("    modelName: " + Model);
            this.LogInfo("    dataLocation   : " + DataLocation);

            //TODO: datalocation is being ignored here

            MeansPool = LoadDensityFile(Path.Combine(Location.Path, "means"), -Float.MAX_VALUE);
            VariancePool = LoadDensityFile(Path.Combine(Location.Path, "variances"), VarianceFloor);
            MixtureWeightsPool = LoadMixtureWeights(Path.Combine(Location.Path, "mixture_weights"), MixtureWeightFloor);
            MatrixPool = LoadTransitionMatrices(Path.Combine(Location.Path, "transition_matrices"));
            TransformMatrix = LoadTransformMatrix(Path.Combine(Location.Path, "feature_transform"));
            Properties = LoadModelProps(Path.Combine(Location.Path, "feat.params"));


            if (HasTiedMixtures())
            {
                GetSenoneToCIPhone();
                SenonePool = CreateTiedSenonePool(DistFloor, VarianceFloor);
            }
            else
            {
                //create regular senone poll
                SenonePool = CreateSenonePool(DistFloor, VarianceFloor);
            }

            // load the HMM modelDef file
            var modelStream = GetDataStream(Path.Combine(Location.Path, Model));
            if (modelStream == null)
            {
                throw new IOException("can't find modelDef " + Model);
            }
            LoadHMMPool(UseCDUnits, modelStream, Path.Combine(Location.Path, Model));

            // modelProps = loadModelProps(CurrentDir + "\\feat.params");
        }

        private void GetSenoneToCIPhone()
        {
            var inputStream = GetDataStream(Path.Combine(Location.Path, Model));
            if (inputStream == null)
            {
                throw new IOException("can't find modelDef " + Model);
            }

            var est = new ExtendedStreamTokenizer(inputStream, '#', false);
            this.LogInfo("Loading HMM file from: " + Model);

            est.ExpectString(ModelVersion);

            _numBase = est.GetInt("numBase");
            est.ExpectString("n_base");

            var numTri = est.GetInt("numTri");
            est.ExpectString("n_tri");

            var numStateMap = est.GetInt("numStateMap");
            est.ExpectString("n_state_map");

            var numTiedState = est.GetInt("numTiedState");
            est.ExpectString("n_tied_state");

            Senone2Ci = new int[numTiedState];

            est.GetInt("numContextIndependentTiedState");
            est.ExpectString("n_tied_ci_state");

            var numTiedTransitionMatrices = est.GetInt("numTiedTransitionMatrices");
            est.ExpectString("n_tied_tmat");

            var numStatePerHMM = numStateMap / (numTri + _numBase);

            Debug.Assert(numTiedState == MixtureWeightsPool.StatesNum);
            Debug.Assert(numTiedTransitionMatrices == MatrixPool.Size);

            // Load the base phones
            for (var i = 0; i < _numBase + numTri; i++)
            {
                //TODO name this magic const somehow
                for (var j = 0; j < 5; j++)
                    est.GetString();
                var tmat = est.GetInt("tmat");

                for (var j = 0; j < numStatePerHMM - 1; j++)
                {
                    Senone2Ci[est.GetInt("j")] = tmat;
                }
                est.ExpectString("N");

                Debug.Assert(tmat < numTiedTransitionMatrices);
            }

            est.Close();
        }

        private Pool<ISenone> CreateTiedSenonePool(float distFloor, float varianceFloor)
        {
            var pool = new Pool<ISenone>("senones");

            var numMeans = MeansPool.Size;
            var numVariances = VariancePool.Size;
            var numGaussiansPerState = MixtureWeightsPool.GauPerState;
            var numSenones = MixtureWeightsPool.StatesNum;
            var numStreams = MixtureWeightsPool.StreamsNum;

            this.LogInfo("Senones " + numSenones);
            this.LogInfo("Gaussians Per State " + numGaussiansPerState);
            this.LogInfo("Means " + numMeans);
            this.LogInfo("Variances " + numVariances);

            Debug.Assert(numGaussiansPerState > 0);
            Debug.Assert(numVariances == _numBase * numGaussiansPerState * numStreams);
            Debug.Assert(numMeans == _numBase * numGaussiansPerState * numStreams);

            var meansTransformationMatrix = MeansTransformationMatrixPool == null ? null
                    : MeansTransformationMatrixPool.Get(0);
            var meansTransformationVector = MeansTransformationVectorPool == null ? null
                    : MeansTransformationVectorPool.Get(0);
            var varianceTransformationMatrix = VarianceTransformationMatrixPool == null ? null
                    : VarianceTransformationMatrixPool.Get(0);
            var varianceTransformationVector = VarianceTransformationVectorPool == null ? null
                    : VarianceTransformationVectorPool.Get(0);

            _phoneticTiedMixtures = new MixtureComponentSet[_numBase];
            for (var i = 0; i < _numBase; i++)
            {
                var mixtureComponents = new List<PrunableMixtureComponent[]>();
                for (var j = 0; j < numStreams; j++)
                {
                    var featMixtureComponents = new PrunableMixtureComponent[numGaussiansPerState];
                    for (var k = 0; k < numGaussiansPerState; k++)
                    {
                        var whichGaussian = i * numGaussiansPerState * numStreams + j * numGaussiansPerState + k;
                        featMixtureComponents[k] = new PrunableMixtureComponent(
                                MeansPool.Get(whichGaussian),
                                meansTransformationMatrix, meansTransformationVector,
                                VariancePool.Get(whichGaussian),
                                varianceTransformationMatrix,
                                varianceTransformationVector, distFloor, varianceFloor, k);
                    }
                    mixtureComponents.Add(featMixtureComponents);
                }
                _phoneticTiedMixtures[i] = new MixtureComponentSet(mixtureComponents, _topGauNum);
            }

            for (var i = 0; i < numSenones; i++)
            {
                ISenone senone = new SetBasedGaussianMixture(MixtureWeightsPool, _phoneticTiedMixtures[Senone2Ci[i]], i);
                pool.Put(i, senone);
            }
            return pool;
        }

        public LinkedHashMap<string, Unit> ContextIndependentUnits { get; private set; }

        /**
        /// Creates the senone pool from the rest of the pools.
        /// 
        /// @param distFloor
        ///            the lowest allowed score
        /// @param varianceFloor
        ///            the lowest allowed variance
        /// @return the senone pool
         */
        public Pool<ISenone> CreateSenonePool(float distFloor, float varianceFloor)
        {
            var pool = new Pool<ISenone>("senones");
            var numMeans = MeansPool.Size;
            var numVariances = VariancePool.Size;
            var numGaussiansPerSenone = MixtureWeightsPool.GauPerState;
            var numSenones = MixtureWeightsPool.StatesNum;
            var numStreams = MixtureWeightsPool.StreamsNum;
            var whichGaussian = 0;

            this.LogInfo("Senones " + numSenones);
            this.LogInfo("Gaussians Per Senone " + numGaussiansPerSenone);
            this.LogInfo("Means " + numMeans);
            this.LogInfo("Variances " + numVariances);

            Debug.Assert(numGaussiansPerSenone > 0);
            Debug.Assert(numVariances == numSenones * numGaussiansPerSenone);
            Debug.Assert(numMeans == numSenones * numGaussiansPerSenone);

            var meansTransformationMatrix = MeansTransformationMatrixPool == null ? null
                    : MeansTransformationMatrixPool.Get(0);
            var meansTransformationVector = MeansTransformationVectorPool == null ? null
                    : MeansTransformationVectorPool.Get(0);
            var varianceTransformationMatrix = VarianceTransformationMatrixPool == null ? null
                    : VarianceTransformationMatrixPool.Get(0);
            var varianceTransformationVector = VarianceTransformationVectorPool == null ? null
                    : VarianceTransformationVectorPool.Get(0);

            for (var i = 0; i < numSenones; i++)
            {
                var mixtureComponents = new MixtureComponent[numGaussiansPerSenone
                        * numStreams];
                for (var j = 0; j < numGaussiansPerSenone; j++)
                {
                    mixtureComponents[j] = new MixtureComponent(
                            MeansPool.Get(whichGaussian),
                            meansTransformationMatrix, meansTransformationVector,
                            VariancePool.Get(whichGaussian),
                            varianceTransformationMatrix,
                            varianceTransformationVector, distFloor, varianceFloor);

                    whichGaussian++;
                }

                ISenone senone = new GaussianMixture(MixtureWeightsPool, mixtureComponents, i);
                pool.Put(i, senone);
            }
            return pool;
        }

        /**
        /// Loads the sphinx3 density file, a set of density arrays are created and
        /// placed in the given pool.
        /// 
        /// @param path
        ///            the name of the data
        /// @param floor
        ///            the minimum density allowed
        /// @return a pool of loaded densities
        /// @throws FileNotFoundException
        ///             if a file cannot be found
        /// @throws IOException
        ///             if an error occurs while loading the data
         */
        public Pool<float[]> LoadDensityFile(String path, float floor)
        {
            var props = new Dictionary<String, Object>();
            var blockSize = 0;

            var dis = ReadS3BinaryHeader(path, props);

            var version = props["version"].ToString();

            if (version == null || !version.Equals(DensityFileVersion))
            {
                throw new IOException("Unsupported version in " + path);
            }

            var checksum = props["chksum0"].ToString();
            var doCheckSum = (checksum != null && checksum.Equals("yes"));
            ResetChecksum();

            var numStates = readInt(dis);
            var numStreams = readInt(dis);
            var numGaussiansPerState = readInt(dis);

            var vectorLength = new int[numStreams];
            for (var i = 0; i < numStreams; i++)
            {
                vectorLength[i] = readInt(dis);
            }

            var rawLength = readInt(dis);

            this.LogInfo("Number of states " + numStates);
            this.LogInfo("Number of streams " + numStreams);
            this.LogInfo("Number of gaussians per state " + numGaussiansPerState);
            this.LogInfo("Vector length " + vectorLength.Length);
            this.LogInfo("Raw length " + rawLength);

            for (var i = 0; i < numStreams; i++)
            {
                blockSize += vectorLength[i];
            }

            Debug.Assert(rawLength == numGaussiansPerState * blockSize * numStates);

            var pool = new Pool<float[]>(path);
            pool.SetFeature(Feature.NumSenones, numStates);
            pool.SetFeature(Feature.NumStreams, numStreams);
            pool.SetFeature(Feature.NumGaussiansPerState, numGaussiansPerState);

            for (var i = 0; i < numStates; i++)
            {
                for (var j = 0; j < numStreams; j++)
                {
                    for (var k = 0; k < numGaussiansPerState; k++)
                    {
                        var density = ReadFloatArray(dis, vectorLength[j]);
                        Utilities.floorData(density, floor);
                        pool.Put(i * numStreams * numGaussiansPerState + j
                               * numGaussiansPerState + k, density);
                    }
                }
            }

            ValidateChecksum(dis, doCheckSum);

            dis.Close();

            NumStates = numStates;
            NumStreams = numStreams;
            NumGaussiansPerState = numGaussiansPerState;
            VectorLength = vectorLength;


            return pool;
        }

        /**
        /// Reads the S3 binary header from the given location + path. Adds header
        /// information to the given set of properties.
        /// 
        /// @param path
        ///            the name of the file
        /// @param props
        ///            the properties
        /// @return the input stream positioned after the header
        /// @throws IOException
        ///             on error
         */
        public Stream ReadS3BinaryHeader(String path, Dictionary<String, Object> _props)
        {
            var inputStream = GetDataStream(path);

            if (inputStream == null)
            {
                throw new IOException("Can't open " + path);
            }
            var dis = new BufferedStream(inputStream, 8192);
            var id = ReadWord(dis);
            if (!id.Equals("s3"))
            {
                throw new IOException("Not proper s3 binary file " + path);
            }
            string name;
            while ((name = ReadWord(dis)) != null)
            {
                if (!name.Equals("endhdr"))
                {
                    var value = ReadWord(dis);
                    _props.Add(name, value);
                }
                else
                {
                    break;
                }
            }
            var byteOrderMagic = ReadInt(dis);
            if (byteOrderMagic == ByteOrderMagic)
            {
                this.LogInfo("Not swapping " + path);
                _swap = false;
            }
            else if (Utilities.SwapInteger(byteOrderMagic) == ByteOrderMagic)
            {
                this.LogInfo("Swapping  " + path);
                _swap = true;
            }
            else
            {
                throw new IOException("Corrupted S3 file " + path);
            }
            return dis;

        }

        /**
        /// Reads the next word (text separated by whitespace) from the given stream.
        /// 
        /// @param dis
        ///            the input stream
        /// @return the next word
        /// @throws IOException
        ///             on error
         */
        string ReadWord(Stream dis)
        {
            var sb = new StringBuilder();
            char c;
            // skip leading whitespace
            do
            {
                c = ReadChar(dis);
            }
            while (Char.IsWhiteSpace(c));
            // read the word
            do
            {
                sb.Append(c);
                c = ReadChar(dis);
            }
            while (!Char.IsWhiteSpace(c));
            return sb.ToString();
        }

        /**
        /// Reads a single char from the stream.
        /// 
        /// @param dis
        ///            the stream to read
        /// @return the next character on the stream
        /// @throws IOException
        ///             if an error occurs
         */
        private static char ReadChar(Stream dis)
        {
            return (char)dis.ReadByte();
        }

        /* Stores checksum during loading */
        private long _calculatedCheckSum;

        /**
        /// Resets the checksum before loading a new chunk of data
         */
        private void ResetChecksum()
        {
            _calculatedCheckSum = 0;
        }

        /**
        /// Validates checksum in the stream
        /// 
        /// @param dis
        ///            input stream
        /// @param doCheckSum
        ///            validates
        /// @throws IOException
        ///             on error
         **/
        private void ValidateChecksum(Stream dis, Boolean doCheckSum)
        {
            if (!doCheckSum)
                return;
            var oldCheckSum = (int)_calculatedCheckSum;
            var checkSum = readInt(dis);
            if (checkSum != oldCheckSum)
            {
                throw new IOException("Invalid checksum "
                        + _calculatedCheckSum.ToString("X") + " must be "
                        + checkSum.ToString("X"));
            }
        }

        /**
        /// Read an integer from the input stream, byte-swapping as necessary.
        /// 
        /// @param dis
        ///            the input stream
        /// @return an integer value
        /// @throws IOException
        ///             on error
         */
        public int readInt(Stream dis)
        {
            var val = 0;
            if (_swap)
            {
                val = Utilities.ReadLittleEndianInt(dis);
            }
            else
            {
                val = dis.ReadByte() << 24 | dis.ReadByte() << 16 | dis.ReadByte() << 8 | dis.ReadByte();
            }
            _calculatedCheckSum = ((_calculatedCheckSum << 20 | _calculatedCheckSum >> 12) + val) & 0xFFFFFFFFL;
            return val;
        }

        public int ReadInt(Stream dis)
        {
            var val = dis.ReadByte() << 24 | dis.ReadByte() << 16 | dis.ReadByte() << 8 | dis.ReadByte();
            return val;
        }



        /**
        /// Read a float from the input stream, byte-swapping as necessary.
        /// 
        /// @param dis
        ///            the input stream
        /// @return a floating pint value
        /// @throws IOException
        ///             on error
         */
        public float ReadFloat(Stream dis)
        {
            int val;
            if (_swap)
            {
                val = Utilities.ReadLittleEndianInt(dis);
            }
            else
            {
                val = ReadInt(dis);
            }
            _calculatedCheckSum = ((_calculatedCheckSum << 20 | _calculatedCheckSum >> 12) + val) & 0xFFFFFFFFL;
            return Float.IntBitsToFloat(val);
        }

        /**
        /// Reads the given number of floats from the stream and returns them in an
        /// array of floats.
        /// 
        /// @param dis
        ///            the stream to read data from
        /// @param size
        ///            the number of floats to read
        /// @return an array of size float elements
        /// @throws IOException
        ///             if an exception occurs
         */
        public float[] ReadFloatArray(Stream dis, int size)
        {
            var data = new float[size];
            for (var i = 0; i < size; i++)
            {
                data[i] = ReadFloat(dis);
            }
            return data;
        }

        public HMMPosition GetHMMPosition(String pos)
        {
            //BEGIN   =  ('b'), // HMM is at the beginning position of the word
            //END     =  ('e'), // HMM is at the end position of the word
            //SINGLE   = ('s'), // HMM is at the beginning and the end of the word
            //INTERNAL = ('i'), // HMM is completely internal to the word
            //UNDEFINED= ('-')// HMM is at an undefined position in the word
            if (pos == "b")return HMMPosition.Begin;
            if (pos == "e")return HMMPosition.End;
            if (pos == "s")return HMMPosition.Single;
            if (pos == "i")return HMMPosition.Internal;

            return HMMPosition.Undefined;
        }

        /**
        /// Loads the sphinx3 density file, a set of density arrays are created and
        /// placed in the given pool.
        /// 
        /// @param useCDUnits
        ///            if true, loads also the context dependent units
        /// @param inputStream
        ///            the open input stream to use
        /// @param path
        ///            the path to a density file
        /// @throws FileNotFoundException
        ///             if a file cannot be found
        /// @throws IOException
        ///             if an error occurs while loading the data
         */
        protected void LoadHMMPool(Boolean useCDUnits, Stream inputStream,
                string path)
        {

            var est = new ExtendedStreamTokenizer(inputStream,
                    '#', false);

            this.LogInfo("Loading HMM file from: " + path);

            est.ExpectString(ModelVersion);

            var numBase = est.GetInt("numBase");
            est.ExpectString("n_base");

            var numTri = est.GetInt("numTri");
            est.ExpectString("n_tri");

            var numStateMap = est.GetInt("numStateMap");
            est.ExpectString("n_state_map");

            var numTiedState = est.GetInt("numTiedState");
            est.ExpectString("n_tied_state");

            var numContextIndependentTiedState = est
                    .GetInt("numContextIndependentTiedState");
            est.ExpectString("n_tied_ci_state");

            var numTiedTransitionMatrices = est.GetInt("numTiedTransitionMatrices");
            est.ExpectString("n_tied_tmat");

            var numStatePerHMM = numStateMap / (numTri + numBase);

            Debug.Assert(numTiedState == MixtureWeightsPool.StatesNum);
            Debug.Assert(numTiedTransitionMatrices == MatrixPool.Size);

            // Load the base phones
            for (var i = 0; i < numBase; i++)
            {
                var name = est.GetString();
                var left = est.GetString();
                var right = est.GetString();
                var position = est.GetString();
                var attribute = est.GetString();
                var tmat = est.GetInt("tmat");

                var stid = new int[numStatePerHMM - 1];

                for (var j = 0; j < numStatePerHMM - 1; j++)
                {
                    stid[j] = est.GetInt("j");
                    Debug.Assert(stid[j] >= 0 && stid[j] < numContextIndependentTiedState);
                }
                est.ExpectString("N");

                Debug.Assert(left.Equals("-"));
                Debug.Assert(right.Equals("-"));
                Debug.Assert(position.Equals("-"));
                Debug.Assert(tmat < numTiedTransitionMatrices);

                var unit = _unitManager.GetUnit(name, attribute.Equals(Filler));
                ContextIndependentUnits.Put(unit.Name, unit);


                //this.LogInfo("Loaded " + unit.ToString());

                // The first filler
                if (unit.IsFiller && unit.Name.Equals(SilenceCiphone))
                {
                    unit = UnitManager.Silence;
                }

                var transitionMatrix = MatrixPool.Get(tmat);
                var ss = GetSenoneSequence(stid);

                IHMM hmm = new SenoneHMM(unit, ss, transitionMatrix, GetHMMPosition(position));
                HmmManager.Put(hmm);
            }

            if (HmmManager.Get(HMMPosition.Undefined, UnitManager.Silence) == null)
            {
                throw new IOException("Could not find SIL unit in acoustic model");
            }

            // Load the context dependent phones. If the useCDUnits
            // property is false, the CD phones will not be created, but
            // the values still need to be read in from the file.

            var lastUnitName = "";
            Unit lastUnit = null;
            int[] lastStid = null;
            SenoneSequence lastSenoneSequence = null;

            for (var i = 0; i < numTri; i++)
            {
                var name = est.GetString();
                var left = est.GetString();
                var right = est.GetString();
                var position = est.GetString();
                var attribute = est.GetString();
                var tmat = est.GetInt("tmat");

                var stid = new int[numStatePerHMM - 1];

                for (var j = 0; j < numStatePerHMM - 1; j++)
                {
                    stid[j] = est.GetInt("j");
                    Debug.Assert(stid[j] >= numContextIndependentTiedState
                            && stid[j] < numTiedState);
                }
                est.ExpectString("N");

                Debug.Assert(!left.Equals("-"));
                Debug.Assert(!right.Equals("-"));
                Debug.Assert(!position.Equals("-"));
                Debug.Assert(attribute.Equals("n/a"));
                Debug.Assert(tmat < numTiedTransitionMatrices);

                if (useCDUnits)
                {
                    Unit unit;
                    var unitName = (name + ' ' + left + ' ' + right);

                    if (unitName.Equals(lastUnitName))
                    {
                        unit = lastUnit;
                    }
                    else
                    {
                        var leftContext = new Unit[1];
                        leftContext[0] = ContextIndependentUnits.Get(left);

                        var rightContext = new Unit[1];
                        rightContext[0] = ContextIndependentUnits.Get(right);

                        Context context = LeftRightContext.Get(leftContext,
                                rightContext);
                        unit = _unitManager.GetUnit(name, false, context);
                    }
                    lastUnitName = unitName;
                    lastUnit = unit;


                    //this.LogInfo("Loaded " + unit.ToString());


                    var transitionMatrix = MatrixPool.Get(tmat);

                    var ss = lastSenoneSequence;
                    if (ss == null || !SameSenoneSequence(stid, lastStid))
                    {
                        ss = GetSenoneSequence(stid);
                    }
                    lastSenoneSequence = ss;
                    lastStid = stid;

                    IHMM hmm = new SenoneHMM(unit, ss, transitionMatrix, GetHMMPosition(position));
                    HmmManager.Put(hmm);
                }
            }

            est.Close();
        }

        /**
        /// Returns true if the given senone sequence IDs are the same.
        /// 
        /// @return true if the given senone sequence IDs are the same, false
        ///         otherwise
         */
        protected Boolean SameSenoneSequence(int[] ssid1, int[] ssid2)
        {
            if (ssid1.Length == ssid2.Length)
            {
                for (var i = 0; i < ssid1.Length; i++)
                {
                    if (ssid1[i] != ssid2[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        /**
        /// Gets the senone sequence representing the given senones.
        /// 
        /// @param stateid
        ///            is the array of senone state ids
        /// @return the senone sequence associated with the states
         */
        protected SenoneSequence GetSenoneSequence(int[] stateid)
        {
            var senones = new ISenone[stateid.Length];
            for (var i = 0; i < stateid.Length; i++)
            {
                senones[i] = SenonePool.Get(stateid[i]);
            }
            return new SenoneSequence(senones);
        }

        /**
        /// Loads the mixture weights (Binary).
        /// 
        /// @param path
        ///            the path to the mixture weight file
        /// @param floor
        ///            the minimum mixture weight allowed
        /// @return a pool of mixture weights
        /// @throws FileNotFoundException
        ///             if a file cannot be found
        /// @throws IOException
        ///             if an error occurs while loading the data
         */
        protected GaussianWeights LoadMixtureWeights(String path, float floor)
        {
            this.LogInfo("Loading mixture weights from: " + path);

            var props = new Dictionary<String, Object>(); //TODO: Use JProperties here

            var dis = ReadS3BinaryHeader(path, props);

            var version = props["version"].ToString();

            if (version == null || !version.Equals(MixwFileVersion))
            {
                throw new IOException("Unsupported version in " + path);
            }

            var checksum = props["chksum0"].ToString();
            var doCheckSum = (checksum != null && checksum.Equals("yes"));
            ResetChecksum();

            var numStates = readInt(dis);
            var numStreams = readInt(dis);
            var numGaussiansPerState = readInt(dis);
            var numValues = readInt(dis);
            var mixtureWeights = new GaussianWeights(path, numStates, numGaussiansPerState, numStreams);

            this.LogInfo("Number of states " + numStates);
            this.LogInfo("Number of streams " + numStreams);
            this.LogInfo("Number of gaussians per state " + numGaussiansPerState);

            Debug.Assert(numValues == numStates * numStreams * numGaussiansPerState);

            for (var i = 0; i < numStates; i++)
            {
                for (var j = 0; j < numStreams; j++)
                {
                    var logStreamMixtureWeight = ReadFloatArray(dis,
                            numGaussiansPerState);
                    Utilities.Normalize(logStreamMixtureWeight);
                    Utilities.floorData(logStreamMixtureWeight, floor);
                    LogMath.LinearToLog(logStreamMixtureWeight);
                    mixtureWeights.Put(i, j, logStreamMixtureWeight);
                }
            }

            ValidateChecksum(dis, doCheckSum);

            dis.Close();
            return mixtureWeights;
        }

        /**
        /// Loads the transition matrices (Binary).
        /// 
        /// @param path
        ///            the path to the transitions matrices
        /// @return a pool of transition matrices
        /// @throws FileNotFoundException
        ///             if a file cannot be found
        /// @throws IOException
        ///             if an error occurs while loading the data
         */
        protected Pool<float[][]> LoadTransitionMatrices(String path)
        {
            this.LogInfo("Loading transition matrices from: " + path);

            var props = new Dictionary<String, Object>();
            var dis = ReadS3BinaryHeader(path, props);

            var version = props["version"].ToString();

            if (version == null || !version.Equals(TmatFileVersion))
            {
                throw new IOException("Unsupported version in " + path);
            }

            var checksum = props["chksum0"].ToString();
            var doCheckSum = (checksum != null && checksum.Equals("yes"));
            ResetChecksum();

            var pool = new Pool<float[][]>(path);

            var numMatrices = readInt(dis);
            var numRows = readInt(dis);
            var numStates = readInt(dis);
            var numValues = readInt(dis);

            Debug.Assert(numValues == numStates * numRows * numMatrices);

            for (var i = 0; i < numMatrices; i++)
            {
                var tmat = new float[numStates][];
                // last row should be zeros
                tmat[numStates - 1] = new float[numStates];
                LogMath.LinearToLog(tmat[numStates - 1]);

                for (var j = 0; j < numRows; j++)
                {
                    tmat[j] = ReadFloatArray(dis, numStates);
                    Utilities.NonZeroFloor(tmat[j], 0f);
                    Utilities.Normalize(tmat[j]);
                    LogMath.LinearToLog(tmat[j]);
                }
                pool.Put(i, tmat);
            }

            ValidateChecksum(dis, doCheckSum);

            dis.Close();
            return pool;
        }

        /**
        /// Loads the transform matrices (Binary).
        /// 
        /// @param path
        ///            the path to the transform matrix
        /// @return a transform matrix
        /// @throws java.io.FileNotFoundException
        ///             if a file cannot be found
        /// @throws java.io.IOException
        ///             if an error occurs while loading the data
         */
        protected float[][] LoadTransformMatrix(String path)
        {
            this.LogInfo("Loading transform matrix from: " + path);

            var props = new Dictionary<String, Object>();

            Stream dis;
            try
            {
                dis = ReadS3BinaryHeader(path, props);
            }
            catch (IOException)
            {
                return null;
            }

            var version = props["version"].ToString();

            if (version == null || !version.Equals(TransformFileVersion))
            {
                throw new IOException("Unsupported version in " + path);
            }

            var checksum = props["chksum0"].ToString();
            var doCheckSum = (checksum != null && checksum.Equals("yes"));
            ResetChecksum();

            readInt(dis);
            var numRows = readInt(dis);
            var numValues = readInt(dis);
            var num = readInt(dis);

            Debug.Assert(num == numRows * numValues);

            var result = new float[numRows][];
            for (var i = 0; i < numRows; i++)
            {
                result[i] = ReadFloatArray(dis, numValues);
            }

            ValidateChecksum(dis, doCheckSum);

            dis.Close();

            return result;
        }

        public void ClearGauScores()
        {
            if (_phoneticTiedMixtures == null)
                return;
            foreach (var mixture in _phoneticTiedMixtures)
                mixture.ClearStoredScores();
        }

        public void SetGauScoresQueueLength(int scoresQueueLen)
        {
            if (_phoneticTiedMixtures == null)
                return;
            foreach (var mixture in _phoneticTiedMixtures)
                mixture.SetScoreQueueLength(scoresQueueLen);
        }

        public Pool<float[]> MeansPool { get; protected set; }

        public Pool<float[][]> MeansTransformationMatrixPool { get; private set; }

        public Pool<float[]> MeansTransformationVectorPool { get; private set; }

        public Pool<float[]> VariancePool { get; protected set; }

        public Pool<float[][]> VarianceTransformationMatrixPool { get; private set; }

        public Pool<float[]> VarianceTransformationVectorPool { get; private set; }


        public Pool<float[][]> TransitionMatrixPool
        {
            get { return MatrixPool; }
        }

        public float[][] TransformMatrix { get; protected set; }

        public Pool<ISenone> SenonePool { get; set; }

        public int LeftContextSize
        {
            get { return ContextSize; }
        }

        public int RightContextSize
        {
            get { return ContextSize; }
        }

        public HMMManager HMMManager
        {
            get { return HmmManager; }
        }

        public void LogInfo()
        {
            this.LogInfo("Loading tied-state acoustic model from: " + Location);
            MeansPool.LogInfo();
            VariancePool.LogInfo();
            MatrixPool.LogInfo();
            SenonePool.LogInfo();

            if (MeansTransformationMatrixPool != null)
                MeansTransformationMatrixPool.LogInfo();
            if (MeansTransformationVectorPool != null)
                MeansTransformationVectorPool.LogInfo();
            if (VarianceTransformationMatrixPool != null)
                VarianceTransformationMatrixPool.LogInfo();
            if (VarianceTransformationVectorPool != null)
                VarianceTransformationVectorPool.LogInfo();

            MixtureWeightsPool.LogInfo();
            SenonePool.LogInfo();
            this.LogInfo("Context Independent Unit Entries: "
                    + ContextIndependentUnits.Count);
            HmmManager.LogInfo();
        }

        public JProperties Properties { get; protected set; }

        private JProperties LoadModelProps(String path)
        {
            var props = new JProperties();
            var reader = new StreamReader(path);
            string line;
            while ((line = reader.ReadLine()) != null)
            {
                var tokens = line.Split(new[] { " " }, StringSplitOptions.RemoveEmptyEntries);
                props.Add(tokens[0], tokens[1]);
            }
            return props;

        }

        public void Update(Transform transform, ClusteredDensityFileData clusters)
        {
            for (var index = 0; index < MeansPool.Size; index++)
            {
                var transformClass = clusters.GetClassIndex(index);
                var tmean = new float[VectorLength[0]];
                var mean = MeansPool.Get(index);

                for (var l = 0; l < VectorLength[0]; l++)
                {
                    tmean[l] = 0;
                    for (var m = 0; m < VectorLength[0]; m++)
                    {
                        tmean[l] += transform.As[transformClass][0][l][m]
                               * mean[m];
                    }
                    tmean[l] += transform.Bs[transformClass][0][l];
                }
                Array.Copy(tmean, 0, mean, 0, tmean.Length);
            }
        }
    }
}
