using System;
using System.Collections.Generic;
using Syn.Speech.Logging;
using Syn.Speech.Api;
using Syn.Speech.Decoders.Search;
using Syn.Speech.Logging;
using Syn.Speech.Results;
using Syn.Speech.Util.Props;
//PATROLLED + REFACTORED
namespace Syn.Speech.Decoders
{
    /// <summary>
    /// An abstract decoder which implements all functionality which is independent of the used decoding-paradigm (pull/push).
    /// </summary>
    public abstract class AbstractDecoder : IResultProducer
    {
        /// <summary>
        /// The property that defines the name of the search manager to use
        /// </summary>
        [S4Component(Type = typeof(ISearchManager))]
        public static string PropSearchManager = "searchManager";
        protected ISearchManager SearchManager;
        /// <summary>
        /// The property that defines the name of the search manager to use
        /// </summary>
        [S4ComponentList(Type = typeof(IResultListener))]
        public static string PropResultListeners = "resultListeners";
        protected List<IResultListener> ResultListeners = new List<IResultListener>();
        /// <summary>
        /// If set to true the used search-manager will be automatically allocated
        ///  in <code>newProperties()</code>.
        /// </summary>
        [S4Boolean(DefaultValue = false)]
        public static string AutoAllocate = "autoAllocate";
        /// <summary>
        /// If set to <code>false</code> the used search-manager all registered
        /// result listeners will be notified only for final results. Per default
        /// non-final results don't trigger notification, because in most
        /// application the utterance final result will be sufficient.
        /// </summary>
        [S4Boolean(DefaultValue = false)]
        public static string FireNonFinalResults = "fireNonFinalResults";
        private Boolean _fireNonFinalResults;

        private string _name;


        public AbstractDecoder()
        {
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="searchManager"></param>
        /// <param name="fireNonFinalResults"></param>
        /// <param name="autoAllocate"></param>
        /// <param name="resultListeners"></param>
        public AbstractDecoder(ISearchManager searchManager, Boolean fireNonFinalResults, Boolean autoAllocate, List<IResultListener> resultListeners)
        {
            var name = base.GetType().Name;
            Init(name, searchManager, fireNonFinalResults, autoAllocate, resultListeners);
        }
        /// <summary>
        /// Decode frames until recognition is complete
        /// </summary>
        /// <param name="referenceText">the reference text (or null)</param>
        /// <returns>a result</returns>
        public abstract Result Decode(String referenceText);

        public virtual void NewProperties(PropertySheet ps)
        {
            Init(ps.GetInstanceName(), (ISearchManager)ps.GetComponent(PropSearchManager), ps.GetBoolean(FireNonFinalResults), ps.GetBoolean(AutoAllocate), ps.GetComponentList<IResultListener>(PropResultListeners));
        }

        private void Init(String name, ISearchManager searchManager, Boolean fireNonFinalResults, Boolean autoAllocate, List<IResultListener> listeners)
        {
            _name = name;

            SearchManager = searchManager;
            _fireNonFinalResults = fireNonFinalResults;

            if (autoAllocate)
            {
                searchManager.Allocate();
            }

            foreach (var listener in listeners)
            {
                AddResultListener(listener);
            }
        }


        /// <summary>
        /// Allocate resources necessary for decoding
        /// </summary>
        public void Allocate()
        {
            SearchManager.Allocate();
        }


        /// <summary>
        /// Deallocate resources
        /// </summary>
        public void Deallocate()
        {
            SearchManager.Deallocate();
        }

        /// <summary>
        /// Adds a result listener to this recognizer. A result listener is called whenever a new result is generated by the
        /// recognizer. This method can be called in any state.
        /// </summary>
        /// <param name="resultListener"></param>
        public void AddResultListener(IResultListener resultListener)
        {
            ResultListeners.Add(resultListener);
        }

        /// <summary>
        /// Removes a previously added result listener. This method can be called in any state.
        /// </summary>
        /// <param name="resultListener">the listener to remove</param>
        public void RemoveResultListener(IResultListener resultListener)
        {
            ResultListeners.Remove(resultListener);
        }
        /// <summary>
        /// Fires new results as soon as they become available.
        /// </summary>
        /// <param name="result">the new result</param>
        protected void FireResultListeners(Result result)
        {
            if (_fireNonFinalResults || result.IsFinal())
            {
                foreach (var resultListener in ResultListeners)
                {
                    resultListener.NewResult(result);
                }
            }
            else
            {
                this.LogInfo("skipping non-final result " + result);
            }
        }

        public override string ToString()
        {
            return _name;
        }
    }
}
