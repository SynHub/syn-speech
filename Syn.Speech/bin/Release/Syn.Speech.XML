<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Syn.Speech</name>
    </assembly>
    <members>
        <member name="T:Syn.Logging.Logger">
            <summary>
            Static Log Helper Class.
            </summary>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.CharTokenizer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Alignment.Tokenizer.CharTokenizer"/> class.
            </summary>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.DecisionTree.#ctor(System.IO.StreamReader,System.Int32)">
            <summary>
            Creates a new CART by reading from the given reader.
            </summary>
            <param name="reader">the source of the CART data.</param>
            <param name="nodes">the number of nodes to read for this cart.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.DecisionTree.ParseAndAdd(System.String)">
            <summary>
            Creates a node from the given input line and add it to the CART. 
            It expects the TOTAL line to come before any of the nodes.
            </summary>
            <param name="line">The line of input to parse.</param>
            <exception cref="T:Syn.Speech.Helper.Error"></exception>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.DecisionTree.GetNode(System.String,Syn.Speech.Helper.StringTokenizer,System.Int32)">
            <summary>
            Gets the node based upon the type and tokenizer.
            </summary>
            <param name="type"><code>NODE</code> or <code>LEAF</code></param>
            <param name="tokenizer">The StringTokenizer containing the data to get.</param>
            <param name="currentNode">The index of the current node we're looking at.</param>
            <returns>The node</returns>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.DecisionTree.ParseValue(System.String)">
            <summary>
            Coerces a string into a value.
            </summary>
            <param name="_string">of the form "type(value)"; for example, "Float(2.3)"</param>
            <returns>The value.</returns>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.DecisionTree.Interpret(Syn.Speech.Alignment.Tokenizer.Item)">
            <summary>
            Passes the given item through this CART and returns the interpretation.
            </summary>
            <param name="item">The item to analyze</param>
            <returns>The interpretation.</returns>
        </member>
        <member name="F:Syn.Speech.Alignment.Tokenizer.DecisionTree.ComparisonNode.ComparisonType">
            <summary>
            The comparison type. One of LESS_THAN, GREATER_THAN, or EQUAL_TO.
            </summary>
        </member>
        <member name="T:Syn.Speech.Alignment.Tokenizer.PronounceableFsm">
            <summary>
            Implements a finite state machine that checks if a given string is pronounceable. 
            If it is pronounceable, the method <code>accept()</code> will return true.
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.Tokenizer.PronounceableFsm.VocabularySize">
            <summary>
            The vocabulary size
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.Tokenizer.PronounceableFsm._transitions">
            <summary>
            The transitions of this FSM
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.Tokenizer.PronounceableFsm.ScanFromFront">
            <summary>
             Whether we should scan the input string from the front.
            </summary>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.PronounceableFsm.#ctor(System.IO.FileInfo,System.Boolean)">
            <summary>
            Constructs a PronounceableFSM with information in the given URL.
            </summary>
            <param name="fileInfo">path To File</param>
            <param name="scanFromFront">Indicates whether this FSM should scan the input string from the front, or from the back.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.PronounceableFsm.#ctor(System.Int32,System.Int32[],System.Boolean)">
            <summary>
            Constructs a PronounceableFSM with the given attributes.
            </summary>
            <param name="vocabularySize">The vocabulary size of the FSM.</param>
            <param name="transitions">The transitions of the FSM.</param>
            <param name="scanFromFront">Indicates whether this FSM should scan the input string from the front, or from the back.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.PronounceableFsm.LoadText(System.String)">
            <summary>
            Loads the ASCII specification of this FSM from the given InputStream.
            </summary>
            <param name="toRead">he input stream to load from.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.PronounceableFsm.ParseLastInt(System.String)">
            <summary>
             Returns the integer value of the last integer in the given string.
            </summary>
            <param name="line">The line to parse the integer from.</param>
            <returns>An integer</returns>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.PronounceableFsm.Transition(System.Int32,System.Int32)">
            <summary>
            Causes this FSM to transition to the next state given the current state and input symbol.
            </summary>
            <param name="state">The current state.</param>
            <param name="symbol">The input symbol.</param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.PronounceableFsm.Accept(System.String)">
            <summary>
            Checks to see if this finite state machine accepts the given input string.
            </summary>
            <param name="inputString">The input string to be tested.</param>
            <returns>true if this FSM accepts, false if it rejects</returns>
        </member>
        <member name="T:Syn.Speech.Alignment.Tokenizer.Relation">
            <summary>
            Represents an ordered set of {@link Item}s and their associated children. 
            A relation has a name and a list of items, and is added to an {@link Utterance} via an {@link UsEnglishWordExpander}.
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.Tokenizer.Relation.Token">
            <summary>
            Name of the relation that contains tokens from the original input text. 
            This is the first thing to be added to the utterance.
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.Tokenizer.Relation.Word">
            <summary>
            Name of the relation that contains the normalized version of the original input text.
            </summary>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.Relation.#ctor(System.String,Syn.Speech.Alignment.Tokenizer.Utterance)">
            <summary>
            Creates a relation.
            </summary>
            <param name="name">The name of the Relation.</param>
            <param name="owner">The utterance that contains this relation.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.Relation.AppendItem">
            <summary>
            Adds a new item to this relation. The item added shares its contents with the original item.
            </summary>
            <returns>The newly added item.</returns>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.Relation.AppendItem(Syn.Speech.Alignment.Tokenizer.Item)">
            <summary>
            Adds a new item to this relation. The item added shares its contents with the original item.
            </summary>
            <param name="originalItem">The ItemContents that will be shared by the new item.</param>
            <returns>The newly added item.</returns>
        </member>
        <member name="P:Syn.Speech.Alignment.Tokenizer.Relation.Name">
            <summary>
            Retrieves the name of this Relation.
            </summary>
            <value>The name of this Relation</value>
        </member>
        <member name="P:Syn.Speech.Alignment.Tokenizer.Relation.Head">
            <summary>
            Gets the head of the item list.
            </summary>
            <value>The head item</value>
        </member>
        <member name="P:Syn.Speech.Alignment.Tokenizer.Relation.Tail">
            <summary>
            Gets the tail of the item list.
            </summary>
            <value>The tail item.</value>
        </member>
        <member name="P:Syn.Speech.Alignment.Tokenizer.Relation.Utterance">
            <summary>
            Returns the utterance that contains this relation.
            </summary>
            <value>The utterance that contains this relation.</value>
        </member>
        <member name="T:Syn.Speech.Alignment.Tokenizer.SuffixFsm">
            <summary>
            Implements a finite state machine that checks if a given string is a suffix.
            </summary>
        </member>
        <member name="T:Syn.Speech.Alignment.Token">
            <summary>
            Contains a parsed token from a Tokenizer.
            </summary>
        </member>
        <member name="M:Syn.Speech.Alignment.Token.ToString">
            <summary>
            Converts this token to a string.
            </summary>
            <returns>The string representation of this object.</returns>
        </member>
        <member name="P:Syn.Speech.Alignment.Token.Whitespace">
            <summary>
            Gets or sets the whitespace characters of this Token.
            </summary>
            <value>the whitespace characters of this Token; null if this Token does not use whitespace characters</value>
        </member>
        <member name="P:Syn.Speech.Alignment.Token.PrePunctuation">
            <summary>
            Returns the prepunctuation characters of this Token.
            </summary>
            <value>the postpunctuation characters of this Token; null if this Token does not use postpunctuation characters</value>
        </member>
        <member name="P:Syn.Speech.Alignment.Token.PostPunctuation">
            <summary>
            Returns the postpunctuation characters of this Token.
            </summary>
            <value>he postpunctuation characters of this Token; null if this Token oes not use postpunctuation characters</value>
        </member>
        <member name="P:Syn.Speech.Alignment.Token.Position">
            <summary>
            Returns the position of this token in the original input text.
            </summary>
            <value>The position of this token in the original input text.</value>
        </member>
        <member name="P:Syn.Speech.Alignment.Token.LineNumber">
            <summary>
            Returns the line of this token in the original text.
            </summary>
            <value>The line of this token in the original text.</value>
        </member>
        <member name="P:Syn.Speech.Alignment.Token.Word">
            <summary>
            Returns the string associated with this token.
            </summary>
            <value>The token if it exists; otherwise null</value>
        </member>
        <member name="T:Syn.Speech.Alignment.UsEnglish">
            <summary>
            Provides the definitions for US English whitespace, punctuations,
            prepunctuation, and postpunctuation symbols. It also contains a set of
            Regular Expressions for the US English language. With regular expressions,
            it specifies what are whitespace, letters in the alphabet, uppercase and
            lowercase letters, alphanumeric characters, identifiers, integers, doubles,
            digits, and 'comma and int'.
            It translates the following code from flite: src/regex/cst_regex.c
            lang/usenglish/us_text.c
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultUsEnWhitespace">
            <summary>
            default whitespace regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultUsEnAlphabet">
            <summary>
            default letter regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultUsEnUppercase">
            <summary>
            default uppercase regular expression pattern 
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultUsEnLowercase">
            <summary>
            default lowercase regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultUsEnAlphanumeric">
            <summary>
            default alpha-numeric regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultUsEnIdentifier">
            <summary>
            default identifier regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultUsEnInt">
            <summary>
            default integer regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultUsEnDouble">
            <summary>
            default double regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultUsEnCommaint">
            <summary>
            default integer with commas regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultUsEnDigits">
            <summary>
            default digits regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultUsEnDottedAbbrev">
            <summary>
            default dotted abbreviation regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultUsEnOrdinalNumber">
            <summary>
            default ordinal number regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultHasVowel">
            <summary>
            default has-vowel regular expression
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultUsMoney">
            <summary>
            default US money regular expression
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultIllion">
            <summary>
            default -illion regular expression
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultDigits2Dash">
            <summary>
            default digits2dash (e.g. 999-999-999) regular expression
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultDigitsslashdigits">
            <summary>
            default digits/digits (e.g. 999/999) regular expression
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultNumberTime">
            <summary>
            default number time regular expression
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultRomanNumber">
            <summary>
            default Roman numerals regular expression
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultDrst">
            <summary>
            default drst "Dr. St" regular expression
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultNumess">
            <summary>
            default numess
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultSevenDigitPhoneNumber">
            <summary>
            default 7-digit phone number
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultFourDigit">
            <summary>
            default 4-digit number
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDefaultThreeDigit">
            <summary>
            default 3-digit number
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxHasVowel">
            <summary>
            has-vowel regular expression
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxUsMoney">
            <summary>
            US money regular expression
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxIllion">
            <summary>
            -illion regular expression
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDigits2Dash">
            <summary>
            digits2dash (e.g. 999-999-999) regular expression
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDigitsslashdigits">
            <summary>
            digits/digits (e.g. 999/999) regular expression
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxNumberTime">
            <summary>
            number time regular expression
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxRomanNumber">
            <summary>
            Roman numerals regular expression
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDrst">
            <summary>
            drst "Dr. St" regular expression
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxNumess">
            <summary>
            default numess
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxSevenDigitPhoneNumber">
            <summary>
            7-digit phone number
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxFourDigit">
            <summary>
            4-digit number
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxThreeDigit">
            <summary>
            3-digit number
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.PunctuationSymbols">
            <summary>
            punctuation regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.PrePunctuationSymbols">
            <summary>
            pre-punctuation regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.SingleCharSymbols">
            <summary>
            single char symbols regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.WhitespaceSymbols">
            <summary>
            whitespace symbols regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxWhitespace">
            <summary>
            whitespace regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxAlphabet">
            <summary>
            letter regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxUppercase">
            <summary>
            uppercase regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxLowercase">
            <summary>
            lowercase regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxAlphanumeric">
            <summary>
            alphanumeric regular expression pattern 
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxIdentifier">
             <summary>
            identifier regular expression pattern
             </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxInt">
            <summary>
            integer regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDouble">
            <summary>
            double regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxCommaint">
            <summary>
            comma separated integer regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDigits">
            <summary>
            digits regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxDottedAbbrev">
            <summary>
            dotted abbreviation regular expression pattern
            </summary>
        </member>
        <member name="F:Syn.Speech.Alignment.UsEnglish.RxOrdinalNumber">
            <summary>
            ordinal number regular expression pattern
            </summary>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglish.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:Syn.Speech.Alignment.UsEnglish"/> class from being created.
            </summary>
        </member>
        <member name="T:Syn.Speech.Alignment.UsEnglishTokenizer">
            <summary>
            Converts the Tokens (in US English words) in an Utterance into a list of
            words. It puts the produced list back into the Utterance. Usually, the
            tokens that gets expanded are numbers like "23" (to "twenty" "three").
            <p/>
            /// It translates the following code from flite: <br/>
            <code>
            lang/usenglish/us_text.c
            </code>
            </summary>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.#ctor">
            <summary>
            Constructs a default USTokenWordProcessor. It uses the USEnglish regular
            expression set (USEngRegExp) by default.
            </summary>
            <exception cref="T:Syn.Speech.Helper.IllegalStateException">The cart to use to classify numbers.</exception>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.GetTokenItem">
            <summary>
            Returns the currently processing token Item.
            </summary>
            <returns>The current token Item; null if no item</returns>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.Expand(System.String)">
            <summary>
            process the utterance
            </summary>
            <param name="text">The text.</param>
            <exception cref="T:Syn.Speech.Helper.IllegalStateException"></exception>
            <returns>The utterance contain the tokens</returns>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.MatchesPartPhoneNumber(System.String)">
            <summary>
            Returns true if the given token matches part of a phone number
            </summary>
            <param name="tokenVal">The token.</param>
            <returns>true or false</returns>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.TokenToWords(System.String)">
            <summary>
            Converts the given Token into (word) Items in the WordRelation.
            </summary>
            <param name="tokenVal">the string value of the token, which may or may not be
            same as the one in called "name" in flite</param>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.DigitsDashToWords(System.String)">
            <summary>
             Convert the given digit token with dashes (e.g. 999-999-999) into (word)
            Items in the WordRelation.
            </summary>
            <param name="tokenVal">The digit string.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.DigitsToWords(System.String)">
            <summary>
            Convert the given digit token into (word) Items in the WordRelation.
            </summary>
            <param name="tokenVal">The digit string.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.RomanToWords(System.String)">
            <summary>
            Converts the given Roman numeral string into (word) Items in the WordRelation.
            </summary>
            <param name="romanString">The roman numeral string.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.InKingSectionLikeMap(System.String,System.String)">
            <summary>
            Returns true if the given key is in the {@link #kingSectionLikeMap} map,
            and the value is the same as the given value.
            </summary>
            <param name="key">key to look for in the map.</param>
            <param name="value">the value to match.</param>
            <returns>true if it matches, or false if it does not or if the key is not
            mapped to any value in the map.</returns>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.KingLike(Syn.Speech.Alignment.Tokenizer.Item)">
            <summary>
            Returns true if the given token item contains a token that is in a
            king-like context, e.g., "King" or "Louis".
            </summary>
            <param name="tokenItem">the token item to check.</param>
            <returns>true or false</returns>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.SectionLike(Syn.Speech.Alignment.Tokenizer.Item)">
            <summary>
            Returns true if the given token item contains a token that is in a
            section-like context, e.g., "chapter" or "act".
            </summary>
            <param name="tokenItem">the token item to check.</param>
            <returns>true or false</returns>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.DrStToWords(System.String)">
            <summary>
            Converts the given string containing "St" and "Dr" to (word) Items in the WordRelation.
            </summary>
            <param name="drStString">The string with "St" and "Dr".</param>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.UsMoneyToWords(System.String)">
            <summary>
            Converts US money string into (word) Items in the WordRelation.
            </summary>
            <param name="tokenVal">The US money string.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.DigitsSlashDigitsToWords(System.String)">
            <summary>
            Convert the given digits/digits string into word (Items) in the WordRelation.
            </summary>
            <param name="tokenVal">The digits/digits string.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.DashToWords(System.String)">
            <summary>
            Convert the given dashed string (e.g. "aaa-bbb") into (word) Items in the WordRelation.
            </summary>
            <param name="tokenVal">The dashed string.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.NotJustAlphasToWords(System.String)">
            <summary>
            Convert the given string (which does not only consist of alphabet) into (word) Items in the WordRelation.
            </summary>
            <param name="tokenVal">The string.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.IsPronounceable(System.String)">
            <summary>
            Returns true if the given word is pronounceable. This method is 
            originally called us_aswd() in Flite 1.1.
            </summary>
            <param name="word">The word to test.</param>
            <returns>true if the word is pronounceable, false otherwise</returns>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.IsStateName(System.String)">
            <summary>
            Returns true if the given token is the name of a US state. If it is, it
            will add the name of the state to (word) Items in the WordRelation.
            </summary>
            <param name="tokenVal">The token string.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.Matches(Syn.Speech.Helper.Pattern,System.String)">
            <summary>
            Determines if the given input matches the given Pattern.
            </summary>
            <param name="pattern">The pattern to match.</param>
            <param name="input">the string to test.</param>
            <returns><code>true</code> if the input string matches the given Pattern;
            <code>false</code> otherwise</returns>
        </member>
        <member name="M:Syn.Speech.Alignment.UsEnglishTokenizer.IsTextSplitable(System.String,System.Int32)">
            <summary>
            Determines if the character at the given position of the given input
            text is splittable. A character is splittable if:
            1) the character and the following character are not letters in the
            English alphabet (A-Z and a-z)
             2) the character and the following character are not digits (0-9)
            </summary>
            <param name="text">The text containing the character of interest.</param>
            <param name="index">The index of the character of interest.</param>
            <returns>true if the position of the given text is splittable false otherwise</returns>
        </member>
        <member name="T:Syn.Speech.Alignment.Tokenizer.Utterance">
            <summary>
            Holds all the data for an utterance to be spoken. It is incrementally
            modified by various UtteranceProcessor implementations. An utterance
            contains a set of Features (essential a set of properties) and a set of
            Relations. A Relation is an ordered set of Item graphs. The utterance
            contains a set of features and implements FeatureSet so that applications
            can set/get features directly from the utterance. If a feature query is not
            found in the utterance feature set, the query is forwarded to the FeatureSet
            of the voice associated with the utterance.
            </summary>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.Utterance.#ctor(Syn.Speech.Alignment.Tokenizer.CharTokenizer)">
            <summary>
            Creates an utterance with the given set of tokenized text.
            </summary>
            <param name="tokenizer">The list of tokens for this utterance.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.Utterance.CreateRelation(System.String)">
            <summary>
            Creates a new relation with the given name and adds it to this utterance.
            </summary>
            <param name="name">The name of the new relation.</param>
            <returns>the newly created relation</returns>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.Utterance.GetRelation(System.String)">
            <summary>
            Retrieves a relation from this utterance.
            </summary>
            <param name="name">The name of the Relation.</param>
            <returns>The relation or null if the relation is not found</returns>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.Utterance.HasRelation(System.String)">
             <summary>
            Determines if this utterance contains a relation with the given name.
             </summary>
             <param name="name">The name of the relation of interest.</param>
             <returns></returns>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.Utterance.Remove(System.String)">
            <summary>
            Removes the named feature from this set of features.
            </summary>
            <param name="name">The name of the feature of interest.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.Utterance.SetInt(System.String,System.Int32)">
            <summary>
            Convenience method that sets the named feature as an int.
            </summary>
            <param name="name">The name of the feature.</param>
            <param name="value">The value of the feature.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.Utterance.SetFloat(System.String,System.Single)">
            <summary>
            Convenience method that sets the named feature as a float.
            </summary>
            <param name="name">The name of the feature.</param>
            <param name="value">The value of the feature.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.Utterance.SetString(System.String,System.String)">
            <summary>
            Convenience method that sets the named feature as a String.
            </summary>
            <param name="name">The name of the feature.</param>
            <param name="value">The value of the feature.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.Utterance.SetObject(System.String,System.Object)">
            <summary>
            Sets the named feature.
            </summary>
            <param name="name">The name of the feature.</param>
            <param name="value">The value of the feature.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.Utterance.GetItem(System.String,System.Single)">
            <summary>
            Returns the Item in the given Relation associated with the given time.
            </summary>
            <param name="relation">The name of the relation.</param>
            <param name="time">The time.</param>
            <returns></returns>
            <exception>if the Segment durations have not been
            calculated in the Utterance or if the given relation is not
            present in the Utterance</exception>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.Utterance.SetTokenList(System.Collections.Generic.IEnumerator{Syn.Speech.Alignment.Token})">
            <summary>
            Sets the token list for this utterance. Note that this could be
            optimized by turning the token list directly into the token relation.
            </summary>
            <param name="tokenizer">The tokenList.</param>
        </member>
        <member name="T:Syn.Speech.Alignment.Tokenizer.WordRelation">
            <summary>
            Helper class to add words and breaks into a Relation object.
            </summary>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.WordRelation.CreateWordRelation(Syn.Speech.Alignment.Tokenizer.Utterance,Syn.Speech.Alignment.UsEnglishTokenizer)">
            <summary>
            Creates a WordRelation object with the given utterance and TokenToWords.
            </summary>
            <param name="utterance">the Utterance from which to create a Relation.</param>
            <param name="tokenToWords">The TokenToWords object to use.</param>
            <returns>a WordRelation object</returns>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.WordRelation.AddBreak">
            <summary>
            Adds a break as a feature to the last item in the list.
            </summary>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.WordRelation.AddWord(System.String)">
             <summary>
            Adds a word as an Item to this WordRelation object.
             </summary>
             <param name="word">The word to add.</param>
        </member>
        <member name="M:Syn.Speech.Alignment.Tokenizer.WordRelation.SetLastWord(System.String)">
            <summary>
             Sets the last Item in this WordRelation to the given word.
            </summary>
            <param name="word">The word to set.</param>
        </member>
        <member name="P:Syn.Speech.Alignment.Tokenizer.WordRelation.Tail">
            <summary>
            Returns the last item in this WordRelation.
            </summary>
            <value>The last item</value>
        </member>
        <member name="T:Syn.Speech.Api.AbstractSpeechRecognizer">
            <summary>
            Base class for high-level speech recognizers.
            </summary>
        </member>
        <member name="M:Syn.Speech.Api.AbstractSpeechRecognizer.#ctor(Syn.Speech.Api.Configuration)">
            <summary>
            Constructs recognizer object using provided configuration.
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:Syn.Speech.Api.AbstractSpeechRecognizer.GetResult">
            <summary>
            Returns result of the recognition.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Syn.Speech.Decoders.Search.ActiveList">
            <summary>
            An active list is maintained as a sorted list
            <p/>
            Note that all scores are represented in LogMath logbase
            </summary>
            
        </member>
        <member name="F:Syn.Speech.Decoders.Search.ActiveList.PropAbsoluteBeamWidth">
            <summary>
            property that sets the desired (or target) size for this active list.  This is sometimes referred to as the beam size
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.ActiveList.PropRelativeBeamWidth">
            <summary>
             Property that sets the minimum score relative to the maximum score in the list for pruning.  Tokens with a score
            less than relativeBeamWidth/// maximumScore will be pruned from the list
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.ActiveList.PropStrictPruning">
            <summary>
            Property that indicates whether or not the active list will implement 'strict pruning'.  When strict pruning is
            enabled, the active list will not remove tokens from the active list until they have been completely scored.  If
            strict pruning is not enabled, tokens can be removed from the active list based upon their entry scores. The
            default setting is false (disabled).
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ActiveList.Add(Syn.Speech.Decoders.Search.Token)">
            <summary>
            Adds the given token to the list, keeping track of the lowest scoring token
            </summary>
            <param name="token">token the token to add</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ActiveList.Purge">
            <summary>
            Replaces an old token with a new token
            </summary>
            <summary>
            Purges the active list of excess members returning a (potentially new) active list
            </summary>
            <returns>a purged active list</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ActiveList.GetTokens">
            <summary>
            Gets the list of all tokens 
            </summary>
            <returns>set of tokens</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ActiveList.GetBeamThreshold">
            <summary>
            gets the beam threshold best upon the best scoring token
            </summary>
            <returns>the beam threshold</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ActiveList.GetBestScore">
            <summary>
            gets the best score in the list
            </summary>
            <returns>the best score</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ActiveList.SetBestToken(Syn.Speech.Decoders.Search.Token)">
            <summary>
            Sets the best scoring token for this active list
            </summary>
            <param name="token">token the best scoring token</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ActiveList.GetBestToken">
            <summary>
            Gets the best scoring token for this active list
            </summary>
            <returns>the best scoring token</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ActiveList.NewInstance">
            <summary>
            Creates a new empty version of this active list with the same general properties.
            </summary>
            <returns>a new active list.</returns>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.ActiveList.Size">
            <summary>
            Returns the size of this list
            </summary>
            <value>the size</value>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.PartitionActiveList.Add(Syn.Speech.Decoders.Search.Token)">
            <summary>
            Adds the given token to the list.
            </summary>
            <param name="token">The token to add</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.PartitionActiveList.DoubleCapacity">
            <summary>
            Doubles the capacity of the Token array.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.PartitionActiveList.Purge">
            <summary>
            Purges excess members. Remove all nodes that fall below the relativeBeamWidth
            </summary>
            <returns>
            a (possible new) active list
            </returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.PartitionActiveList.GetBeamThreshold">
            <summary>
            gets the beam threshold best upon the best scoring token
            </summary>
            <returns>
            the beam threshold
            </returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.PartitionActiveList.GetBestScore">
            <summary>
            gets the best score in the list
            </summary>
            <returns>
            the best score
            </returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.PartitionActiveList.SetBestToken(Syn.Speech.Decoders.Search.Token)">
            <summary>
            Sets the best scoring token for this active list.
            </summary>
            <param name="token">The best scoring token</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.PartitionActiveList.GetBestToken">
            <summary>
             Gets the best scoring token for this active list.
            </summary>
            <returns>
            the best scoring token
            </returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.PartitionActiveList.Iterator">
            <summary>
            Retrieves the iterator for this tree.
            </summary>
            <returns>The iterator for this token list.</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.PartitionActiveList.GetTokens">
            <summary>
            Gets the list of all tokens
            </summary>
            <returns>
            List of tokens
            </returns>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.PartitionActiveList.Size">
            <summary>
            Returns the number of tokens on this active list.
            </summary>
            <value>
            the size
            </value>
        </member>
        <member name="T:Syn.Speech.Decoders.Search.WordPruningBreadthFirstLookaheadSearchManager">
            <summary>
            Provides the breadth first search with fast match heuristic included to reduce amount of tokens created. 
            All scores and probabilities are maintained in the log math log domain.
            </summary>
        </member>
        <member name="T:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager">
            <summary>
            Provides the breadth first search. To perform recognition an application should call initialize before recognition
            begins, and repeatedly call <code> recognize </code> until Result.isFinal() returns true. Once a final result has
            been obtained, <code> stopRecognition </code> should be called.
            All scores and probabilities are maintained in the log math log domain.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Props.IConfigurable.NewProperties(Syn.Speech.Util.Props.PropertySheet)">
            <summary>
            This method is called when this configurable component needs to be reconfigured.
            </summary>
            <param name="ps"> a property sheet holding the new data</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ISearchManager.Allocate">
            <summary>
            Allocates the resources necessary for this search. This should be called once before an recognitions are
            performed
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ISearchManager.Deallocate">
            <summary>
            Deallocates resources necessary for this search. This should be called once after all recognitions are completed
            at the search manager is no longer needed.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ISearchManager.StartRecognition">
            <summary>
            Prepares the SearchManager for recognition.  This method must be called before recognize 
            is called. Typically, start and stop  are called bracketing an utterance.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ISearchManager.StopRecognition">
            <summary>
            Performs post-recognition cleanup. This method should be called after recognize returns a final result.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ISearchManager.Recognize(System.Int32)">
            <summary>
            Performs recognition. Processes no more than the given number of frames before returning. This method returns a
            partial result after nFrames have been processed, or a final result if recognition completes while processing
            frames.  If a final result is returned, the actual number of frames processed can be retrieved from the result.
            This method may block while waiting for frames to arrive.
            </summary>
            <param name="nFrames">the maximum number of frames to process. A final result may be returned before all nFrames are processed.</param>
            <returns>the recognition result, the result may be a partial or a final result; or return null if no frames are
            arrived</returns>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.TokenSearchManager.PropBuildWordLattice">
            <summary>
            The property that specifies whether to build a word lattice. 
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.TokenSearchManager.PropKeepAllTokens">
            <summary>
            The property that controls whether or not we keep all tokens. If this is
            set to false, only word tokens are retained, otherwise all tokens are
            retained.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.TokenSearchManager.GetResultListPredecessor(Syn.Speech.Decoders.Search.Token)">
            <summary>
            Find the token to use as a predecessor in resultList given a candidate predecessor.
             </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.PropLinguist">
            <summary>
            The property that defines the name of the linguist to be used by this search manager.
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.PropPruner">
            <summary>
            The property that defines the name of the linguist to be used by this search manager.
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.PropScorer">
            <summary>
            The property that defines the name of the scorer to be used by this search manager.
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.PropShowTokenCount">
            <summary>
            The property than, when set to <code>true</code> will cause the recognizer to count up all the tokens in the active list after every frame.
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.PropGrowSkipInterval">
            <summary>
            The property that controls the number of frames processed for every time
            the decode growth step is skipped. Setting this property to zero disables
            grow skipping. Setting this number to a small integer will increase the
            speed of the decoder but will also decrease its accuracy. The higher the
            number, the less often the grow code is skipped. Values like 6-8 is known
            to be the good enough for large vocabulary tasks. That means that one of
            6 frames will be skipped.
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.PropActiveListManager">
            <summary>
            The property that defines the type of active list to use.
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.PropCheckStateOrder">
            <summary>
            The property for checking if the order of states is valid.
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.PropMaxLatticeEdges">
            <summary>
            The property that specifies the maximum lattice edges.
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.PropAcousticLookaheadFrames">
            <summary>
            The property that controls the amount of simple acoustic lookahead performed. Setting the property to zero (the default) disables simple acoustic lookahead. The lookahead need not be an integer.
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.PropRelativeBeamWidth">
            <summary>
            The property that specifies the relative beam width.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.StartRecognition">
            <summary>
            Called at the start of recognition. Gets the search manager ready to recognize
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.Recognize(System.Int32)">
            <summary>
            Performs the recognition for the given number of frames.
            </summary>
            <param name="nFrames">The number of frames to recognize.</param>
            <returns>The current result.</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.ClearCollectors">
            <summary>
            Clears lists and maps before next expansion stage.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.CreateBestTokenMap">
            <summary>
            Creates a new best token map with the best size.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.StopRecognition">
            <summary>
            Terminates a recognition.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.LocalStart">
            <summary>
            Gets the initial grammar node from the linguist and creates a GrammarNodeToken.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.LocalStop">
            <summary>
            Local cleanup for this search manager.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.GrowBranches">
            <summary>
            Goes through the active list of tokens and expands each token, 
            finding the set of successor tokens until all the successor tokens are emitting tokens.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.GrowEmittingBranches">
            <summary>
            Grows the emitting branches. This version applies a simple acoustic lookahead based upon the rate of change in the current acoustic score.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.GrowNonEmittingBranches">
            <summary>
            Grow the non-emitting branches, until the tokens reach an emitting state.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.ScoreTokens">
            <summary>
            Calculate the acoustic scores for the active list. The active list should contain only emitting tokens.
            </summary>
            <returns><code>true</code> if there are more frames to score, otherwise, false</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.MonitorWords(Syn.Speech.Decoders.Search.ActiveList)">
            <summary>
            Keeps track of and reports all of the active word histories for the given active list.
            </summary>
            <param name="activeList">The active list to track.</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.MonitorStates(Syn.Speech.Decoders.Search.ActiveList)">
            <summary>
            Keeps track of and reports statistics about the number of active states.
            </summary>
            <param name="activeList">The active list of states.</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.PruneBranches">
            <summary>
            Removes unpromising branches from the active list.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.GetBestToken(Syn.Speech.Linguist.ISearchState)">
            <summary>
            Gets the best token for this state.
            </summary>
            <param name="state">The state of interest.</param>
            <returns>The best token.</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.SetBestToken(Syn.Speech.Decoders.Search.Token,Syn.Speech.Linguist.ISearchState)">
                    /// Sets the best token for a given state
                     *
                    /// @param token the best token
                    /// @param state the state
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.CheckStateOrder(Syn.Speech.Linguist.ISearchState,Syn.Speech.Linguist.ISearchState)">
            Checks that the given two states are in legitimate order.
                    /// @param fromState
                    /// @param toState
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.CollectSuccessorTokens(Syn.Speech.Decoders.Search.Token)">
                    /// Collects the next set of emitting tokens from a token and accumulates them in the active or result lists
                     *
                    /// @param token the token to collect successors from be immediately expanded are placed. Null if we should always
                    ///              expand all nodes.
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.IsVisited(Syn.Speech.Decoders.Search.Token)">
                    /// Determines whether or not we've visited the state associated with this token since the previous frame.
                     *
                    /// @param t
                    /// @return true if we've visited the search state since the last frame
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.AllowExpansion(Syn.Speech.Decoders.Search.Token)">
            <summary>
            Determine if the given token should be expanded.
            </summary>
            <param name="t">The token to test.</param>
            <returns><code>true</code> if the token should be expanded</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.ShowTokenCount">
            <summary>
            Counts all the tokens in the active list (and displays them). This is an expensive operation.
            </summary>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.ActiveList">
            <summary>
            Gets or sets the active list.
            </summary>
            <value>
            The active list.
            </value>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.ResultList">
            <summary>
            Gets or sets the result list.
            </summary>
            <value>
            The result list.
            </value>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.CurrentFrameNumber">
            <summary>
            Gets or sets the current frame number.
            </summary>
            <value>
            The current frame number.
            </value>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.GrowTimer">
            <summary>
            Gets or sets the grow timer.
            </summary>
            <value>
            The grow timer.
            </value>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.WordPruningBreadthFirstSearchManager.TokensCreated">
            <summary>
            Returns the tokensCreated StatisticsVariable.
            </summary>
            <value>
            The tokens created.
            </value>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.WordPruningBreadthFirstLookaheadSearchManager.PropLoader">
            <summary>
            The property that to get direct access to gau for score caching control. 
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.WordPruningBreadthFirstLookaheadSearchManager.PropFastmatchLinguist">
            <summary>
            The property that defines the name of the linguist to be used for fast match.
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.WordPruningBreadthFirstLookaheadSearchManager.PropFmActiveListFactory">
            <summary>
            The property that defines the type active list factory for fast match
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.WordPruningBreadthFirstLookaheadSearchManager.PropLookaheadWindow">
            <summary>
            The property that controls size of lookahead window. Acceptable values are in range [1..10].
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstLookaheadSearchManager.Recognize(System.Int32)">
            <summary>
            Performs the recognition for the given number of frames.
            </summary>
            <param name="nFrames">The number of frames to recognize.</param>
            <returns>
            The current result.
            </returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstLookaheadSearchManager.CreateFastMatchBestTokenMap">
            <summary>
            creates a new best token map with the best size
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstLookaheadSearchManager.LocalStart">
            <summary>
            Gets the initial grammar node from the linguist and creates a GrammarNodeToken
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstLookaheadSearchManager.GrowFastmatchBranches">
            <summary>
            Goes through the fast match active list of tokens and expands each token, 
            finding the set of successor tokens until all the successor tokens are emitting tokens.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstLookaheadSearchManager.PruneFastMatchBranches">
            <summary>
            Removes unpromising branches from the fast match active list.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.WordPruningBreadthFirstLookaheadSearchManager.CollectSuccessorTokens(Syn.Speech.Decoders.Search.Token)">
            <summary>
            Collects the next set of emitting tokens from a token and accumulates them in the active or result lists
            </summary>
            <param name="token">The token to collect successors from be immediately expanded are placed. Null if we should always expand all nodes.</param>
        </member>
        <member name="T:Syn.Speech.FrontEnds.DataBranch.DataBufferProcessor">
            A FIFO-buffer for <code>Data</code>-elements.
            <p/>
            <code>Data</code>s are inserted to the buffer using the <code>processDataFrame</code>-method.
        </member>
        <member name="T:Syn.Speech.FrontEnds.BaseDataProcessor">
            <summary>
            An abstract DataProcessor implementing elements common to all concrete DataProcessors, such as name, predecessor, and
            timer.
            </summary>
        </member>
        <member name="T:Syn.Speech.Util.Props.ConfigurableAdapter">
            <summary>
            An default (abstract) implementation of a configurable that implements a meaning {@code toString()} and keeps a
            references to the {@code Confurable}'s logger.
            @author Holger Brandl
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurableAdapter.ToString">
                    /// Returns the name of this BaseDataProcessor.
                     *
                    /// @return the name of this BaseDataProcessor
        </member>
        <member name="P:Syn.Speech.Util.Props.ConfigurableAdapter.Name">
            Returns the configuration name this {@code Configurable}. 
        </member>
        <member name="T:Syn.Speech.FrontEnds.IDataProcessor">
             <summary>
             /**
             A processor that performs a signal processing function.
            
             Since a DataProcessor usually belongs to a particular front end pipeline,
             you can name the pipeline it belongs to in the {@link #initialize()
             initialize} method. (Note, however, that it is not always the case that a
             DataProcessor belongs to a particular pipeline. For example, the {@link
             sphincs.frontend.util.Microphone Microphone}class is a DataProcessor,
             but it usually does not belong to any particular pipeline.  <p/> Each
             DataProcessor usually have a predecessor as well. This is the previous
             DataProcessor in the pipeline. Again, not all DataProcessors have
             predecessors.  <p/> Calling {@link #getData() getData}will return the
             processed Data object.
            
             </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.IDataProcessor.Initialize">
            <summary>
            Initializes this DataProcessor.
            This is typically called after the DataProcessor has been configured.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.IDataProcessor.GetData">
            <summary>
            Returns the processed Data output.
            </summary>
            <returns>a Data object that has been processed by this DataProcessor</returns>
        </member>
        <member name="P:Syn.Speech.FrontEnds.IDataProcessor.Predecessor">
            <summary>
            Returns the predecessor DataProcessor.
            </summary>
            <value>the predecessor</value>
        </member>
        <member name="M:Syn.Speech.FrontEnds.BaseDataProcessor.GetData">
            <summary>
            Returns the processed Data output.
            </summary>
            <returns>an Data object that has been processed by this DataProcessor</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.BaseDataProcessor.Initialize">
            <summary>
            Initializes this DataProcessor. This is typically called after the DataProcessor has been configured. 
            </summary>
        </member>
        <member name="P:Syn.Speech.FrontEnds.BaseDataProcessor.Predecessor">
            <summary>
            Sets the predecessor DataProcessor. This method allows dynamic reconfiguration of the front end.
            </summary>
            <value>
            The new predecessor of this DataProcessor
            </value>
        </member>
        <member name="T:Syn.Speech.FrontEnds.DataBranch.IDataListener">
            Defines some API-elements for Data-observer classes. 
        </member>
        <member name="M:Syn.Speech.FrontEnds.DataBranch.IDataListener.ProcessDataFrame(Syn.Speech.FrontEnds.IData)">
            This method is invoked when a new {@link Data} object becomes available.
            @param data
        </member>
        <member name="F:Syn.Speech.FrontEnds.DataBranch.DataBufferProcessor.PropWaitIfEmpty">
            If this property is set <code>true</code> the buffer will wait for new data until it returns from a
            <code>getData</code>-call. Enable this flag if the buffer should serve as starting point for a new
            feature-pull-chain..
        </member>
        <member name="F:Syn.Speech.FrontEnds.DataBranch.DataBufferProcessor.PropWaitTimeMs">
            The time in milliseconds which will be waited between two attempts to read a data element from the buffer when
            being in <code>waitIfEmpty</code>-mode
        </member>
        <member name="F:Syn.Speech.FrontEnds.DataBranch.DataBufferProcessor.PropBufferSize">
            The maximal size of the buffer in frames. The oldest frames will be removed if the buffer grows out of bounds. 
        </member>
        <member name="F:Syn.Speech.FrontEnds.DataBranch.DataBufferProcessor._featureBuffer">
            The FIFO- data buffer. 
        </member>
        <member name="M:Syn.Speech.FrontEnds.DataBranch.DataBufferProcessor.#ctor(System.Int32,System.Boolean,System.Int32,System.Collections.Generic.IEnumerable{Syn.Speech.Util.Props.IConfigurable})">
            @param maxBufferSize The maximal size of the buffer in frames. The oldest frames will be removed if the buffer grows out of bounds.
            @param waitIfEmpty If this property is set <code>true</code> the buffer will wait for new data until it returns from a
            <code>getData</code>-call. Enable this flag if the buffer should serve as starting point for a new
            feature-pull-chain.
            @param waitTime The time in milliseconds which will be waited between two attempts to read a data element from the buffer when
            being in <code>waitIfEmpty</code>-mode
            @param listeners
        </member>
        <member name="M:Syn.Speech.FrontEnds.DataBranch.DataBufferProcessor.GetData">
             Returns the processed Data output.
            
             @return an Data object that has been processed by this DataProcessor
             @throws edu.cmu.sphinx.frontend.DataProcessingException
                      if a data processor error occurs
        </member>
        <member name="M:Syn.Speech.FrontEnds.DataBranch.DataBufferProcessor.AddDataListener(Syn.Speech.FrontEnds.DataBranch.IDataListener)">
            Adds a new listener.
            @param l
        </member>
        <member name="M:Syn.Speech.FrontEnds.DataBranch.DataBufferProcessor.RemoveDataListener(Syn.Speech.FrontEnds.DataBranch.IDataListener)">
            Removes a listener.
            @param l
        </member>
        <member name="T:Syn.Speech.FrontEnds.RandomDataProcessor">
            <summary>
            A DataProcessor implemenation which can be used to setup simple unit-tests for other DataProcessors.
            Addtionally some static utility methods which should ease unit-testing of DataProcessors are provided by this class.
            @author Holger Brandl
            </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Util.ConcatAudioFileDataSource">
            <summary>
            Concatenates a list of audio files as one continuous audio stream.
            @author Holger Brandl
            </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Util.AudioFileDataSource">
             An AudioFileDataSource generates a stream of audio data from a given audio file. All required information concerning
             the audio format are read directly from the file . One would need to call {@link #setAudioFile(java.io.File,String)}
             to set the input file, and call {@link #getData} to obtain the Data frames.
             <p/>
             Using JavaSound as backend this class is able to handle all sound files supported by JavaSound. Beside the built-in
             support for .wav, .au and .aiff. Using plugins (cf.  http://www.jsresources.org/ ) it can be extended to support
             .ogg, .mp3, .speex and others.
            
             @author Holger Brandl
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.AudioFileDataSource.PropBytesPerRead">
            <summary>
            The property for the number of bytes to read from the InputStream each time.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.AudioFileDataSource.SetAudioFile(System.String,System.String)">
             Sets the audio file from which the data-stream will be generated of.
            
             @param audioFile  The location of the audio file to use
             @param streamName The name of the InputStream. if <code>null</code> the complete path of the audio file will be
                               uses as stream name.
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.AudioFileDataSource.SetAudioFile(Syn.Speech.Helper.URL,System.String)">
             Sets the audio file from which the data-stream will be generated of.
            
             @param audioFileURL The location of the audio file to use
             @param streamName   The name of the InputStream. if <code>null</code> the complete path of the audio file will be
                                 uses as stream name.
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.AudioFileDataSource.SetInputStream(Syn.Speech.Wave.WaveFile,System.String)">
             Sets the InputStream from which this StreamDataSource reads.
            
             @param inputStream the InputStream from which audio data comes
             @param streamName  the name of the InputStream
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.AudioFileDataSource.GetData">
             Reads and returns the next Data from the InputStream of StreamDataSource, return null if no data is read and end
             of file is reached.
            
             @return the next Data or <code>null</code> if none is available
             @throws edu.cmu.sphinx.frontend.DataProcessingException
                      if there is a data processing error
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.AudioFileDataSource.ReadNextFrame">
             Returns the next Data from the input stream, or null if there is none available
            
             @return a Data or null
             @throws edu.cmu.sphinx.frontend.DataProcessingException
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.AudioFileDataSource.AddNewFileListener(Syn.Speech.FrontEnds.Util.IAudioFileProcessListener)">
            <summary>
            Adds a new listener for new file events.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.AudioFileDataSource.RemoveNewFileListener(Syn.Speech.FrontEnds.Util.IAudioFileProcessListener)">
            <summary>
            Removes a listener for new file events.
            </summary>
        </member>
        <member name="P:Syn.Speech.FrontEnds.Util.AudioFileDataSource.Duration">
            <summary>
            Returns the duration of the current data stream in milliseconds.
            </summary>
            <value>
            The duration of the current data stream in milliseconds.
            </value>
        </member>
        <member name="T:Syn.Speech.Util.IReferenceSource">
            <summary>
             A source of reference texts.
            </summary>
        </member>
        <member name="P:Syn.Speech.Util.IReferenceSource.References">
            <summary>
            Returns a list of reference text.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.ConcatAudioFileDataSource.Initialize">
            <summary>
            Initializes a ConcatFileDataSource.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.ConcatAudioFileDataSource.ReadDriver(System.String)">
            <summary>
            Reads and verifies a driver file.
            </summary>
            <param name="fileName">Name of the file.</param>
            <returns></returns>
        </member>
        <member name="P:Syn.Speech.FrontEnds.Util.ConcatAudioFileDataSource.References">
             <summary>
             Gets a list of all reference text. Implements the getReferences() method of ReferenceSource.
             </summary>
            
        </member>
        <member name="T:Syn.Speech.FrontEnds.Util.ConcatAudioFileDataSource.InputStreamEnumeration">
            <summary>
            The work of the concatenating of the audio files are done here. The idea
            here is to turn the list of audio files into an Enumeration, and then
            fed it to a SequenceInputStream, giving the illusion that the audio
            files are concatenated, but only logically.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.ConcatAudioFileDataSource.InputStreamEnumeration.HasMoreElements">
            <summary>
            Tests if this enumeration contains more elements.
            </summary>
            <returns>True if and only if this enumeration object contains at least one more element to provide; false otherwise.</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.ConcatAudioFileDataSource.InputStreamEnumeration.NextElement">
            <summary>
            Returns the next element of this enumeration if this enumeration object has at least one more element to provide.
            </summary>
            <returns>The next element of this enumeration.</returns>
            <exception cref="T:Syn.Speech.Helper.RuntimeException">format mismatch for subsequent files</exception>
            <exception cref="T:System.Exception">Cannot convert  + _parent._nextFile
                                            +  to a FileInputStream</exception>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.ConcatAudioFileDataSource.InputStreamEnumeration.ReadNext">
            <summary>
             Returns the name of next audio file
            </summary>
            <returns>The name of the appropriate audio file.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.FrontEnds.Util.ConcatFileDataSource" -->
        <member name="T:Syn.Speech.FrontEnds.Util.StreamDataSource">
             <summary>
             A StreamDataSource converts data from an InputStream into Data objects. One
             would call {@link #setInputStream(InputStream,String) setInputStream} to set
             the input stream, and call {@link #getData} to obtain the Data object. The
             InputStream can be an arbitrary stream, for example a data from the network
             or from a pipe.
            
             StreamDataSource is not aware about incoming data format and assumes
             that incoming data matches StreamDataSource configuration. By default it's configured
             to read 16 kHz little-endian 16-bit signed raw data. If data has wrong format
             the result of the recognition is undefined. Also note that the sample rate of the
             data must match the sample required by the the acoustic model. If your
             model decodes 16 kHz files you can't recognize 8kHz data using it.
            
             You can use AudioFileDataSource instead to read the file headers and
             to convert incoming data to the required format automatically.
             </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.StreamDataSource.PropSampleRate">
            <summary>
            The property for the sample rate. 
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.StreamDataSource.PropBytesPerRead">
            <summary>
            The property for the number of bytes to read from the InputStream each
            time.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.StreamDataSource.PropBitsPerSample">
            <summary>
            The property for the number of bits per value. 
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.StreamDataSource.PropBigEndianData">
            <summary>
            The property specifying whether the input data is big-endian. 
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.StreamDataSource.PropSignedData">
            <summary>
            The property specifying whether the input data is signed. 
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.StreamDataSource.NewProperties(Syn.Speech.Util.Props.PropertySheet)">
            <summary>
            @see Sphincs.util.props.Configurable#newProperties(Sphincs.util.props.PropertySheet)
            </summary>
            <param name="ps"></param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.StreamDataSource.Initialize">
            <summary>
            Sphincs.FrontEnd.DataProcessor#initialize(sphincs.FrontEnd.CommonConfig)
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.StreamDataSource.SetInputStream(System.IO.Stream,Syn.Speech.Util.TimeFrame)">
            <summary>
            Sets the InputStream from which this StreamDataSource reads.
            </summary>
            <param name="inputStream">The InputStream from which audio data comes.</param>
            <param name="timeFrame">The time frame.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.StreamDataSource.GetData">
            <summary>
            Reads and returns the next Data from the InputStream of
            StreamDataSource, return null if no data is read and end of file is
            reached.
            </summary>
            <returns>the next Data or <code>null</code> if none is available</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.StreamDataSource.ReadNextFrame">
            <summary>
            Returns the next Data from the input stream, or null if there is none
            available
            </summary>
            <returns>a Data or null</returns>
        </member>
        <member name="P:Syn.Speech.FrontEnds.Util.StreamDataSource.Duration">
            <summary>
            Returns the duration of the current data stream in milliseconds.
            </summary>
            <value>the duration of the current data stream in milliseconds</value>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.ConcatFileDataSource.PropStartFile">
            <summary>
            TThe property that specifies which file to start at.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.ConcatFileDataSource.PropSkip">
            <summary>
            The property that specifies the number of files to skip for every file read.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.ConcatFileDataSource.PropTotalFiles">
            <summary>
            The property that specifies the total number of files to read. The default value should be no limit.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.ConcatFileDataSource.PropSilenceFile">
            <summary>
            The property that specifies the silence audio file, if any. If this property is null, then no silences are added in between files.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.ConcatFileDataSource.PropAddRandomSilence">
            <summary>
            The property that specifies whether to add random silence.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.ConcatFileDataSource.PropMaxSilence">
            <summary>
            The property that specifies the maximum number of times the silence file is added  between files. If
            PROP_ADD_RANDOM_SILENCE is set to true, the number of times the silence file is added is between 1 and this
            value. If PROP_ADD_RANDOM_SILENCE is set to false, this value will be the number of times the silence file is
            added. So if PROP_MAX_SILENCE is set to 3, then the silence file will be added three times between files.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.ConcatFileDataSource.PropTranscriptFile">
            <summary>
            The property that specifies the name of the transcript file. 
            If this property is set, a transcript file will be created. No transcript file will be created if this property is not set.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.ConcatFileDataSource.PropBatchFile">
            <summary>
            The property for the file containing a list of audio files to read from.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.ConcatFileDataSource.Initialize">
            <summary>
            Initializes a ConcatFileDataSource.
            </summary>
            <exception cref="T:System.Exception">BatchFile cannot be null!</exception>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.ConcatFileDataSource.GetSeconds(System.Int64)">
            <summary>
            Returns the audio time in seconds represented by the given number of bytes.
            </summary>
            <param name="bytes">The number of bytes.</param>
            <returns>The audio time.</returns>
        </member>
        <member name="P:Syn.Speech.FrontEnds.Util.ConcatFileDataSource.References">
            <summary>
            Gets a list of all reference text. Implements the getReferences() method of ReferenceSource.
            </summary>
            <returns>A list of all reference text</returns>
        </member>
        <member name="P:Syn.Speech.FrontEnds.Util.ConcatFileDataSource.TranscriptFile">
            <summary>
            Gets the name of the transcript file.
            </summary>
            <value>
            The name of the transcript file.
            </value>
        </member>
        <member name="T:Syn.Speech.Api.Configuration">
            <summary>
            Represents common configuration options.
            This configuration is used by high-level recognition classes.
            <see cref="T:Syn.Speech.Api.SpeechAligner"/>
            <see cref="T:Syn.Speech.Api.LiveSpeechRecognizer"/>
            <see cref="T:Syn.Speech.Api.StreamSpeechRecognizer"/> 
            </summary>
        </member>
        <member name="P:Syn.Speech.Api.Configuration.AcousticModelPath">
            <summary>
            Gets or sets path to acoustic model.
            </summary>
            <value>
            The acoustic model path.
            </value>
        </member>
        <member name="P:Syn.Speech.Api.Configuration.DictionaryPath">
            <summary>
            Gets or sets the path to dictionary.
            </summary>
            <value>
            The dictionary path.
            </value>
        </member>
        <member name="P:Syn.Speech.Api.Configuration.LanguageModelPath">
            <summary>
            Gets or sets the path to language model.
            </summary>
            <value>
            The language model path.
            </value>
        </member>
        <member name="P:Syn.Speech.Api.Configuration.GrammarPath">
            <summary>
            Gets or sets the path to grammar resources.
            </summary>
            <value>
            The grammar path.
            </value>
        </member>
        <member name="P:Syn.Speech.Api.Configuration.GrammarName">
            <summary>
            Gets or sets the grammar name.
            </summary>
            <value>
            The name of the grammar.
            </value>
        </member>
        <member name="P:Syn.Speech.Api.Configuration.UseGrammar">
            <summary>
            Gets or sets a value indicating whether fixed grammar should be used instead of language model.
            </summary>
            <value>
              <c>true</c> if [use grammar]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Syn.Speech.Api.Configuration.SampleRate">
            <summary>
            Gets or sets the config sample rate. Default value is 16000
            </summary>
            <value>
            The sample rate.
            </value>
        </member>
        <member name="T:Syn.Speech.Api.Context">
            <summary>
             Helps to tweak configuration without touching XML-file directly.
            </summary>
        </member>
        <member name="M:Syn.Speech.Api.Context.#ctor(Syn.Speech.Api.Configuration)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Api.Context"/> class.
            </summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Syn.Speech.Api.Context.#ctor(Syn.Speech.Helper.URL,Syn.Speech.Api.Configuration)">
            <summary>
            Constructs builder using user-supplied XML configuration.
            </summary>
            <param name="path">path to XML-resource with configuration</param>
            <param name="config">the same instance of {@link Configuration}</param>
        </member>
        <member name="M:Syn.Speech.Api.Context.SetAcousticModel(System.String)">
            <summary>
            Sets acoustic model location.
            It also reads feat.params which should be located at the root of
            acoustic model and sets corresponding parameters of
            <see cref="T:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank2"/> instance.
            </summary>
            <param name="path">The path to directory with acoustic model files.</param>
        </member>
        <member name="M:Syn.Speech.Api.Context.SetDictionary(System.String)">
            <summary>
            Sets the dictionary.
            </summary>
            <param name="path">The path to directory with dictionary files.</param>
        </member>
        <member name="M:Syn.Speech.Api.Context.SetSampleRate(System.Int32)">
            <summary>
            Sets sampleRate.
            </summary>
            <param name="sampleRate">The sample rate of the input stream..</param>
        </member>
        <member name="M:Syn.Speech.Api.Context.SetGrammar(System.String,System.String)">
            <summary>
            Sets path to the grammar files. Enables static grammar and disables probabilistic language model.
            JSGF and GrXML formats are supported.
            </summary>
            <param name="path">The path to the grammar files.</param>
            <param name="name">The name of the main grammar to use.</param>
        </member>
        <member name="M:Syn.Speech.Api.Context.SetLanguageModel(System.String)">
            <summary>
            Sets path to the language model. Enables probabilistic language model and disables static grammar.
            Currently it supports ".lm", ".dmp" and ".bin" file formats.
            </summary>
            <param name="path">The path to the language model file.</param>
            <exception cref="T:System.ArgumentException">Unknown format extension:  + path</exception>
        </member>
        <member name="M:Syn.Speech.Api.Context.SetSpeechSource(System.IO.FileStream)">
            <summary>
            Sets byte stream as the speech source.
            </summary>
            <param name="stream">The stream.</param>
        </member>
        <member name="M:Syn.Speech.Api.Context.SetLocalProperty(System.String,System.Object)">
            <summary>
            Sets property within a "component" tag in configuration.
            Use this method to alter "value" property of a "property" tag inside a
            "component" tag of the XML configuration.
            </summary>
            <param name="name">The property name.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Syn.Speech.Api.Context.SetGlobalProperty(System.String,System.Object)">
            <summary>
            Sets property of a top-level "property" tag.
            Use this method to alter "value" property of a "property" tag whose
            parent is the root tag "config" of the XML configuration.
            </summary>
            <param name="name">The property name.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Syn.Speech.Api.Context.GetInstance(System.Type)">
            <summary>
            Returns instance of the XML configuration by its class.
            </summary>
            <param name="clazz">The class to look up.</param>
            <returns>Instance of the specified class or null.</returns>
        </member>
        <member name="M:Syn.Speech.Api.Context.GetLoader">
            <summary>
            Gets the Loader object used for loading the acoustic model.
            </summary>
            <returns>The loader object.</returns>
        </member>
        <member name="M:Syn.Speech.Api.LiveSpeechRecognizer.StartRecognition(System.Boolean)">
            <summary>
            Starts recognition process.
            Recognition process is paused until the next call to startRecognition.
            </summary>
            <param name="clear">clear cached microphone data.</param>
        </member>
        <member name="M:Syn.Speech.Api.LiveSpeechRecognizer.StopRecognition">
            <summary>
            Stops recognition process.
            </summary>
        </member>
        <member name="T:Syn.Speech.Api.SpeechResult">
            <summary>
            High-level wrapper for {@link Result} instance.
            </summary>
        </member>
        <member name="M:Syn.Speech.Api.SpeechResult.#ctor(Syn.Speech.Results.Result)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Api.SpeechResult"/> class.
            </summary>
            <param name="result">Recognition result returned by <see cref="T:Syn.Speech.Recognizers.Recognizer"/>.</param>
        </member>
        <member name="M:Syn.Speech.Api.SpeechResult.GetWords">
            <summary>
            Returns {@link List} of words of the recognition result.
            Within the list words are ordered by time frame.
            </summary>
            <returns>words that form the result</returns>
        </member>
        <member name="M:Syn.Speech.Api.SpeechResult.GetHypothesis">
            <summary>
            Returns string representation of the result.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Api.SpeechResult.GetNbest(System.Int32)">
            <summary>
            Return N best hypothesis.
            </summary>
            <param name="n">n number of hypothesis to return.</param>
            <returns>List of several best hypothesis</returns>
        </member>
        <member name="P:Syn.Speech.Api.SpeechResult.Lattice">
            <summary>
            Returns lattice for the recognition result.
            </summary>
            <value>lattice object</value>
        </member>
        <member name="P:Syn.Speech.Api.SpeechResult.Result">
            <summary>
            Return Result object of current SpeechResult
            </summary>
            <value>Result object stored in this.result</value>
        </member>
        <member name="T:Syn.Speech.Api.StreamSpeechRecognizer">
            <summary>
            Speech recognizer that works with audio resources. 
            </summary>
        </member>
        <member name="M:Syn.Speech.Api.StreamSpeechRecognizer.#ctor(Syn.Speech.Api.Configuration)">
            <summary>
            Constructs new stream recognizer.
            </summary>
            <param name="configuration">configuration</param>
        </member>
        <member name="M:Syn.Speech.Api.StreamSpeechRecognizer.StartRecognition(System.IO.Stream)">
            <summary>
            Allocates the speech recognizer and starts the speech recognition process.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Syn.Speech.Api.StreamSpeechRecognizer.StartRecognition(System.IO.Stream,Syn.Speech.Util.TimeFrame)">
            <summary>
            Starts recognition process.
            </summary>
            <param name="stream"></param>
            <param name="timeFrame"></param>
        </member>
        <member name="M:Syn.Speech.Api.StreamSpeechRecognizer.StopRecognition">
            <summary>
            Stops recognition process.
            </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.IData">
            <summary>
            Implements the interface for all Data objects that passes between
            DataProcessors.
            Subclass of Data can contain the actual data, or be a signal
            (e.g., data start, data end, speech start, speech end).
            </summary>
        </member>
        <member name="T:Syn.Speech.Fsts.Semirings.ProbabilitySemiring">
            <summary>
            Probability semiring implementation.
            @author "John Salatas "jsalatas@users.sourceforge.net"
            </summary>
        </member>
        <member name="T:Syn.Speech.Fsts.Semirings.Semiring">
            <summary>
            bstract semiring class.
            
            @author "John Salatas "jsalatas@users.sourceforge.net"
            </summary>
        </member>
        <member name="M:Syn.Speech.Fsts.Semirings.Semiring.Plus(System.Single,System.Single)">
                    /// Semiring's plus operation
        </member>
        <member name="M:Syn.Speech.Fsts.Semirings.Semiring.Times(System.Single,System.Single)">
                    /// Semiring's times operation
        </member>
        <member name="M:Syn.Speech.Fsts.Semirings.Semiring.Divide(System.Single,System.Single)">
                    /// Semiring's divide operation
        </member>
        <member name="M:Syn.Speech.Fsts.Semirings.Semiring.IsMember(System.Single)">
                    /// Checks if a value is a valid one the semiring
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Fsts.Semirings.Semiring.NaturalLess(System.Single,System.Single)" -->
        <member name="P:Syn.Speech.Fsts.Semirings.Semiring.Zero">
                    /// Semiring's zero element
        </member>
        <member name="P:Syn.Speech.Fsts.Semirings.Semiring.One">
                    /// Semiring's one element
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.complex.Complex">
             Representation of a Complex number, i.e. a number which has both a
             real and imaginary part.
             <br/>
             Implementations of arithmetic operations handle {@code NaN} and
             infinite values according to the rules for {@link java.lang.Double}, i.e.
             {@link #equals} is an equivalence relation for all instances that have
             a {@code NaN} in either real or imaginary part, e.g. the following are
             considered equal:
             <ul>
              <li>{@code 1 + NaNi}</li>
              <li>{@code NaN + i}</li>
              <li>{@code NaN + NaNi}</li>
             </ul>
             Note that this is in contradiction with the IEEE-754 standard for floating
             point numbers (according to which the test {@code x == x} must fail if
             {@code x} is {@code NaN}). The method
             {@link org.apache.commons.math3.util.Precision#equals(double,double,int)
             equals for primitive double} in {@link org.apache.commons.math3.util.Precision}
             conforms with IEEE-754 while this class conforms with the standard behavior
             for Java object types.
             <br/>
             Implements Serializable since 2.0
            
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.FieldElement`1.add(`0)">
            Compute this + a.
            @param a element to add
            @return a new element representing this + a
            @throws NullArgumentException if {@code addend} is {@code null}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.FieldElement`1.subtract(`0)">
            Compute this - a.
            @param a element to subtract
            @return a new element representing this - a
            @throws NullArgumentException if {@code a} is {@code null}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.FieldElement`1.negate">
            Returns the additive inverse of {@code this} element.
            @return the opposite of {@code this}.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.FieldElement`1.multiply(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.FieldElement`1.multiply(`0)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.FieldElement`1.divide(`0)" -->
        <member name="M:Syn.Speech.Helper.Mathematics.FieldElement`1.reciprocal">
            Returns the multiplicative inverse of {@code this} element.
            @return the inverse of {@code this}.
            @throws MathArithmeticException if {@code this} is zero
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.FieldElement`1.getField">
            Get the {@link Field} to which the instance belongs.
            @return {@link Field} to which the instance belongs
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.complex.Complex.serialVersionUID">
            Serializable version identifier 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.complex.Complex.I">
            The square root of -1. A number representing "0.0 + 1.0i" 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.complex.Complex.NaN">
            A complex number representing "NaN + NaNi" 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.complex.Complex.INF">
            A complex number representing "+INF + INFi" 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.complex.Complex.ONE">
            A complex number representing "1.0 + 0.0i" 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.complex.Complex.ZERO">
            A complex number representing "0.0 + 0.0i" 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.complex.Complex.imaginary">
            The imaginary part. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.complex.Complex.real">
            The real part. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.complex.Complex._isNaN">
            Record whether this complex number is equal to NaN. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.complex.Complex._isInfinite">
            Record whether this complex number is infinite. 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.#ctor(System.Double)">
             Create a complex number given only the real part.
            
             @param real Real part.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.#ctor(System.Double,System.Double)">
             Create a complex number given the real and imaginary parts.
            
             @param real Real part.
             @param imaginary Imaginary part.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.abs">
             Return the absolute value of this complex number.
             Returns {@code NaN} if either real or imaginary part is {@code NaN}
             and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},
             but at least one part is infinite.
            
             @return the absolute value.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.add(Syn.Speech.Helper.Mathematics.complex.Complex)">
             Returns a {@code Complex} whose value is
             {@code (this + addend)}.
             Uses the definitional formula
             <pre>
              <code>
               (a + bi) + (c + di) = (a+c) + (b+d)i
              </code>
             </pre>
             <br/>
             If either {@code this} or {@code addend} has a {@code NaN} value in
             either part, {@link #NaN} is returned; otherwise {@code Infinite}
             and {@code NaN} values are returned in the parts of the result
             according to the rules for {@link java.lang.Double} arithmetic.
            
             @param  addend Value to be added to this {@code Complex}.
             @return {@code this + addend}.
             @throws NullArgumentException if {@code addend} is {@code null}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.add(System.Double)">
             Returns a {@code Complex} whose value is {@code (this + addend)},
             with {@code addend} interpreted as a real number.
            
             @param addend Value to be added to this {@code Complex}.
             @return {@code this + addend}.
             @see #add(Complex)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.conjugate">
             Return the conjugate of this complex number.
             The conjugate of {@code a + bi} is {@code a - bi}.
             <br/>
             {@link #NaN} is returned if either the real or imaginary
             part of this Complex number equals {@code Double.NaN}.
             <br/>
             If the imaginary part is infinite, and the real part is not
             {@code NaN}, the returned value has infinite imaginary part
             of the opposite sign, e.g. the conjugate of
             {@code 1 + POSITIVE_INFINITY i} is {@code 1 - NEGATIVE_INFINITY i}.
            
             @return the conjugate of this Complex object.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.divide(Syn.Speech.Helper.Mathematics.complex.Complex)">
             Returns a {@code Complex} whose value is
             {@code (this / divisor)}.
             Implements the definitional formula
             <pre>
              <code>
                a + bi          ac + bd + (bc - ad)i
                ----------- = -------------------------
                c + di         c<sup>2</sup> + d<sup>2</sup>
              </code>
             </pre>
             but uses
             <a href="http://doi.acm.org/10.1145/1039813.1039814">
             prescaling of operands</a> to limit the effects of overflows and
             underflows in the computation.
             <br/>
             {@code Infinite} and {@code NaN} values are handled according to the
             following rules, applied in the order presented:
             <ul>
              <li>If either {@code this} or {@code divisor} has a {@code NaN} value
               in either part, {@link #NaN} is returned.
              </li>
              <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.
              </li>
              <li>If {@code this} and {@code divisor} are both infinite,
               {@link #NaN} is returned.
              </li>
              <li>If {@code this} is finite (i.e., has no {@code Infinite} or
               {@code NaN} parts) and {@code divisor} is infinite (one or both parts
               infinite), {@link #ZERO} is returned.
              </li>
              <li>If {@code this} is infinite and {@code divisor} is finite,
               {@code NaN} values are returned in the parts of the result if the
               {@link java.lang.Double} rules applied to the definitional formula
               force {@code NaN} results.
              </li>
             </ul>
            
             @param divisor Value by which this {@code Complex} is to be divided.
             @return {@code this / divisor}.
             @throws NullArgumentException if {@code divisor} is {@code null}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.divide(System.Double)">
             Returns a {@code Complex} whose value is {@code (this / divisor)},
             with {@code divisor} interpreted as a real number.
            
             @param  divisor Value by which this {@code Complex} is to be divided.
             @return {@code this / divisor}.
             @see #divide(Complex)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.reciprocal">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.Equals(System.Object)">
             Test for equality with another object.
             If both the real and imaginary parts of two complex numbers
             are exactly the same, and neither is {@code Double.NaN}, the two
             Complex objects are considered to be equal.
             The behavior is the same as for JDK's {@link Double#equals(Object)
             Double}:
             <ul>
              <li>All {@code NaN} values are considered to be equal,
               i.e, if either (or both) real and imaginary parts of the complex
               number are equal to {@code Double.NaN}, the complex number is equal
               to {@code NaN}.
              </li>
              <li>
               Instances constructed with different representations of zero (i.e.
               either "0" or "-0") are <em>not</em> considered to be equal.
              </li>
             </ul>
            
             @param other Object to test for equality with this instance.
             @return {@code true} if the objects are equal, {@code false} if object
             is {@code null}, not an instance of {@code Complex}, or not equal to
             this instance.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.Equals(Syn.Speech.Helper.Mathematics.complex.Complex,Syn.Speech.Helper.Mathematics.complex.Complex,System.Int32)">
             Test for the floating-point equality between Complex objects.
             It returns {@code true} if both arguments are equal or within the
             range of allowed error (inclusive).
            
             @param x First value (cannot be {@code null}).
             @param y Second value (cannot be {@code null}).
             @param maxUlps {@code (maxUlps - 1)} is the number of floating point
             values between the real (resp. imaginary) parts of {@code x} and
             {@code y}.
             @return {@code true} if there are fewer than {@code maxUlps} floating
             point values between the real (resp. imaginary) parts of {@code x}
             and {@code y}.
            
             @see Precision#equals(double,double,int)
             @since 3.3
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.Equals(Syn.Speech.Helper.Mathematics.complex.Complex,Syn.Speech.Helper.Mathematics.complex.Complex)">
             Returns {@code true} iff the values are equal as defined by
             {@link #equals(Complex,Complex,int) equals(x, y, 1)}.
            
             @param x First value (cannot be {@code null}).
             @param y Second value (cannot be {@code null}).
             @return {@code true} if the values are equal.
            
             @since 3.3
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.Equals(Syn.Speech.Helper.Mathematics.complex.Complex,Syn.Speech.Helper.Mathematics.complex.Complex,System.Double)">
             Returns {@code true} if, both for the real part and for the imaginary
             part, there is no double value strictly between the arguments or the
             difference between them is within the range of allowed error
             (inclusive).
            
             @param x First value (cannot be {@code null}).
             @param y Second value (cannot be {@code null}).
             @param eps Amount of allowed absolute error.
             @return {@code true} if the values are two adjacent floating point
             numbers or they are within range of each other.
            
             @see Precision#equals(double,double,double)
             @since 3.3
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.equalsWithRelativeTolerance(Syn.Speech.Helper.Mathematics.complex.Complex,Syn.Speech.Helper.Mathematics.complex.Complex,System.Double)">
             Returns {@code true} if, both for the real part and for the imaginary
             part, there is no double value strictly between the arguments or the
             relative difference between them is smaller or equal to the given
             tolerance.
            
             @param x First value (cannot be {@code null}).
             @param y Second value (cannot be {@code null}).
             @param eps Amount of allowed relative error.
             @return {@code true} if the values are two adjacent floating point
             numbers or they are within range of each other.
            
             @see Precision#equalsWithRelativeTolerance(double,double,double)
             @since 3.3
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.HashCode">
             Get a hashCode for the complex number.
             Any {@code Double.NaN} value in real or imaginary part produces
             the same hash code {@code 7}.
            
             @return a hash code value for this object.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.getImaginary">
             Access the imaginary part.
            
             @return the imaginary part.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.getReal">
             Access the real part.
            
             @return the real part.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.isNaN">
             Checks whether either or both parts of this complex number is
             {@code NaN}.
            
             @return true if either or both parts of this complex number is
             {@code NaN}; false otherwise.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.isInfinite">
             Checks whether either the real or imaginary part of this complex number
             takes an infinite value (either {@code Double.POSITIVE_INFINITY} or
             {@code Double.NEGATIVE_INFINITY}) and neither part
             is {@code NaN}.
            
             @return true if one or both parts of this complex number are infinite
             and neither part is {@code NaN}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.multiply(Syn.Speech.Helper.Mathematics.complex.Complex)">
             Returns a {@code Complex} whose value is {@code this * factor}.
             Implements preliminary checks for {@code NaN} and infinity followed by
             the definitional formula:
             <pre>
              <code>
               (a + bi)(c + di) = (ac - bd) + (ad + bc)i
              </code>
             </pre>
             Returns {@link #NaN} if either {@code this} or {@code factor} has one or
             more {@code NaN} parts.
             <br/>
             Returns {@link #INF} if neither {@code this} nor {@code factor} has one
             or more {@code NaN} parts and if either {@code this} or {@code factor}
             has one or more infinite parts (same result is returned regardless of
             the sign of the components).
             <br/>
             Returns finite values in components of the result per the definitional
             formula in all remaining cases.
            
             @param  factor value to be multiplied by this {@code Complex}.
             @return {@code this * factor}.
             @throws NullArgumentException if {@code factor} is {@code null}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.multiply(System.Int32)">
             Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}
             interpreted as a integer number.
            
             @param  factor value to be multiplied by this {@code Complex}.
             @return {@code this * factor}.
             @see #multiply(Complex)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.multiply(System.Double)">
             Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}
             interpreted as a real number.
            
             @param  factor value to be multiplied by this {@code Complex}.
             @return {@code this * factor}.
             @see #multiply(Complex)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.negate">
             Returns a {@code Complex} whose value is {@code (-this)}.
             Returns {@code NaN} if either real or imaginary
             part of this Complex number equals {@code Double.NaN}.
            
             @return {@code -this}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.subtract(Syn.Speech.Helper.Mathematics.complex.Complex)">
             Returns a {@code Complex} whose value is
             {@code (this - subtrahend)}.
             Uses the definitional formula
             <pre>
              <code>
               (a + bi) - (c + di) = (a-c) + (b-d)i
              </code>
             </pre>
             If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part,
             {@link #NaN} is returned; otherwise infinite and {@code NaN} values are
             returned in the parts of the result according to the rules for
             {@link java.lang.Double} arithmetic.
            
             @param  subtrahend value to be subtracted from this {@code Complex}.
             @return {@code this - subtrahend}.
             @throws NullArgumentException if {@code subtrahend} is {@code null}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.subtract(System.Double)">
             Returns a {@code Complex} whose value is
             {@code (this - subtrahend)}.
            
             @param  subtrahend value to be subtracted from this {@code Complex}.
             @return {@code this - subtrahend}.
             @see #subtract(Complex)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.acos">
             Compute the
             <a href="http://mathworld.wolfram.com/InverseCosine.html" TARGET="_top">
             inverse cosine</a> of this complex number.
             Implements the formula:
             <pre>
              <code>
               acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))
              </code>
             </pre>
             Returns {@link Complex#NaN} if either real or imaginary part of the
             input argument is {@code NaN} or infinite.
            
             @return the inverse cosine of this complex number.
             @since 1.2
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.asin">
             Compute the
             <a href="http://mathworld.wolfram.com/InverseSine.html" TARGET="_top">
             inverse sine</a> of this complex number.
             Implements the formula:
             <pre>
              <code>
               asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))
              </code>
             </pre>
             Returns {@link Complex#NaN} if either real or imaginary part of the
             input argument is {@code NaN} or infinite.
            
             @return the inverse sine of this complex number.
             @since 1.2
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.atan">
             Compute the
             <a href="http://mathworld.wolfram.com/InverseTangent.html" TARGET="_top">
             inverse tangent</a> of this complex number.
             Implements the formula:
             <pre>
              <code>
               atan(z) = (i/2) log((i + z)/(i - z))
              </code>
             </pre>
             Returns {@link Complex#NaN} if either real or imaginary part of the
             input argument is {@code NaN} or infinite.
            
             @return the inverse tangent of this complex number
             @since 1.2
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.complex.Complex.cos" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.complex.Complex.cosh" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.complex.Complex.exp" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.complex.Complex.log" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.complex.Complex.pow(Syn.Speech.Helper.Mathematics.complex.Complex)" -->
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.pow(System.Double)">
             Returns of value of this complex number raised to the power of {@code x}.
            
             @param  x exponent to which this {@code Complex} is to be raised.
             @return <code>this<sup>x</sup></code>.
             @see #pow(Complex)
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.complex.Complex.sin" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.complex.Complex.sinh" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.complex.Complex.sqrt" -->
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.sqrt1z">
             Compute the
             <a href="http://mathworld.wolfram.com/SquareRoot.html" TARGET="_top">
             square root</a> of <code>1 - this<sup>2</sup></code> for this complex
             number.
             Computes the result directly as
             {@code sqrt(ONE.subtract(z.multiply(z)))}.
             <br/>
             Returns {@link Complex#NaN} if either real or imaginary part of the
             input argument is {@code NaN}.
             <br/>
             Infinite values in real or imaginary parts of the input may result in
             infinite or NaN values returned in parts of the result.
            
             @return the square root of <code>1 - this<sup>2</sup></code>.
             @since 1.2
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.complex.Complex.tan" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.complex.Complex.tanh" -->
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.getArgument">
             Compute the argument of this complex number.
             The argument is the angle phi between the positive real axis and
             the point representing this number in the complex plane.
             The value returned is between -PI (not inclusive)
             and PI (inclusive), with negative values returned for numbers with
             negative imaginary parts.
             <br/>
             If either real or imaginary part (or both) is NaN, NaN is returned.
             Infinite parts are handled as {@code Math.atan2} handles them,
             essentially treating finite parts as zero in the presence of an
             infinite coordinate and returning a multiple of pi/4 depending on
             the signs of the infinite parts.
             See the javadoc for {@code Math.atan2} for full details.
            
             @return the argument of {@code this}.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.complex.Complex.nthRoot(System.Int32)" -->
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.createComplex(System.Double,System.Double)">
             Create a complex number given the real and imaginary parts.
            
             @param realPart Real part.
             @param imaginaryPart Imaginary part.
             @return a new complex number instance.
             @since 1.2
             @see #valueOf(double, double)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.valueOf(System.Double,System.Double)">
             Create a complex number given the real and imaginary parts.
            
             @param realPart Real part.
             @param imaginaryPart Imaginary part.
             @return a Complex instance.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.valueOf(System.Double)">
             Create a complex number given only the real part.
            
             @param realPart Real part.
             @return a Complex instance.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.readResolve">
             Resolve the transient fields in a deserialized Complex Object.
             Subclasses will need to override {@link #createComplex} to
             deserialize properly.
            
             @return A Complex instance with all fields resolved.
             @since 2.0
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.getField">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.Complex.ToString">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Field`1.getZero">
            Get the additive identity of the field.
            <p>
            The additive identity is the element e<sub>0</sub> of the field such that
            for all elements a of the field, the equalities a + e<sub>0</sub> =
            e<sub>0</sub> + a = a hold.
            </p>
            @return additive identity of the field
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Field`1.getOne" -->
        <member name="M:Syn.Speech.Helper.Mathematics.Field`1.getRuntimeClass">
             Returns the runtime class of the FieldElement.
            
             @return The {@code Class} object that represents the runtime
                     class of this object.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.ComplexField.#ctor">
            Private constructor for the singleton.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.ComplexField.getInstance">
            Get the unique instance.
            @return the unique instance
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.ComplexField.getOne">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.ComplexField.getZero">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.ComplexField.getRuntimeClass">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.complex.ComplexField.readResolve">
            Handle deserialization of the singleton.
            @return the singleton instance
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.complex.ComplexField.LazyHolder">
            Holder for the instance.
            <p>We use here the Initialization On Demand Holder Idiom.</p>
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.complex.ComplexField.LazyHolder.INSTANCE">
            Cached field instance. 
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix">
            <summary>
            Basic implementation of RealMatrix methods regardless of the underlying storage.
            </summary>
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Linear.AnyMatrix">
            <summary>
            Interface defining very basic matrix operations.
            </summary>
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AnyMatrix.isSquare">
            <summary>
            Is this a square matrix?
            </summary>
            <returns> true if the matrix is square (rowDimension = columnDimension)</returns>
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AnyMatrix.getRowDimension">
            <summary>
             Returns the number of rows in the matrix.
            </summary>
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AnyMatrix.getColumnDimension">
            <summary>
            Returns the number of columns in the matrix.
            </summary>
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.#cctor">
            Default format. 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.#ctor">
            Creates a matrix with no data
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.#ctor(System.Int32,System.Int32)">
             Create a new RealMatrix with the supplied row and column dimensions.
            
             @param rowDimension  the number of rows in the new matrix
             @param columnDimension  the number of columns in the new matrix
             @throws NotStrictlyPositiveException if row or column dimension is not positive
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.add(Syn.Speech.Helper.Mathematics.Linear.RealMatrix)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.subtract(Syn.Speech.Helper.Mathematics.Linear.RealMatrix)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.scalarAdd(System.Double)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.scalarMultiply(System.Double)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.multiply(Syn.Speech.Helper.Mathematics.Linear.RealMatrix)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.preMultiply(Syn.Speech.Helper.Mathematics.Linear.RealMatrix)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.power(System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.getData">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.getNorm">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.getFrobeniusNorm">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.getSubMatrix(System.Int32,System.Int32,System.Int32,System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.getSubMatrix(System.Int32[],System.Int32[])">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.copySubMatrix(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[][])">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.copySubMatrix(System.Int32[],System.Int32[],System.Double[][])">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.setSubMatrix(System.Double[][],System.Int32,System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.getRowMatrix(System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.setRowMatrix(System.Int32,Syn.Speech.Helper.Mathematics.Linear.RealMatrix)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.getColumnMatrix(System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.setColumnMatrix(System.Int32,Syn.Speech.Helper.Mathematics.Linear.RealMatrix)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.getRowVector(System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.setRowVector(System.Int32,Syn.Speech.Helper.Mathematics.Linear.RealVector)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.getColumnVector(System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.setColumnVector(System.Int32,Syn.Speech.Helper.Mathematics.Linear.RealVector)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.getRow(System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.setRow(System.Int32,System.Double[])">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.getColumn(System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.setColumn(System.Int32,System.Double[])">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.addToEntry(System.Int32,System.Int32,System.Double)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.multiplyEntry(System.Int32,System.Int32,System.Double)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.transpose">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.isSquare">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.getRowDimension">
             Returns the number of rows of this matrix.
            
             @return the number of rows.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.getColumnDimension">
             Returns the number of columns of this matrix.
            
             @return the number of columns.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.getTrace">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.operate(System.Double[])">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.preMultiply(System.Double[])">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.preMultiply(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.walkInRowOrder(Syn.Speech.Helper.Mathematics.Linear.RealMatrixChangingVisitor)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.walkInRowOrder(Syn.Speech.Helper.Mathematics.Linear.RealMatrixPreservingVisitor)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.walkInRowOrder(Syn.Speech.Helper.Mathematics.Linear.RealMatrixChangingVisitor,System.Int32,System.Int32,System.Int32,System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.walkInRowOrder(Syn.Speech.Helper.Mathematics.Linear.RealMatrixPreservingVisitor,System.Int32,System.Int32,System.Int32,System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.walkInColumnOrder(Syn.Speech.Helper.Mathematics.Linear.RealMatrixChangingVisitor)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.walkInColumnOrder(Syn.Speech.Helper.Mathematics.Linear.RealMatrixPreservingVisitor)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.walkInColumnOrder(Syn.Speech.Helper.Mathematics.Linear.RealMatrixChangingVisitor,System.Int32,System.Int32,System.Int32,System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.walkInColumnOrder(Syn.Speech.Helper.Mathematics.Linear.RealMatrixPreservingVisitor,System.Int32,System.Int32,System.Int32,System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.walkInOptimizedOrder(Syn.Speech.Helper.Mathematics.Linear.RealMatrixChangingVisitor)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.walkInOptimizedOrder(Syn.Speech.Helper.Mathematics.Linear.RealMatrixPreservingVisitor)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.walkInOptimizedOrder(Syn.Speech.Helper.Mathematics.Linear.RealMatrixChangingVisitor,System.Int32,System.Int32,System.Int32,System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.walkInOptimizedOrder(Syn.Speech.Helper.Mathematics.Linear.RealMatrixPreservingVisitor,System.Int32,System.Int32,System.Int32,System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.ToString">
            Get a string representation for this matrix.
            @return a string representation for this matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.Equals(System.Object)">
             Returns true iff <code>object</code> is a
             <code>RealMatrix</code> instance with the same dimensions as this
             and all corresponding matrix entries are equal.
            
             @param object the object to test equality against.
             @return true if object equals this
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.GetHashCode">
             Computes a hashcode for the matrix.
            
             @return hashcode for matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.createMatrix(System.Int32,System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.copy">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.getEntry(System.Int32,System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.AbstractRealMatrix.setEntry(System.Int32,System.Int32,System.Double)">
            {@inheritDoc} 
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Linear.RealMatrixPreservingVisitor">
             Interface defining a visitor for matrix entries.
            
             @see DefaultRealMatrixPreservingVisitor
             @since 2.0
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealMatrixPreservingVisitor.start(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            Start visiting a matrix.
            <p>This method is called once before any entry of the matrix is visited.</p>
            @param rows number of rows of the matrix
            @param columns number of columns of the matrix
            @param startRow Initial row index
            @param endRow Final row index (inclusive)
            @param startColumn Initial column index
            @param endColumn Final column index (inclusive)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealMatrixPreservingVisitor.visit(System.Int32,System.Int32,System.Double)">
            Visit one matrix entry.
            @param row row index of the entry
            @param column column index of the entry
            @param value current value of the entry
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealMatrixPreservingVisitor.end">
            End visiting a matrix.
            <p>This method is called once after all entries of the matrix have been visited.</p>
            @return the value that the <code>walkInXxxOrder</code> must return
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.DefaultRealMatrixPreservingVisitor.start(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.DefaultRealMatrixPreservingVisitor.visit(System.Int32,System.Int32,System.Double)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.DefaultRealMatrixPreservingVisitor.end">
            {@inheritDoc} 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.SecondDefaultRealMatrixPreservingVisitor._realMatrix">
            {@inheritDoc} 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.FirstRealMatrixPreservingVisitor.endRow">
            Last row index. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.FirstRealMatrixPreservingVisitor.columnSum">
            Sum of absolute values on one column. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.FirstRealMatrixPreservingVisitor.maxColSum">
            Maximal sum across all columns. 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.FirstRealMatrixPreservingVisitor.start(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.FirstRealMatrixPreservingVisitor.visit(System.Int32,System.Int32,System.Double)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.FirstRealMatrixPreservingVisitor.end">
            {@inheritDoc} 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.FirstDefaultRealMatrixPreservingVisitor.startRow">
            Initial row index. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.FirstDefaultRealMatrixPreservingVisitor.startColumn">
            Initial column index. 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.FirstDefaultRealMatrixPreservingVisitor.#ctor(System.Double[][])">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.FirstDefaultRealMatrixPreservingVisitor.visit(System.Int32,System.Int32,System.Double)">
            {@inheritDoc} 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.SecondRealMatrixPreservingVisitor.sum">
            Sum of squared entries. 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.SecondRealMatrixPreservingVisitor.start(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.SecondRealMatrixPreservingVisitor.visit(System.Int32,System.Int32,System.Double)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.SecondRealMatrixPreservingVisitor.end">
            {@inheritDoc} 
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Linear.DefaultRealMatrixChangingVisitor">
            <summary>
            Default implementation of the {@link RealMatrixChangingVisitor} interface.
            </summary>
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Linear.RealMatrixChangingVisitor">
             Interface defining a visitor for matrix entries.
            
             @see DefaultRealMatrixChangingVisitor
             @since 2.0
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealMatrixChangingVisitor.start(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            Start visiting a matrix.
            <p>This method is called once before any entry of the matrix is visited.</p>
            @param rows number of rows of the matrix
            @param columns number of columns of the matrix
            @param startRow Initial row index
            @param endRow Final row index (inclusive)
            @param startColumn Initial column index
            @param endColumn Final column index (inclusive)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealMatrixChangingVisitor.visit(System.Int32,System.Int32,System.Double)">
            Visit one matrix entry.
            @param row row index of the entry
            @param column column index of the entry
            @param value current value of the entry
            @return the new value to be set for the entry
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealMatrixChangingVisitor.end">
            End visiting a matrix.
            <p>This method is called once after all entries of the matrix have been visited.</p>
            @return the value that the <code>walkInXxxOrder</code> must return
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.FirstDefaultRealMatrixChangingVisitor._selectedRows">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Analysis.FunctionUtils.fix2ndArgument(Syn.Speech.Helper.Mathematics.Analysis.BivariateFunction,System.Double)">
            <summary>
            Creates a unary function by fixing the second argument of a binary function.
            </summary>
            <param name="f">Binary function..</param>
            <param name="fixed">Value to which the second argument of {@code f} is set..</param>
            <returns>the unary function h(x) = f(x, fixed)</returns>
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Analysis.UnivariateFunction.value(System.Double)">
             <summary>
            Compute the value of the function.
             </summary>
             <param name="x">Point at which the function value should be computed..</param>
             <returns></returns>
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Analysis.BivariateFunction">
            <summary>
            An interface representing a bivariate real function.
            </summary>
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Analysis.BivariateFunction.value(System.Double,System.Double)">
            <summary>
            Compute the value for the function.
            </summary>
            <param name="x">Abscissa for which the function value should be computed..</param>
            <param name="y">Ordinate for which the function value should be computed..</param>
            <returns>the value.</returns>
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Analysis.Function.Add">
            <summary>
            Add the two operands.
            </summary>
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Analysis.Function.Divide">
            <summary>
            Divide the first operand by the second.
            </summary>
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Analysis.Function.Multiply">
            <summary>
            Multiply the two operands.
            </summary>
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.BLOCK_SIZE">
            Block size. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.blocks">
            Blocks of matrix entries. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.rows">
            Number of rows of the matrix. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.columns">
            Number of columns of the matrix. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.blockRows">
            Number of block rows of the matrix. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.blockColumns">
            Number of block columns of the matrix. 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.#ctor(System.Int32,System.Int32)">
             Create a new matrix with the supplied row and column dimensions.
            
             @param rows  the number of rows in the new matrix
             @param columns  the number of columns in the new matrix
             @throws NotStrictlyPositiveException if row or column dimension is not
             positive.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.#ctor(System.Double[][])">
             Create a new dense matrix copying entries from raw layout data.
             <p>The input array <em>must</em> already be in raw layout.</p>
             <p>Calling this constructor is equivalent to call:
             <pre>matrix = new BlockRealMatrix(rawData.length, rawData[0].length,
                                               toBlocksLayout(rawData), false);</pre>
             </p>
            
             @param rawData data for new matrix, in raw layout
             @throws DimensionMismatchException if the shape of {@code blockData} is
             inconsistent with block layout.
             @throws NotStrictlyPositiveException if row or column dimension is not
             positive.
             @see #BlockRealMatrix(int, int, double[][], boolean)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.#ctor(System.Int32,System.Int32,System.Double[][],System.Boolean)">
             Create a new dense matrix copying entries from block layout data.
             <p>The input array <em>must</em> already be in blocks layout.</p>
            
             @param rows Number of rows in the new matrix.
             @param columns Number of columns in the new matrix.
             @param blockData data for new matrix
             @param copyArray Whether the input array will be copied or referenced.
             @throws DimensionMismatchException if the shape of {@code blockData} is
             inconsistent with block layout.
             @throws NotStrictlyPositiveException if row or column dimension is not
             positive.
             @see #createBlocksLayout(int, int)
             @see #toBlocksLayout(double[][])
             @see #BlockRealMatrix(double[][])
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.toBlocksLayout(System.Double[][])">
            Convert a data array from raw layout to blocks layout.
            <p>
            Raw layout is the straightforward layout where element at row i and
            column j is in array element <code>rawData[i][j]</code>. Blocks layout
            is the layout used in {@link BlockRealMatrix} instances, where the matrix
            is split in square blocks (except at right and bottom side where blocks may
            be rectangular to fit matrix size) and each block is stored in a flattened
            one-dimensional array.
            </p>
            <p>
            This method creates an array in blocks layout from an input array in raw layout.
            It can be used to provide the array argument of the {@link
            #BlockRealMatrix(int, int, double[][], boolean)} constructor.
            </p>
            @param rawData Data array in raw layout.
            @return a new data array containing the same entries but in blocks layout.
            @throws DimensionMismatchException if {@code rawData} is not rectangular.
            @see #createBlocksLayout(int, int)
            @see #BlockRealMatrix(int, int, double[][], boolean)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.createBlocksLayout(System.Int32,System.Int32)">
            Create a data array in blocks layout.
            <p>
            This method can be used to create the array argument of the {@link
            #BlockRealMatrix(int, int, double[][], boolean)} constructor.
            </p>
            @param rows Number of rows in the new matrix.
            @param columns Number of columns in the new matrix.
            @return a new data array in blocks layout.
            @see #toBlocksLayout(double[][])
            @see #BlockRealMatrix(int, int, double[][], boolean)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.add(Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix)">
             Compute the sum of this matrix and {@code m}.
            
             @param m Matrix to be added.
             @return {@code this} + m.
             @throws MatrixDimensionMismatchException if {@code m} is not the same
             size as this matrix.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.subtract(Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix)">
             Subtract {@code m} from this matrix.
            
             @param m Matrix to be subtracted.
             @return {@code this} - m.
             @throws MatrixDimensionMismatchException if {@code m} is not the
             same size as this matrix.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.multiply(Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix)">
             Returns the result of postmultiplying this by {@code m}.
            
             @param m Matrix to postmultiply by.
             @return {@code this} * m.
             @throws DimensionMismatchException if the matrices are not compatible.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.copyBlockPart(System.Double[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32,System.Int32)">
            Copy a part of a block into another one
            <p>This method can be called only when the specified part fits in both
            blocks, no verification is done here.</p>
            @param srcBlock source block
            @param srcWidth source block width ({@link #BLOCK_SIZE} or smaller)
            @param srcStartRow start row in the source block
            @param srcEndRow end row (exclusive) in the source block
            @param srcStartColumn start column in the source block
            @param srcEndColumn end column (exclusive) in the source block
            @param dstBlock destination block
            @param dstWidth destination block width ({@link #BLOCK_SIZE} or smaller)
            @param dstStartRow start row in the destination block
            @param dstStartColumn start column in the destination block
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.setRowMatrix(System.Int32,Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix)">
             Sets the entries in row number <code>row</code>
             as a row matrix.  Row indices start at 0.
            
             @param row the row to be set
             @param matrix row matrix (must have one row and the same number of columns
             as the instance)
             @throws OutOfRangeException if the specified row index is invalid.
             @throws MatrixDimensionMismatchException if the matrix dimensions do
             not match one instance row.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.setColumnMatrix(System.Int32,Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix)">
             Sets the entries in column number <code>column</code>
             as a column matrix.  Column indices start at 0.
            
             @param column the column to be set
             @param matrix column matrix (must have one column and the same number of rows
             as the instance)
             @throws OutOfRangeException if the specified column index is invalid.
             @throws MatrixDimensionMismatchException if the matrix dimensions do
             not match one instance column.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.blockHeight(System.Int32)">
            Get the height of a block.
            @param blockRow row index (in block sense) of the block
            @return height (number of rows) of the block
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.BlockRealMatrix.blockWidth(System.Int32)">
            Get the width of a block.
            @param blockColumn column index (in block sense) of the block
            @return width (number of columns) of the block
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Linear.DecompositionSolver.solve(Syn.Speech.Helper.Mathematics.Linear.RealVector)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Linear.DecompositionSolver.solve(Syn.Speech.Helper.Mathematics.Linear.RealMatrix)" -->
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.DecompositionSolver.isNonSingular">
            Check if the decomposed matrix is non-singular.
            @return true if the decomposed matrix is non-singular.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Linear.DecompositionSolver.getInverse" -->
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.HessenbergTransformer.householderVectors">
            Householder vectors. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.HessenbergTransformer.ort">
            Temporary storage vector. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.HessenbergTransformer.cachedP">
            Cached value of P. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.HessenbergTransformer.cachedPt">
            Cached value of Pt. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.HessenbergTransformer.cachedH">
            Cached value of H. 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.HessenbergTransformer.#ctor(Syn.Speech.Helper.Mathematics.Linear.RealMatrix)">
             Build the transformation to Hessenberg form of a general matrix.
            
             @param matrix matrix to transform
             @throws NonSquareMatrixException if the matrix is not square
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.HessenbergTransformer.getP">
             Returns the matrix P of the transform.
             <p>P is an orthogonal matrix, i.e. its inverse is also its transpose.</p>
            
             @return the P matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.HessenbergTransformer.getPT">
             Returns the transpose of the matrix P of the transform.
             <p>P is an orthogonal matrix, i.e. its inverse is also its transpose.</p>
            
             @return the transpose of the P matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.HessenbergTransformer.getH">
             Returns the Hessenberg matrix H of the transform.
            
             @return the H matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.HessenbergTransformer.getHouseholderVectorsRef">
             Get the Householder vectors of the transform.
             <p>Note that since this class is only intended for internal use, it returns
             directly a reference to its internal arrays, not a copy.</p>
            
             @return the main diagonal elements of the B matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.HessenbergTransformer.transform">
            Transform original matrix to Hessenberg form.
            <p>Transformation is done using Householder transforms.</p>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition" -->
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.EPSILON">
            Internally used epsilon criteria. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.maxIter">
            Maximum number of iterations accepted in the implicit QL transformation 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.main">
            Main diagonal of the tridiagonal matrix. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.secondary">
            Secondary diagonal of the tridiagonal matrix. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.transformer">
            Transformer to tridiagonal (may be null if matrix is already
            tridiagonal).
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.realEigenvalues">
            Real part of the realEigenvalues. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.imagEigenvalues">
            Imaginary part of the realEigenvalues. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.eigenvectors">
            Eigenvectors. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.cachedV">
            Cached value of V. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.cachedD">
            Cached value of D. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.cachedVt">
            Cached value of Vt. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.isSymmetric">
            Whether the matrix is symmetric. 
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.#ctor(Syn.Speech.Helper.Mathematics.Linear.RealMatrix)" -->
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.#ctor(Syn.Speech.Helper.Mathematics.Linear.RealMatrix,System.Double)">
             Calculates the eigen decomposition of the given real matrix.
            
             @param matrix Matrix to decompose.
             @param splitTolerance Dummy parameter (present for backward
             compatibility only).
             @throws MathArithmeticException  if the decomposition of a general matrix
             results in a matrix with zero norm
             @throws MaxCountExceededException if the algorithm fails to converge.
             @deprecated in 3.1 (to be removed in 4.0) due to unused parameter
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.#ctor(System.Double[],System.Double[])">
             Calculates the eigen decomposition of the symmetric tridiagonal
             matrix.  The Householder matrix is assumed to be the identity matrix.
            
             @param main Main diagonal of the symmetric tridiagonal form.
             @param secondary Secondary of the tridiagonal form.
             @throws MaxCountExceededException if the algorithm fails to converge.
             @since 3.1
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.#ctor(System.Double[],System.Double[],System.Double)">
             Calculates the eigen decomposition of the symmetric tridiagonal
             matrix.  The Householder matrix is assumed to be the identity matrix.
            
             @param main Main diagonal of the symmetric tridiagonal form.
             @param secondary Secondary of the tridiagonal form.
             @param splitTolerance Dummy parameter (present for backward
             compatibility only).
             @throws MaxCountExceededException if the algorithm fails to converge.
             @deprecated in 3.1 (to be removed in 4.0) due to unused parameter
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.getV">
             Gets the matrix V of the decomposition.
             V is an orthogonal matrix, i.e. its transpose is also its inverse.
             The columns of V are the eigenvectors of the original matrix.
             No assumption is made about the orientation of the system axes formed
             by the columns of V (e.g. in a 3-dimension space, V can form a left-
             or right-handed system).
            
             @return the V matrix.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.getD">
             Gets the block diagonal matrix D of the decomposition.
             D is a block diagonal matrix.
             Real eigenvalues are on the diagonal while complex values are on
             2x2 blocks { {real +imaginary}, {-imaginary, real} }.
            
             @return the D matrix.
            
             @see #getRealEigenvalues()
             @see #getImagEigenvalues()
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.getVT">
             Gets the transpose of the matrix V of the decomposition.
             V is an orthogonal matrix, i.e. its transpose is also its inverse.
             The columns of V are the eigenvectors of the original matrix.
             No assumption is made about the orientation of the system axes formed
             by the columns of V (e.g. in a 3-dimension space, V can form a left-
             or right-handed system).
            
             @return the transpose of the V matrix.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.hasComplexEigenvalues" -->
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.getRealEigenvalues">
             Gets a copy of the real parts of the eigenvalues of the original matrix.
            
             @return a copy of the real parts of the eigenvalues of the original matrix.
            
             @see #getD()
             @see #getRealEigenvalue(int)
             @see #getImagEigenvalues()
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.getRealEigenvalue(System.Int32)">
             Returns the real part of the i<sup>th</sup> eigenvalue of the original
             matrix.
            
             @param i index of the eigenvalue (counting from 0)
             @return real part of the i<sup>th</sup> eigenvalue of the original
             matrix.
            
             @see #getD()
             @see #getRealEigenvalues()
             @see #getImagEigenvalue(int)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.getImagEigenvalues">
             Gets a copy of the imaginary parts of the eigenvalues of the original
             matrix.
            
             @return a copy of the imaginary parts of the eigenvalues of the original
             matrix.
            
             @see #getD()
             @see #getImagEigenvalue(int)
             @see #getRealEigenvalues()
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.getImagEigenvalue(System.Int32)">
             Gets the imaginary part of the i<sup>th</sup> eigenvalue of the original
             matrix.
            
             @param i Index of the eigenvalue (counting from 0).
             @return the imaginary part of the i<sup>th</sup> eigenvalue of the original
             matrix.
            
             @see #getD()
             @see #getImagEigenvalues()
             @see #getRealEigenvalue(int)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.getEigenvector(System.Int32)">
             Gets a copy of the i<sup>th</sup> eigenvector of the original matrix.
            
             @param i Index of the eigenvector (counting from 0).
             @return a copy of the i<sup>th</sup> eigenvector of the original matrix.
             @see #getD()
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.getDeterminant">
             Computes the determinant of the matrix.
            
             @return the determinant of the matrix.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.getSquareRoot">
             Computes the square-root of the matrix.
             This implementation assumes that the matrix is symmetric and positive
             definite.
            
             @return the square-root of the matrix.
             @throws MathUnsupportedOperationException if the matrix is not
             symmetric or not positive definite.
             @since 3.1
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.getSolver" -->
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.transformToTridiagonal(Syn.Speech.Helper.Mathematics.Linear.RealMatrix)">
             Transforms the matrix to tridiagonal form.
            
             @param matrix Matrix to transform.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.findEigenVectors(System.Double[][])">
             Find eigenvalues and eigenvectors (Dubrulle et al., 1971)
            
             @param householderMatrix Householder matrix of the transformation
             to tridiagonal form.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.transformToSchur(Syn.Speech.Helper.Mathematics.Linear.RealMatrix)">
             Transforms the matrix to Schur form and calculates the eigenvalues.
            
             @param matrix Matrix to transform.
             @return the {@link SchurTransformer Shur transform} for this matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.cdiv(System.Double,System.Double,System.Double,System.Double)">
             Performs a division of two complex numbers.
            
             @param xr real part of the first number
             @param xi imaginary part of the first number
             @param yr real part of the second number
             @param yi imaginary part of the second number
             @return result of the complex division
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.findEigenVectorsFromSchur(Syn.Speech.Helper.Mathematics.Linear.SchurTransformer)">
             Find eigenvectors from a matrix transformed to Schur form.
            
             @param schur the schur transformation of the matrix
             @throws MathArithmeticException if the Schur form has a norm of zero
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.Solver">
            Specialized solver. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.Solver.realEigenvalues">
            Real part of the realEigenvalues. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.Solver.imagEigenvalues">
            Imaginary part of the realEigenvalues. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.Solver.eigenvectors">
            Eigenvectors. 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.Solver.#ctor(System.Double[],System.Double[],Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector[])">
             Builds a solver from decomposed matrix.
            
             @param realEigenvalues Real parts of the eigenvalues.
             @param imagEigenvalues Imaginary parts of the eigenvalues.
             @param eigenvectors Eigenvectors.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.Solver.solve(Syn.Speech.Helper.Mathematics.Linear.RealVector)" -->
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.Solver.solve(Syn.Speech.Helper.Mathematics.Linear.RealMatrix)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.Solver.isNonSingular">
             Checks whether the decomposed matrix is non-singular.
            
             @return true if the decomposed matrix is non-singular.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.Solver.eigenvalueNorm(System.Int32)">
            @param i which eigenvalue to find the norm of
            @return the norm of ith (complex) eigenvalue.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.EigenDecomposition.Solver.getInverse">
             Get the inverse of the decomposed matrix.
            
             @return the inverse matrix.
             @throws SingularMatrixException if the decomposed matrix is singular.
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Linear.SparseRealMatrix">
            <summary>
             Marker interface for RealMatrix implementations that require sparse backing storage
            </summary>
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.rows">
            Number of rows of the matrix. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.columns">
            Number of columns of the matrix. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.entries">
            Storage for (sparse) matrix elements. 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.#ctor(System.Int32,System.Int32)">
             Build a sparse matrix with the supplied row and column dimensions.
            
             @param rowDimension Number of rows of the matrix.
             @param columnDimension Number of columns of the matrix.
             @throws NotStrictlyPositiveException if row or column dimension is not
             positive.
             @throws NumberIsTooLargeException if the total number of entries of the
             matrix is larger than {@code Integer.MAX_VALUE}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.#ctor(Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix)">
             Build a matrix by copying another one.
            
             @param matrix matrix to copy.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.copy">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.createMatrix(System.Int32,System.Int32)">
             {@inheritDoc}
            
             @throws NumberIsTooLargeException if the total number of entries of the
             matrix is larger than {@code Integer.MAX_VALUE}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.getColumnDimension">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.add(Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix)">
             Compute the sum of this matrix and {@code m}.
            
             @param m Matrix to be added.
             @return {@code this} + {@code m}.
             @throws MatrixDimensionMismatchException if {@code m} is not the same
             size as {@code this}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.subtract(Syn.Speech.Helper.Mathematics.Linear.RealMatrix)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.subtract(Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix)">
             Subtract {@code m} from this matrix.
            
             @param m Matrix to be subtracted.
             @return {@code this} - {@code m}.
             @throws MatrixDimensionMismatchException if {@code m} is not the same
             size as {@code this}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.multiply(Syn.Speech.Helper.Mathematics.Linear.RealMatrix)">
             {@inheritDoc}
            
             @throws NumberIsTooLargeException if {@code m} is an
             {@code OpenMapRealMatrix}, and the total number of entries of the product
             is larger than {@code Integer.MAX_VALUE}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.multiply(Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix)">
             Postmultiply this matrix by {@code m}.
            
             @param m Matrix to postmultiply by.
             @return {@code this} * {@code m}.
             @throws DimensionMismatchException if the number of rows of {@code m}
             differ from the number of columns of {@code this} matrix.
             @throws NumberIsTooLargeException if the total number of entries of the
             product is larger than {@code Integer.MAX_VALUE}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.getEntry(System.Int32,System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.getRowDimension">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.setEntry(System.Int32,System.Int32,System.Double)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.addToEntry(System.Int32,System.Int32,System.Double)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.multiplyEntry(System.Int32,System.Int32,System.Double)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.OpenMapRealMatrix.computeKey(System.Int32,System.Int32)">
            Compute the key to access a matrix element
            @param row row index of the matrix element
            @param column column index of the matrix element
            @return key within the map to access the matrix element
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealLinearOperator.getRowDimension">
             Returns the dimension of the codomain of this operator.
            
             @return the number of rows of the underlying matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealLinearOperator.getColumnDimension">
             Returns the dimension of the domain of this operator.
            
             @return the number of columns of the underlying matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealLinearOperator.operate(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Returns the result of multiplying {@code this} by the vector {@code x}.
            
             @param x the vector to operate on
             @return the product of {@code this} instance with {@code x}
             @throws DimensionMismatchException if the column dimension does not match
             the size of {@code x}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealLinearOperator.operateTranspose(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Returns the result of multiplying the transpose of {@code this} operator
             by the vector {@code x} (optional operation). The default implementation
             throws an {@link UnsupportedOperationException}. Users overriding this
             method must also override {@link #isTransposable()}.
            
             @param x the vector to operate on
             @return the product of the transpose of {@code this} instance with
             {@code x}
             @throws org.apache.commons.math3.exception.DimensionMismatchException
             if the row dimension does not match the size of {@code x}
             @throws UnsupportedOperationException if this operation is not supported
             by {@code this} operator
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealLinearOperator.isTransposable">
             Returns {@code true} if this operator supports
             {@link #operateTranspose(RealVector)}. If {@code true} is returned,
             {@link #operateTranspose(RealVector)} should not throw
             {@code UnsupportedOperationException}. The default implementation returns
             {@code false}.
            
             @return {@code false}
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Linear.RealVector">
             Class defining a real-valued vector with basic algebraic operations.
             <p>
             vector element indexing is 0-based -- e.g., {@code getEntry(0)}
             returns the first element of the vector.
             </p>
             <p>
             The {@code code map} and {@code mapToSelf} methods operate
             on vectors element-wise, i.e. they perform the same operation (adding a scalar,
             applying a function ...) on each element in turn. The {@code map}
             versions create a new vector to hold the result and do not change the instance.
             The {@code mapToSelf} version uses the instance itself to store the
             results, so the instance is changed by this method. In all cases, the result
             vector is returned by the methods, allowing the <i>fluent API</i>
             style, like this:
             </p>
             <pre>
               RealVector result = v.mapAddToSelf(3.4).mapToSelf(new Tan()).mapToSelf(new Power(2.3));
             </pre>
            
             @since 2.1
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.getDimension">
             Returns the size of the vector.
            
             @return the size of this vector.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.getEntry(System.Int32)">
             Return the entry at the specified index.
            
             @param index Index location of entry to be fetched.
             @return the vector entry at {@code index}.
             @throws OutOfRangeException if the index is not valid.
             @see #setEntry(int, double)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.setEntry(System.Int32,System.Double)">
             Set a single element.
            
             @param index element index.
             @param value new value for the element.
             @throws OutOfRangeException if the index is not valid.
             @see #getEntry(int)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.addToEntry(System.Int32,System.Double)">
             Change an entry at the specified index.
            
             @param index Index location of entry to be set.
             @param increment Value to add to the vector entry.
             @throws OutOfRangeException if the index is not valid.
             @since 3.0
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.append(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Construct a new vector by appending a vector to this vector.
            
             @param v vector to append to this one.
             @return a new vector.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.append(System.Double)">
             Construct a new vector by appending a double to this vector.
            
             @param d double to append.
             @return a new vector.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.getSubVector(System.Int32,System.Int32)">
             Get a subvector from consecutive elements.
            
             @param index index of first element.
             @param n number of elements to be retrieved.
             @return a vector containing n elements.
             @throws OutOfRangeException if the index is not valid.
             @throws NotPositiveException if the number of elements is not positive.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.setSubVector(System.Int32,Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Set a sequence of consecutive elements.
            
             @param index index of first element to be set.
             @param v vector containing the values to set.
             @throws OutOfRangeException if the index is not valid.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.isNaN">
             Check whether any coordinate of this vector is {@code NaN}.
            
             @return {@code true} if any coordinate of this vector is {@code NaN},
             {@code false} otherwise.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.isInfinite">
             Check whether any coordinate of this vector is infinite and none are {@code NaN}.
            
             @return {@code true} if any coordinate of this vector is infinite and
             none are {@code NaN}, {@code false} otherwise.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.checkVectorDimensions(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Check if instance and specified vectors have the same dimension.
            
             @param v Vector to compare instance with.
             @throws DimensionMismatchException if the vectors do not
             have the same dimension.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.checkVectorDimensions(System.Int32)">
             Check if instance dimension is equal to some expected value.
            
             @param n Expected dimension.
             @throws DimensionMismatchException if the dimension is
             inconsistent with the vector size.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.checkIndex(System.Int32)">
             Check if an index is valid.
            
             @param index Index to check.
             @exception OutOfRangeException if {@code index} is not valid.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Linear.RealVector.checkIndices(System.Int32,System.Int32)" -->
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.add(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Compute the sum of this vector and {@code v}.
             Returns a new vector. Does not change instance data.
            
             @param v Vector to be added.
             @return {@code this} + {@code v}.
             @throws DimensionMismatchException if {@code v} is not the same size as
             {@code this} vector.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.subtract(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Subtract {@code v} from this vector.
             Returns a new vector. Does not change instance data.
            
             @param v Vector to be subtracted.
             @return {@code this} - {@code v}.
             @throws DimensionMismatchException if {@code v} is not the same size as
             {@code this} vector.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.mapAdd(System.Double)">
             Add a value to each entry.
             Returns a new vector. Does not change instance data.
            
             @param d Value to be added to each entry.
             @return {@code this} + {@code d}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.mapAddToSelf(System.Double)">
             Add a value to each entry.
             The instance is changed in-place.
            
             @param d Value to be added to each entry.
             @return {@code this}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.copy">
             Returns a (deep) copy of this vector.
            
             @return a vector copy.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.dotProduct(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Compute the dot product of this vector with {@code v}.
            
             @param v Vector with which dot product should be computed
             @return the scalar dot product between this instance and {@code v}.
             @throws DimensionMismatchException if {@code v} is not the same size as
             {@code this} vector.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.cosine(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Computes the cosine of the angle between this vector and the
             argument.
            
             @param v Vector.
             @return the cosine of the angle between this vector and {@code v}.
             @throws MathArithmeticException if {@code this} or {@code v} is the null
             vector
             @throws DimensionMismatchException if the dimensions of {@code this} and
             {@code v} do not match
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.ebeDivide(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Element-by-element division.
            
             @param v Vector by which instance elements must be divided.
             @return a vector containing this[i] / v[i] for all i.
             @throws DimensionMismatchException if {@code v} is not the same size as
             {@code this} vector.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.ebeMultiply(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Element-by-element multiplication.
            
             @param v Vector by which instance elements must be multiplied
             @return a vector containing this[i] * v[i] for all i.
             @throws DimensionMismatchException if {@code v} is not the same size as
             {@code this} vector.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.getDistance(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Distance between two vectors.
             <p>This method computes the distance consistent with the
             L<sub>2</sub> norm, i.e. the square root of the sum of
             element differences, or Euclidean distance.</p>
            
             @param v Vector to which distance is requested.
             @return the distance between two vectors.
             @throws DimensionMismatchException if {@code v} is not the same size as
             {@code this} vector.
             @see #getL1Distance(RealVector)
             @see #getLInfDistance(RealVector)
             @see #getNorm()
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.getNorm">
             Returns the L<sub>2</sub> norm of the vector.
             <p>The L<sub>2</sub> norm is the root of the sum of
             the squared elements.</p>
            
             @return the norm.
             @see #getL1Norm()
             @see #getLInfNorm()
             @see #getDistance(RealVector)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.getL1Norm">
             Returns the L<sub>1</sub> norm of the vector.
             <p>The L<sub>1</sub> norm is the sum of the absolute
             values of the elements.</p>
            
             @return the norm.
             @see #getNorm()
             @see #getLInfNorm()
             @see #getL1Distance(RealVector)
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Linear.RealVector.getLInfNorm" -->
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.getL1Distance(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Distance between two vectors.
             <p>This method computes the distance consistent with
             L<sub>1</sub> norm, i.e. the sum of the absolute values of
             the elements differences.</p>
            
             @param v Vector to which distance is requested.
             @return the distance between two vectors.
             @throws DimensionMismatchException if {@code v} is not the same size as
             {@code this} vector.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Linear.RealVector.getLInfDistance(Syn.Speech.Helper.Mathematics.Linear.RealVector)" -->
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.getMinIndex">
             Get the index of the minimum entry.
            
             @return the index of the minimum entry or -1 if vector length is 0
             or all entries are {@code NaN}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.getMinValue">
             Get the value of the minimum entry.
            
             @return the value of the minimum entry or {@code NaN} if all
             entries are {@code NaN}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.getMaxIndex">
             Get the index of the maximum entry.
            
             @return the index of the maximum entry or -1 if vector length is 0
             or all entries are {@code NaN}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.getMaxValue">
             Get the value of the maximum entry.
            
             @return the value of the maximum entry or {@code NaN} if all
             entries are {@code NaN}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.mapMultiply(System.Double)">
             Multiply each entry by the argument. Returns a new vector.
             Does not change instance data.
            
             @param d Multiplication factor.
             @return {@code this} * {@code d}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.mapMultiplyToSelf(System.Double)">
             Multiply each entry.
             The instance is changed in-place.
            
             @param d Multiplication factor.
             @return {@code this}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.mapSubtract(System.Double)">
             Subtract a value from each entry. Returns a new vector.
             Does not change instance data.
            
             @param d Value to be subtracted.
             @return {@code this} - {@code d}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.mapSubtractToSelf(System.Double)">
             Subtract a value from each entry.
             The instance is changed in-place.
            
             @param d Value to be subtracted.
             @return {@code this}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.mapDivide(System.Double)">
             Divide each entry by the argument. Returns a new vector.
             Does not change instance data.
            
             @param d Value to divide by.
             @return {@code this} / {@code d}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.mapDivideToSelf(System.Double)">
             Divide each entry by the argument.
             The instance is changed in-place.
            
             @param d Value to divide by.
             @return {@code this}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.outerProduct(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Compute the outer product.
            
             @param v Vector with which outer product should be computed.
             @return the matrix outer product between this instance and {@code v}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.projection(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Find the orthogonal projection of this vector onto another vector.
            
             @param v vector onto which instance must be projected.
             @return projection of the instance onto {@code v}.
             @throws DimensionMismatchException if {@code v} is not the same size as
             {@code this} vector.
             @throws MathArithmeticException if {@code this} or {@code v} is the null
             vector
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.set(System.Double)">
             Set all elements to a single value.
            
             @param value Single value to set for all elements.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.toArray">
             Convert the vector to an array of {@code double}s.
             The array is independent from this vector data: the elements
             are copied.
            
             @return an array containing a copy of the vector elements.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.unitVector">
             Creates a unit vector pointing in the direction of this vector.
             The instance is not changed by this method.
            
             @return a unit vector pointing in direction of this vector.
             @throws MathArithmeticException if the norm is zero.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.unitize">
             Converts this vector into a unit vector.
             The instance itself is changed by this method.
            
             @throws MathArithmeticException if the norm is zero.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.sparseIterator">
             Create a sparse iterator over the vector, which may omit some entries.
             The ommitted entries are either exact zeroes (for dense implementations)
             or are the entries which are not stored (for real sparse vectors).
             No guarantees are made about order of iteration.
            
             <p>Note: derived classes are required to return an {@link Iterator} that
             returns non-null {@link Entry} objects as long as {@link Iterator#hasNext()}
             returns {@code true}.</p>
            
             @return a sparse iterator.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.iterator">
             Generic dense iterator. Iteration is in increasing order
             of the vector index.
            
             <p>Note: derived classes are required to return an {@link Iterator} that
             returns non-null {@link Entry} objects as long as {@link Iterator#hasNext()}
             returns {@code true}.</p>
            
             @return a dense iterator.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.map(Syn.Speech.Helper.Mathematics.Analysis.UnivariateFunction)">
             Acts as if implemented as:
             <pre>
              return copy().mapToSelf(function);
             </pre>
             Returns a new vector. Does not change instance data.
            
             @param function Function to apply to each entry.
             @return a new vector.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Linear.RealVector.mapToSelf(Syn.Speech.Helper.Mathematics.Analysis.UnivariateFunction)" -->
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.combine(System.Double,System.Double,Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Returns a new vector representing {@code a * this + b * y}, the linear
             combination of {@code this} and {@code y}.
             Returns a new vector. Does not change instance data.
            
             @param a Coefficient of {@code this}.
             @param b Coefficient of {@code y}.
             @param y Vector with which {@code this} is linearly combined.
             @return a vector containing {@code a * this[i] + b * y[i]} for all
             {@code i}.
             @throws DimensionMismatchException if {@code y} is not the same size as
             {@code this} vector.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.combineToSelf(System.Double,System.Double,Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Updates {@code this} with the linear combination of {@code this} and
             {@code y}.
            
             @param a Weight of {@code this}.
             @param b Weight of {@code y}.
             @param y Vector with which {@code this} is linearly combined.
             @return {@code this}, with components equal to
             {@code a * this[i] + b * y[i]} for all {@code i}.
             @throws DimensionMismatchException if {@code y} is not the same size as
             {@code this} vector.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.walkInDefaultOrder(Syn.Speech.Helper.Mathematics.Linear.RealVectorPreservingVisitor)">
             Visits (but does not alter) all entries of this vector in default order
             (increasing index).
            
             @param visitor the visitor to be used to process the entries of this
             vector
             @return the value returned by {@link RealVectorPreservingVisitor#end()}
             at the end of the walk
             @since 3.1
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Linear.RealVector.walkInDefaultOrder(Syn.Speech.Helper.Mathematics.Linear.RealVectorPreservingVisitor,System.Int32,System.Int32)" -->
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.walkInOptimizedOrder(Syn.Speech.Helper.Mathematics.Linear.RealVectorPreservingVisitor)">
             Visits (but does not alter) all entries of this vector in optimized
             order. The order in which the entries are visited is selected so as to
             lead to the most efficient implementation; it might depend on the
             concrete implementation of this abstract class.
            
             @param visitor the visitor to be used to process the entries of this
             vector
             @return the value returned by {@link RealVectorPreservingVisitor#end()}
             at the end of the walk
             @since 3.1
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Linear.RealVector.walkInOptimizedOrder(Syn.Speech.Helper.Mathematics.Linear.RealVectorPreservingVisitor,System.Int32,System.Int32)" -->
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.walkInDefaultOrder(Syn.Speech.Helper.Mathematics.Linear.RealVectorChangingVisitor)">
             Visits (and possibly alters) all entries of this vector in default order
             (increasing index).
            
             @param visitor the visitor to be used to process and modify the entries
             of this vector
             @return the value returned by {@link RealVectorChangingVisitor#end()}
             at the end of the walk
             @since 3.1
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Linear.RealVector.walkInDefaultOrder(Syn.Speech.Helper.Mathematics.Linear.RealVectorChangingVisitor,System.Int32,System.Int32)" -->
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.walkInOptimizedOrder(Syn.Speech.Helper.Mathematics.Linear.RealVectorChangingVisitor)">
             Visits (and possibly alters) all entries of this vector in optimized
             order. The order in which the entries are visited is selected so as to
             lead to the most efficient implementation; it might depend on the
             concrete implementation of this abstract class.
            
             @param visitor the visitor to be used to process the entries of this
             vector
             @return the value returned by {@link RealVectorChangingVisitor#end()}
             at the end of the walk
             @since 3.1
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Linear.RealVector.walkInOptimizedOrder(Syn.Speech.Helper.Mathematics.Linear.RealVectorChangingVisitor,System.Int32,System.Int32)" -->
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.Equals(System.Object)">
             <p>
             Test for the equality of two real vectors. If all coordinates of two real
             vectors are exactly the same, and none are {@code NaN}, the two real
             vectors are considered to be equal. {@code NaN} coordinates are
             considered to affect globally the vector and be equals to each other -
             i.e, if either (or all) coordinates of the real vector are equal to
             {@code NaN}, the real vector is equal to a vector with all {@code NaN}
             coordinates.
             </p>
             <p>
             This method <em>must</em> be overriden by concrete subclasses of
             {@link RealVector} (the current implementation throws an exception).
             </p>
            
             @param other Object to test for equality.
             @return {@code true} if two vector objects are equal, {@code false} if
             {@code other} is null, not an instance of {@code RealVector}, or
             not equal to this {@code RealVector} instance.
             @throws MathUnsupportedOperationException if this method is not
             overridden.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVector.GetHashCode">
             {@inheritDoc}. This method <em>must</em> be overriden by concrete
             subclasses of {@link RealVector} (current implementation throws an
             exception).
            
             @throws MathUnsupportedOperationException if this method is not
             overridden.
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.Entry.index">
            Index of this entry. 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.Entry.#ctor(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
            Simple constructor. 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.Entry.getValue">
             Get the value of the entry.
            
             @return the value of the entry.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.Entry.setValue(System.Double)">
             Set the value of the entry.
            
             @param value New value for the entry.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.Entry.getIndex">
             Get the index of the entry.
            
             @return the index of the entry.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.Entry.setIndex(System.Int32)">
             Set the index of the entry.
            
             @param index New index for the entry.
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.SparseEntryIterator.dim">
            Dimension of the vector. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.SparseEntryIterator.current">
            Last entry returned by {@link #next()}. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.SparseEntryIterator._next">
            Next entry for {@link #next()} to return. 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.SparseEntryIterator.#ctor(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
            Simple constructor. 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.SparseEntryIterator.advance(Syn.Speech.Helper.Mathematics.Linear.Entry)">
             Advance an entry up to the next nonzero one.
            
             @param e entry to advance.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.SparseEntryIterator.hasNext">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.SparseEntryIterator.next">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.SparseEntryIterator.remove">
             {@inheritDoc}
            
             @throws MathUnsupportedOperationException in all circumstances.
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.CustomIterator.i">
            Current index. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.CustomIterator.e">
            Current entry. 
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Linear.RealVectorChangingVisitor">
             This interface defines a visitor for the entries of a vector. Visitors
             implementing this interface may alter the entries of the vector being
             visited.
            
             @since 3.1
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVectorChangingVisitor.start(System.Int32,System.Int32,System.Int32)">
             Start visiting a vector. This method is called once, before any entry
             of the vector is visited.
            
             @param dimension the size of the vector
             @param start the index of the first entry to be visited
             @param end the index of the last entry to be visited (inclusive)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVectorChangingVisitor.visit(System.Int32,System.Double)">
             Visit one entry of the vector.
            
             @param index the index of the entry being visited
             @param value the value of the entry being visited
             @return the new value of the entry being visited
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVectorChangingVisitor.end">
             End visiting a vector. This method is called once, after all entries of
             the vector have been visited.
            
             @return the value returned by
             {@link RealVector#walkInDefaultOrder(RealVectorChangingVisitor)},
             {@link RealVector#walkInDefaultOrder(RealVectorChangingVisitor, int, int)},
             {@link RealVector#walkInOptimizedOrder(RealVectorChangingVisitor)}
             or
             {@link RealVector#walkInOptimizedOrder(RealVectorChangingVisitor, int, int)}
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Linear.RealVectorPreservingVisitor">
             This interface defines a visitor for the entries of a vector. Visitors
             implementing this interface do not alter the entries of the vector being
             visited.
            
             @since 3.1
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVectorPreservingVisitor.start(System.Int32,System.Int32,System.Int32)">
             Start visiting a vector. This method is called once, before any entry
             of the vector is visited.
            
             @param dimension the size of the vector
             @param start the index of the first entry to be visited
             @param end the index of the last entry to be visited (inclusive)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVectorPreservingVisitor.visit(System.Int32,System.Double)">
             Visit one entry of the vector.
            
             @param index the index of the entry being visited
             @param value the value of the entry being visited
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.RealVectorPreservingVisitor.end">
             End visiting a vector. This method is called once, after all entries of
             the vector have been visited.
            
             @return the value returned by
             {@link RealVector#walkInDefaultOrder(RealVectorPreservingVisitor)},
             {@link RealVector#walkInDefaultOrder(RealVectorPreservingVisitor, int, int)},
             {@link RealVector#walkInOptimizedOrder(RealVectorPreservingVisitor)}
             or
             {@link RealVector#walkInOptimizedOrder(RealVectorPreservingVisitor, int, int)}
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.MAX_ITERATIONS">
            Maximum allowed iterations for convergence of the transformation. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.matrixP">
            P matrix. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.matrixT">
            T matrix. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.cachedP">
            Cached value of P. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.cachedT">
            Cached value of T. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.cachedPt">
            Cached value of PT. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.epsilon">
            Epsilon criteria taken from JAMA code (originally was 2^-52). 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.#ctor(Syn.Speech.Helper.Mathematics.Linear.RealMatrix)">
             Build the transformation to Schur form of a general real matrix.
            
             @param matrix matrix to transform
             @throws NonSquareMatrixException if the matrix is not square
             
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.getP">
             Returns the matrix P of the transform.
             <p>P is an orthogonal matrix, i.e. its inverse is also its transpose.</p>
            
             @return the P matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.getPT">
             Returns the transpose of the matrix P of the transform.
             <p>P is an orthogonal matrix, i.e. its inverse is also its transpose.</p>
            
             @return the transpose of the P matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.getT">
             Returns the quasi-triangular Schur matrix T of the transform.
            
             @return the T matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.transform">
            Transform original matrix to Schur form.
            @throws MaxCountExceededException if the transformation does not converge
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.getNorm">
             Computes the L1 norm of the (quasi-)triangular matrix T.
            
             @return the L1 norm of matrix T
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.findSmallSubDiagonalElement(System.Int32,System.Double)">
             Find the first small sub-diagonal element and returns its index.
            
             @param startIdx the starting index for the search
             @param norm the L1 norm of the matrix
             @return the index of the first small sub-diagonal element
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.computeShift(System.Int32,System.Int32,System.Int32,Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.ShiftInfo)">
             Compute the shift for the current iteration.
            
             @param l the index of the small sub-diagonal element
             @param idx the current eigenvalue index
             @param iteration the current iteration
             @param shift holder for shift information
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.initQRStep(System.Int32,System.Int32,Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.ShiftInfo,System.Double[])">
             Initialize the householder vectors for the QR step.
            
             @param il the index of the small sub-diagonal element
             @param iu the current eigenvalue index
             @param shift shift information holder
             @param hVec the initial houseHolder vector
             @return the start index for the QR step
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.performDoubleQRStep(System.Int32,System.Int32,System.Int32,Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.ShiftInfo,System.Double[])">
             Perform a double QR step involving rows l:idx and columns m:n
            
             @param il the index of the small sub-diagonal element
             @param im the start index for the QR step
             @param iu the current eigenvalue index
             @param shift shift information holder
             @param hVec the initial houseHolder vector
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.ShiftInfo">
            Internal data structure holding the current shift information.
            Contains variable names as present in the original JAMA code.
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.ShiftInfo.x">
            x shift info 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.ShiftInfo.y">
            y shift info 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.ShiftInfo.w">
            w shift info 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.SchurTransformer.ShiftInfo.exShift">
            Indicates an exceptional shift. 
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Linear.SparseRealVector">
            <summary>
            Marker class for RealVectors that require sparse backing storage
            </summary>
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.TriDiagonalTransformer.householderVectors">
            Householder vectors. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.TriDiagonalTransformer.main">
            Main diagonal. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.TriDiagonalTransformer.secondary">
            Secondary diagonal. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.TriDiagonalTransformer.cachedQ">
            Cached value of Q. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.TriDiagonalTransformer.cachedQt">
            Cached value of Qt. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.TriDiagonalTransformer.cachedT">
            Cached value of T. 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.TriDiagonalTransformer.#ctor(Syn.Speech.Helper.Mathematics.Linear.RealMatrix)">
             Build the transformation to tridiagonal shape of a symmetrical matrix.
             <p>The specified matrix is assumed to be symmetrical without any check.
             Only the upper triangular part of the matrix is used.</p>
            
             @param matrix Symmetrical matrix to transform.
             @throws NonSquareMatrixException if the matrix is not square.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.TriDiagonalTransformer.getQ">
            Returns the matrix Q of the transform.
            <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p>
            @return the Q matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.TriDiagonalTransformer.getQT">
            Returns the transpose of the matrix Q of the transform.
            <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p>
            @return the Q matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.TriDiagonalTransformer.getT">
            Returns the tridiagonal matrix T of the transform.
            @return the T matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.TriDiagonalTransformer.getHouseholderVectorsRef">
            Get the Householder vectors of the transform.
            <p>Note that since this class is only intended for internal use,
            it returns directly a reference to its internal arrays, not a copy.</p>
            @return the main diagonal elements of the B matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.TriDiagonalTransformer.getMainDiagonalRef">
            Get the main diagonal elements of the matrix T of the transform.
            <p>Note that since this class is only intended for internal use,
            it returns directly a reference to its internal arrays, not a copy.</p>
            @return the main diagonal elements of the T matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.TriDiagonalTransformer.getSecondaryDiagonalRef">
            Get the secondary diagonal elements of the matrix T of the transform.
            <p>Note that since this class is only intended for internal use,
            it returns directly a reference to its internal arrays, not a copy.</p>
            @return the secondary diagonal elements of the T matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.TriDiagonalTransformer.transform">
            Transform original matrix to tridiagonal form.
            <p>Transformation is done using Householder transforms.</p>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Helper.Mathematics.Stat.Correlation.Covariance" -->
        <member name="F:Syn.Speech.Helper.Mathematics.Stat.Correlation.Covariance.covarianceMatrix">
            covariance matrix 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Stat.Correlation.Covariance.n">
            Create an empty covariance matrix.
            Number of observations (length of covariate vectors) 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Correlation.Covariance.#ctor">
            Create a Covariance with no data
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Correlation.Covariance.#ctor(System.Double[][],System.Boolean)">
             Create a Covariance matrix from a rectangular array
             whose columns represent covariates.
            
             <p>The <code>biasCorrected</code> parameter determines whether or not
             covariance estimates are bias-corrected.</p>
            
             <p>The input array must be rectangular with at least one column
             and two rows.</p>
            
             @param data rectangular array with columns representing covariates
             @param biasCorrected true means covariances are bias-corrected
             @throws MathIllegalArgumentException if the input data array is not
             rectangular with at least two rows and one column.
             @throws NotStrictlyPositiveException if the input data array is not
             rectangular with at least one row and one column.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Correlation.Covariance.#ctor(System.Double[][])">
             Create a Covariance matrix from a rectangular array
             whose columns represent covariates.
            
             <p>The input array must be rectangular with at least one column
             and two rows</p>
            
             @param data rectangular array with columns representing covariates
             @throws MathIllegalArgumentException if the input data array is not
             rectangular with at least two rows and one column.
             @throws NotStrictlyPositiveException if the input data array is not
             rectangular with at least one row and one column.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Correlation.Covariance.#ctor(Syn.Speech.Helper.Mathematics.Linear.RealMatrix,System.Boolean)">
             Create a covariance matrix from a matrix whose columns
             represent covariates.
            
             <p>The <code>biasCorrected</code> parameter determines whether or not
             covariance estimates are bias-corrected.</p>
            
             <p>The matrix must have at least one column and two rows</p>
            
             @param matrix matrix with columns representing covariates
             @param biasCorrected true means covariances are bias-corrected
             @throws MathIllegalArgumentException if the input matrix does not have
             at least two rows and one column
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Correlation.Covariance.#ctor(Syn.Speech.Helper.Mathematics.Linear.RealMatrix)">
             Create a covariance matrix from a matrix whose columns
             represent covariates.
            
             <p>The matrix must have at least one column and two rows</p>
            
             @param matrix matrix with columns representing covariates
             @throws MathIllegalArgumentException if the input matrix does not have
             at least two rows and one column
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Correlation.Covariance.getCovarianceMatrix">
             Returns the covariance matrix
            
             @return covariance matrix
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Correlation.Covariance.getN">
             Returns the number of observations (length of covariate vectors)
            
             @return number of observations
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Correlation.Covariance.computeCovarianceMatrix(Syn.Speech.Helper.Mathematics.Linear.RealMatrix,System.Boolean)">
            Compute a covariance matrix from a matrix whose columns represent
            covariates.
            @param matrix input matrix (must have at least one column and two rows)
            @param biasCorrected determines whether or not covariance estimates are bias-corrected
            @return covariance matrix
            @throws MathIllegalArgumentException if the matrix does not contain sufficient data
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Correlation.Covariance.computeCovarianceMatrix(Syn.Speech.Helper.Mathematics.Linear.RealMatrix)">
            Create a covariance matrix from a matrix whose columns represent
            covariates. Covariances are computed using the bias-corrected formula.
            @param matrix input matrix (must have at least one column and two rows)
            @return covariance matrix
            @throws MathIllegalArgumentException if matrix does not contain sufficient data
            @see #Covariance
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Correlation.Covariance.computeCovarianceMatrix(System.Double[][],System.Boolean)">
            Compute a covariance matrix from a rectangular array whose columns represent
            covariates.
            @param data input array (must have at least one column and two rows)
            @param biasCorrected determines whether or not covariance estimates are bias-corrected
            @return covariance matrix
            @throws MathIllegalArgumentException if the data array does not contain sufficient
            data
            @throws NotStrictlyPositiveException if the input data array is not
            rectangular with at least one row and one column.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Correlation.Covariance.computeCovarianceMatrix(System.Double[][])">
            Create a covariance matrix from a rectangular array whose columns represent
            covariates. Covariances are computed using the bias-corrected formula.
            @param data input array (must have at least one column and two rows)
            @return covariance matrix
            @throws MathIllegalArgumentException if the data array does not contain sufficient data
            @throws NotStrictlyPositiveException if the input data array is not
            rectangular with at least one row and one column.
            @see #Covariance
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Correlation.Covariance.covariance(System.Double[],System.Double[],System.Boolean)">
             Computes the covariance between the two arrays.
            
             <p>Array lengths must match and the common length must be at least 2.</p>
            
             @param xArray first data array
             @param yArray second data array
             @param biasCorrected if true, returned value will be bias-corrected
             @return returns the covariance for the two arrays
             @throws  MathIllegalArgumentException if the arrays lengths do not match or
             there is insufficient data
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Correlation.Covariance.covariance(System.Double[],System.Double[])">
             Computes the covariance between the two arrays, using the bias-corrected
             formula.
            
             <p>Array lengths must match and the common length must be at least 2.</p>
            
             @param xArray first data array
             @param yArray second data array
             @return returns the covariance for the two arrays
             @throws  MathIllegalArgumentException if the arrays lengths do not match or
             there is insufficient data
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Correlation.Covariance.checkSufficientData(Syn.Speech.Helper.Mathematics.Linear.RealMatrix)">
            Throws MathIllegalArgumentException if the matrix does not have at least
            one column and two rows.
            @param matrix matrix to check
            @throws MathIllegalArgumentException if the matrix does not contain sufficient data
            to compute covariance
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Stat.Descriptive.AbstractStorelessUnivariateStatistic">
            
             Abstract implementation of the {@link StorelessUnivariateStatistic} interface.
             <p>
             Provides default <code>evaluate()</code> and <code>incrementAll(double[])</code>
             implementations.</p>
             <p>
             <strong>Note that these implementations are not synchronized.</strong></p>
            
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Stat.Descriptive.UnivariateStatistic">
             Base interface implemented by all statistics.
            
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.UnivariateStatistic.evaluate(System.Double[])">
             Returns the result of evaluating the statistic over the input array.
            
             @param values input array
             @return the value of the statistic applied to the input array
             @throws MathIllegalArgumentException  if values is null
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.UnivariateStatistic.evaluate(System.Double[],System.Int32,System.Int32)">
             Returns the result of evaluating the statistic over the specified entries
             in the input array.
            
             @param values the input array
             @param begin the index of the first element to include
             @param length the number of elements to include
             @return the value of the statistic applied to the included array entries
             @throws MathIllegalArgumentException if values is null or the indices are invalid
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.UnivariateStatistic.copy">
             Returns a copy of the statistic with the same internal state.
            
             @return a copy of the statistic
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Stat.Descriptive.StorelessUnivariateStatistic">
             Extends the definition of {@link UnivariateStatistic} with
             {@link #increment} and {@link #incrementAll(double[])} methods for adding
             values and updating internal state.
             <p>
             This interface is designed to be used for calculating statistics that can be
             computed in one pass through the data without storing the full array of
             sample values.</p>
            
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.StorelessUnivariateStatistic.increment(System.Double)">
            Updates the internal state of the statistic to reflect the addition of the new value.
            @param d  the new value.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.StorelessUnivariateStatistic.incrementAll(System.Double[])">
             Updates the internal state of the statistic to reflect addition of
             all values in the values array.  Does not clear the statistic first --
             i.e., the values are added <strong>incrementally</strong> to the dataset.
            
             @param values  array holding the new values to add
             @throws MathIllegalArgumentException if the array is null
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.StorelessUnivariateStatistic.incrementAll(System.Double[],System.Int32,System.Int32)">
             Updates the internal state of the statistic to reflect addition of
             the values in the designated portion of the values array.  Does not
             clear the statistic first -- i.e., the values are added
             <strong>incrementally</strong> to the dataset.
            
             @param values  array holding the new values to add
             @param start  the array index of the first value to add
             @param length  the number of elements to add
             @throws MathIllegalArgumentException if the array is null or the index
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.StorelessUnivariateStatistic.getResult">
            Returns the current value of the Statistic.
            @return value of the statistic, <code>Double.NaN</code> if it
            has been cleared or just instantiated.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.StorelessUnivariateStatistic.getN">
            Returns the number of values that have been added.
            @return the number of values.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.StorelessUnivariateStatistic.clear">
            Clears the internal state of the Statistic
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.StorelessUnivariateStatistic.copy">
             Returns a copy of the statistic with the same internal state.
            
             @return a copy of the statistic
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.AbstractStorelessUnivariateStatistic.evaluate(System.Double[])">
            This default implementation calls {@link #clear}, then invokes
            {@link #increment} in a loop over the the input array, and then uses
            {@link #getResult} to compute the return value.
            <p>
            Note that this implementation changes the internal state of the
            statistic.  Its side effects are the same as invoking {@link #clear} and
            then {@link #incrementAll(double[])}.</p>
            <p>
            Implementations may override this method with a more efficient and
            possibly more accurate implementation that works directly with the
            input array.</p>
            <p>
            If the array is null, a MathIllegalArgumentException is thrown.</p>
            @param values input array
            @return the value of the statistic applied to the input array
            @throws MathIllegalArgumentException if values is null
            @see org.apache.commons.math3.stat.descriptive.UnivariateStatistic#evaluate(double[])
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.AbstractStorelessUnivariateStatistic.evaluate(System.Double[],System.Int32,System.Int32)">
            This default implementation calls {@link #clear}, then invokes
            {@link #increment} in a loop over the specified portion of the input
            array, and then uses {@link #getResult} to compute the return value.
            <p>
            Note that this implementation changes the internal state of the
            statistic.  Its side effects are the same as invoking {@link #clear} and
            then {@link #incrementAll(double[], int, int)}.</p>
            <p>
            Implementations may override this method with a more efficient and
            possibly more accurate implementation that works directly with the
            input array.</p>
            <p>
            If the array is null or the index parameters are not valid, an
            MathIllegalArgumentException is thrown.</p>
            @param values the input array
            @param begin the index of the first element to include
            @param length the number of elements to include
            @return the value of the statistic applied to the included array entries
            @throws MathIllegalArgumentException if the array is null or the indices are not valid
            @see org.apache.commons.math3.stat.descriptive.UnivariateStatistic#evaluate(double[], int, int)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.AbstractStorelessUnivariateStatistic.getN">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.AbstractStorelessUnivariateStatistic.getResult">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.AbstractStorelessUnivariateStatistic.increment(System.Double)">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.AbstractStorelessUnivariateStatistic.incrementAll(System.Double[])">
             This default implementation just calls {@link #increment} in a loop over
             the input array.
             <p>
             Throws IllegalArgumentException if the input values array is null.</p>
            
             @param values values to add
             @throws MathIllegalArgumentException if values is null
             @see org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic#incrementAll(double[])
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.AbstractStorelessUnivariateStatistic.incrementAll(System.Double[],System.Int32,System.Int32)">
             This default implementation just calls {@link #increment} in a loop over
             the specified portion of the input array.
             <p>
             Throws IllegalArgumentException if the input values array is null.</p>
            
             @param values  array holding values to add
             @param begin   index of the first array element to add
             @param length  number of array elements to add
             @throws MathIllegalArgumentException if values is null
             @see org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic#incrementAll(double[], int, int)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.AbstractStorelessUnivariateStatistic.equals(System.Object)">
            Returns true iff <code>object</code> is an
            <code>AbstractStorelessUnivariateStatistic</code> returning the same
            values as this for <code>getResult()</code> and <code>getN()</code>
            @param object object to test equality against.
            @return true if object returns the same value as this
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.AbstractStorelessUnivariateStatistic.hashCode">
             Returns hash code based on getResult() and getN()
            
             @return hash code
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.FirstMoment.n">
            Count of values that have been added 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.FirstMoment.m1">
            First moment of values that have been added 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.FirstMoment.dev">
            Deviation of most recently added value from previous first moment.
            Retained to prevent repeated computation in higher order moments.
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.FirstMoment.nDev">
            Deviation of most recently added value from previous first moment,
            normalized by previous sample size.  Retained to prevent repeated
            computation in higher order moments
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.FirstMoment.#ctor">
            Create a FirstMoment instance
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.FirstMoment.#ctor(Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.FirstMoment)">
             Copy constructor, creates a new {@code FirstMoment} identical
             to the {@code original}
            
             @param original the {@code FirstMoment} instance to copy
             @throws NullArgumentException if original is null
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.FirstMoment.increment(System.Double)">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.FirstMoment.clear">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.FirstMoment.getResult">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.FirstMoment.getN">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.FirstMoment.copy(Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.FirstMoment,Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.FirstMoment)">
             Copies source to dest.
             <p>Neither source nor dest can be null.</p>
            
             @param source FirstMoment to copy
             @param dest FirstMoment to copy to
             @throws NullArgumentException if either source or dest is null
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.WeightedEvaluation.evaluate(System.Double[],System.Double[])">
             Returns the result of evaluating the statistic over the input array,
             using the supplied weights.
            
             @param values input array
             @param weights array of weights
             @return the value of the weighted statistic applied to the input array
             @throws MathIllegalArgumentException if either array is null, lengths
             do not match, weights contain NaN, negative or infinite values, or
             weights does not include at least on positive value
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.WeightedEvaluation.evaluate(System.Double[],System.Double[],System.Int32,System.Int32)">
             Returns the result of evaluating the statistic over the specified entries
             in the input array, using corresponding entries in the supplied weights array.
            
             @param values the input array
             @param weights array of weights
             @param begin the index of the first element to include
             @param length the number of elements to include
             @return the value of the weighted statistic applied to the included array entries
             @throws MathIllegalArgumentException if either array is null, lengths
             do not match, indices are invalid, weights contain NaN, negative or
             infinite values, or weights does not include at least on positive value
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Mean.moment">
            First moment on which this statistic is based. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Mean.incMoment">
            Determines whether or not this statistic can be incremented or cleared.
            <p>
            Statistics based on (constructed from) external moments cannot
            be incremented or cleared.</p>
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Mean.#ctor">
            Constructs a Mean. 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Mean.#ctor(Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.FirstMoment)">
             Constructs a Mean with an External Moment.
            
             @param m1 the moment
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Mean.#ctor(Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Mean)">
             Copy constructor, creates a new {@code Mean} identical
             to the {@code original}
            
             @param original the {@code Mean} instance to copy
             @throws NullArgumentException if original is null
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Mean.increment(System.Double)">
            {@inheritDoc}
            <p>Note that when {@link #Mean(FirstMoment)} is used to
            create a Mean, this method does nothing. In that case, the
            FirstMoment should be incremented directly.</p>
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Mean.clear">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Mean.getResult">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Mean.getN">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Mean.evaluate(System.Double[],System.Int32,System.Int32)">
             Returns the arithmetic mean of the entries in the specified portion of
             the input array, or <code>Double.NaN</code> if the designated subarray
             is empty.
             <p>
             Throws <code>IllegalArgumentException</code> if the array is null.</p>
             <p>
             See {@link Mean} for details on the computing algorithm.</p>
            
             @param values the input array
             @param begin index of the first array element to include
             @param length the number of elements to include
             @return the mean of the values or Double.NaN if length = 0
             @throws MathIllegalArgumentException if the array is null or the array index
              parameters are not valid
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Mean.evaluate(System.Double[],System.Double[],System.Int32,System.Int32)">
             Returns the weighted arithmetic mean of the entries in the specified portion of
             the input array, or <code>Double.NaN</code> if the designated subarray
             is empty.
             <p>
             Throws <code>IllegalArgumentException</code> if either array is null.</p>
             <p>
             See {@link Mean} for details on the computing algorithm. The two-pass algorithm
             described above is used here, with weights applied in computing both the original
             estimate and the correction factor.</p>
             <p>
             Throws <code>IllegalArgumentException</code> if any of the following are true:
             <ul><li>the values array is null</li>
                 <li>the weights array is null</li>
                 <li>the weights array does not have the same length as the values array</li>
                 <li>the weights array contains one or more infinite values</li>
                 <li>the weights array contains one or more NaN values</li>
                 <li>the weights array contains negative values</li>
                 <li>the start and length arguments do not determine a valid array</li>
             </ul></p>
            
             @param values the input array
             @param weights the weights array
             @param begin index of the first array element to include
             @param length the number of elements to include
             @return the mean of the values or Double.NaN if length = 0
             @throws MathIllegalArgumentException if the parameters are not valid
             @since 2.1
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Mean.evaluate(System.Double[],System.Double[])">
             Returns the weighted arithmetic mean of the entries in the input array.
             <p>
             Throws <code>MathIllegalArgumentException</code> if either array is null.</p>
             <p>
             See {@link Mean} for details on the computing algorithm. The two-pass algorithm
             described above is used here, with weights applied in computing both the original
             estimate and the correction factor.</p>
             <p>
             Throws <code>MathIllegalArgumentException</code> if any of the following are true:
             <ul><li>the values array is null</li>
                 <li>the weights array is null</li>
                 <li>the weights array does not have the same length as the values array</li>
                 <li>the weights array contains one or more infinite values</li>
                 <li>the weights array contains one or more NaN values</li>
                 <li>the weights array contains negative values</li>
             </ul></p>
            
             @param values the input array
             @param weights the weights array
             @return the mean of the values or Double.NaN if length = 0
             @throws MathIllegalArgumentException if the parameters are not valid
             @since 2.1
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Mean.copy">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Mean.copy(Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Mean,Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Mean)">
             Copies source to dest.
             <p>Neither source nor dest can be null.</p>
            
             @param source Mean to copy
             @param dest Mean to copy to
             @throws NullArgumentException if either source or dest is null
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.SecondMoment.serialVersionUID">
            Serializable version identifier 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.SecondMoment.m2">
            second moment of values that have been added 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.SecondMoment.#ctor">
            Create a SecondMoment instance
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.SecondMoment.#ctor(Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.SecondMoment)">
             Copy constructor, creates a new {@code SecondMoment} identical
             to the {@code original}
            
             @param original the {@code SecondMoment} instance to copy
             @throws NullArgumentException if original is null
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.SecondMoment.increment(System.Double)">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.SecondMoment.clear">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.SecondMoment.getResult">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.SecondMoment.copy">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.SecondMoment.copy(Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.SecondMoment,Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.SecondMoment)">
             Copies source to dest.
             <p>Neither source nor dest can be null.</p>
            
             @param source SecondMoment to copy
             @param dest SecondMoment to copy to
             @throws NullArgumentException if either source or dest is null
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance">
            <summary>
            Computes the variance of the available values.
            </summary>
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.moment">
            SecondMoment is used in incremental calculation of Variance
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.incMoment">
            Whether or not {@link #increment(double)} should increment
            the internal second moment. When a Variance is constructed with an
            external SecondMoment as a constructor parameter, this property is
            set to false and increments must be applied to the second moment
            directly.
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance._isBiasCorrected">
            Whether or not bias correction is applied when computing the
            value of the statistic. True means that bias is corrected.  See
            {@link Variance} for details on the formula.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.#ctor">
            Constructs a Variance with default (true) <code>isBiasCorrected</code>
            property.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.#ctor(Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.SecondMoment)">
             Constructs a Variance based on an external second moment.
             When this constructor is used, the statistic may only be
             incremented via the moment, i.e., {@link #increment(double)}
             does nothing; whereas {@code m2.increment(value)} increments
             both {@code m2} and the Variance instance constructed from it.
            
             @param m2 the SecondMoment (Third or Fourth moments work
             here as well.)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.#ctor(System.Boolean)">
             Constructs a Variance with the specified <code>isBiasCorrected</code>
             property
            
             @param isBiasCorrected  setting for bias correction - true means
             bias will be corrected and is equivalent to using the argumentless
             constructor
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.#ctor(System.Boolean,Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.SecondMoment)">
             Constructs a Variance with the specified <code>isBiasCorrected</code>
             property and the supplied external second moment.
            
             @param isBiasCorrected  setting for bias correction - true means
             bias will be corrected
             @param m2 the SecondMoment (Third or Fourth moments work
             here as well.)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.#ctor(Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance)">
             Copy constructor, creates a new {@code Variance} identical
             to the {@code original}
            
             @param original the {@code Variance} instance to copy
             @throws NullArgumentException if original is null
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.increment(System.Double)">
             {@inheritDoc}
             <p>If all values are available, it is more accurate to use
             {@link #evaluate(double[])} rather than adding values one at a time
             using this method and then executing {@link #getResult}, since
             <code>evaluate</code> leverages the fact that is has the full
             list of values together to execute a two-pass algorithm.
             See {@link Variance}.</p>
            
             <p>Note also that when {@link #Variance(SecondMoment)} is used to
             create a Variance, this method does nothing. In that case, the
             SecondMoment should be incremented directly.</p>
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.getN">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.clear">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.evaluate(System.Double[])">
             Returns the variance of the entries in the input array, or
             <code>Double.NaN</code> if the array is empty.
             <p>
             See {@link Variance} for details on the computing algorithm.</p>
             <p>
             Returns 0 for a single-value (i.e. length = 1) sample.</p>
             <p>
             Throws <code>MathIllegalArgumentException</code> if the array is null.</p>
             <p>
             Does not change the internal state of the statistic.</p>
            
             @param values the input array
             @return the variance of the values or Double.NaN if length = 0
             @throws MathIllegalArgumentException if the array is null
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.evaluate(System.Double[],System.Int32,System.Int32)">
             Returns the variance of the entries in the specified portion of
             the input array, or <code>Double.NaN</code> if the designated subarray
             is empty.  Note that Double.NaN may also be returned if the input
             includes NaN and / or infinite values.
             <p>
             See {@link Variance} for details on the computing algorithm.</p>
             <p>
             Returns 0 for a single-value (i.e. length = 1) sample.</p>
             <p>
             Does not change the internal state of the statistic.</p>
             <p>
             Throws <code>MathIllegalArgumentException</code> if the array is null.</p>
            
             @param values the input array
             @param begin index of the first array element to include
             @param length the number of elements to include
             @return the variance of the values or Double.NaN if length = 0
             @throws MathIllegalArgumentException if the array is null or the array index
              parameters are not valid
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.evaluate(System.Double[],System.Double[],System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.evaluate(System.Double[],System.Double[])" -->
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.evaluate(System.Double[],System.Double,System.Int32,System.Int32)">
             Returns the variance of the entries in the specified portion of
             the input array, using the precomputed mean value.  Returns
             <code>Double.NaN</code> if the designated subarray is empty.
             <p>
             See {@link Variance} for details on the computing algorithm.</p>
             <p>
             The formula used assumes that the supplied mean value is the arithmetic
             mean of the sample data, not a known population parameter.  This method
             is supplied only to save computation when the mean has already been
             computed.</p>
             <p>
             Returns 0 for a single-value (i.e. length = 1) sample.</p>
             <p>
             Throws <code>MathIllegalArgumentException</code> if the array is null.</p>
             <p>
             Does not change the internal state of the statistic.</p>
            
             @param values the input array
             @param mean the precomputed mean value
             @param begin index of the first array element to include
             @param length the number of elements to include
             @return the variance of the values or Double.NaN if length = 0
             @throws MathIllegalArgumentException if the array is null or the array index
              parameters are not valid
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.evaluate(System.Double[],System.Double)">
             Returns the variance of the entries in the input array, using the
             precomputed mean value.  Returns <code>Double.NaN</code> if the array
             is empty.
             <p>
             See {@link Variance} for details on the computing algorithm.</p>
             <p>
             If <code>isBiasCorrected</code> is <code>true</code> the formula used
             assumes that the supplied mean value is the arithmetic mean of the
             sample data, not a known population parameter.  If the mean is a known
             population parameter, or if the "population" version of the variance is
             desired, set <code>isBiasCorrected</code> to <code>false</code> before
             invoking this method.</p>
             <p>
             Returns 0 for a single-value (i.e. length = 1) sample.</p>
             <p>
             Throws <code>MathIllegalArgumentException</code> if the array is null.</p>
             <p>
             Does not change the internal state of the statistic.</p>
            
             @param values the input array
             @param mean the precomputed mean value
             @return the variance of the values or Double.NaN if the array is empty
             @throws MathIllegalArgumentException if the array is null
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.evaluate(System.Double[],System.Double[],System.Double,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.evaluate(System.Double[],System.Double[],System.Double)" -->
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.isBiasCorrected">
            @return Returns the isBiasCorrected.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.setBiasCorrected(System.Boolean)">
            @param biasCorrected The isBiasCorrected to set.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.copy">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance.copy(Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance,Syn.Speech.Helper.Mathematics.Stat.Descriptive.Moment.Variance)">
             Copies source to dest.
             <p>Neither source nor dest can be null.</p>
            
             @param source Variance to copy
             @param dest Variance to copy to
             @throws NullArgumentException if either source or dest is null
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Summary.Sum">
              * Returns the sum of the available values.
             * <p>
             * If there are no values in the dataset, then 0 is returned.
             * If any of the values are
             * <code>NaN</code>, then <code>NaN</code> is returned.</p>
             * <p>
             * <strong>Note that this implementation is not synchronized.</strong> If
             * multiple threads access an instance of this class concurrently, and at least
             * one of the threads invokes the <code>increment()</code> or
             * <code>clear()</code> method, it must be synchronized externally.</p>
             *
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Summary.Sum.n">
            
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Summary.Sum.value">
            The currently running sum.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Summary.Sum.#ctor">
            Create a Sum instance
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Summary.Sum.#ctor(Syn.Speech.Helper.Mathematics.Stat.Descriptive.Summary.Sum)">
             Copy constructor, creates a new {@code Sum} identical
             to the {@code original}
            
             @param original the {@code Sum} instance to copy
             @throws NullArgumentException if original is null
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Summary.Sum.increment(System.Double)">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Summary.Sum.getResult">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Summary.Sum.getN">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Summary.Sum.clear">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Summary.Sum.evaluate(System.Double[],System.Int32,System.Int32)">
             The sum of the entries in the specified portion of
             the input array, or 0 if the designated subarray
             is empty.
             <p>
             Throws <code>MathIllegalArgumentException</code> if the array is null.</p>
            
             @param values the input array
             @param begin index of the first array element to include
             @param length the number of elements to include
             @return the sum of the values or 0 if length = 0
             @throws MathIllegalArgumentException if the array is null or the array index
              parameters are not valid
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Summary.Sum.evaluate(System.Double[],System.Double[],System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Summary.Sum.evaluate(System.Double[],System.Double[])" -->
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Summary.Sum.copy">
            {@inheritDoc}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Stat.Descriptive.Summary.Sum.copy(Syn.Speech.Helper.Mathematics.Stat.Descriptive.Summary.Sum,Syn.Speech.Helper.Mathematics.Stat.Descriptive.Summary.Sum)">
             Copies source to dest.
             <p>Neither source nor dest can be null.</p>
            
             @param source Sum to copy
             @param dest Sum to copy to
             @throws NullArgumentException if either source or dest is null
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.FREE">
            Status indicator for free table entries. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.FULL">
            Status indicator for full table entries. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.REMOVED">
            Status indicator for removed table entries. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.LOAD_FACTOR">
            Load factor for the map. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.DEFAULT_EXPECTED_SIZE">
            Default starting size.
            <p>This must be a power of two for bit mask to work properly. </p>
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.RESIZE_MULTIPLIER">
            Multiplier for size growth when map fills up.
            <p>This must be a power of two for bit mask to work properly. </p>
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.PERTURB_SHIFT">
            Number of bits to perturb the index when probing for collision resolution. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.keys">
            Keys table. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.values">
            Values table. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.states">
            States table. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.missingEntries">
            Return value for missing entries. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap._size">
            Current size of the map. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.mask">
            Bit mask for hash values. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.count">
            Modifications count. 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.#ctor">
            Build an empty map with default size and using NaN for missing entries.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.#ctor(System.Double)">
            Build an empty map with default size
            @param missingEntries value to return when a missing entry is fetched
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.#ctor(System.Int32)">
            Build an empty map with specified size and using NaN for missing entries.
            @param expectedSize expected number of elements in the map
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.#ctor(System.Int32,System.Double)">
            Build an empty map with specified size.
            @param expectedSize expected number of elements in the map
            @param missingEntries value to return when a missing entry is fetched
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.#ctor(Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap)">
            Copy constructor.
            @param source map to copy
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.computeCapacity(System.Int32)">
            Compute the capacity needed for a given size.
            @param expectedSize expected size of the map
            @return capacity to use for the specified size
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.nextPowerOfTwo(System.Int32)">
            Find the smallest power of two greater than the input value
            @param i input value
            @return smallest power of two greater than the input value
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.get(System.Int32)">
            Get the stored value associated with the given key
            @param key key associated with the data
            @return data associated with the key
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.containsKey(System.Int32)">
            Check if a value is associated with a key.
            @param key key to check
            @return true if a value is associated with key
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.iterator">
            Get an iterator over map elements.
            <p>The specialized iterators returned are fail-fast: they throw a
            <code>ConcurrentModificationException</code> when they detect the map
            has been modified during iteration.</p>
            @return iterator over the map elements
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.perturb(System.Int32)">
            Perturb the hash for starting probing.
            @param hash initial hash
            @return perturbed hash
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.findInsertionIndex(System.Int32)">
            Find the index at which a key should be inserted
            @param key key to lookup
            @return index at which key should be inserted
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.findInsertionIndex(System.Int32[],System.Byte[],System.Int32,System.Int32)">
            Find the index at which a key should be inserted
            @param keys keys table
            @param states states table
            @param key key to lookup
            @param mask bit mask for hash values
            @return index at which key should be inserted
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.probe(System.Int32,System.Int32)">
            Compute next probe for collision resolution
            @param perturb perturbed hash
            @param j previous probe
            @return next probe
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.changeIndexSign(System.Int32)">
            Change the index sign
            @param index initial index
            @return changed index
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.size">
            Get the number of elements stored in the map.
            @return number of elements stored in the map
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.remove(System.Int32)">
            Remove the value associated with a key.
            @param key key to which the value is associated
            @return removed value
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.containsKey(System.Int32,System.Int32)">
            Check if the tables contain an element associated with specified key
            at specified index.
            @param key key to check
            @param index index to check
            @return true if an element is associated with key at index
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.doRemove(System.Int32)">
            Remove an element at specified index.
            @param index index of the element to remove
            @return removed value
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.put(System.Int32,System.Double)">
            Put a value associated with a key in the map.
            @param key key to which value is associated
            @param value value to put in the map
            @return previous value associated with the key
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.growTable">
            Grow the tables.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.shouldGrowTable">
            Check if tables should grow due to increased size.
            @return true if  tables should grow
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.hashOf(System.Int32)">
            Compute the hash value of a key
            @param key key to hash
            @return hash value of the key
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            Read a serialized object.
            @param stream input stream
            @throws IOException if object cannot be read
            @throws ClassNotFoundException if the class corresponding
            to the serialized object cannot be found
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.Iterator">
            Iterator class for the map. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.Iterator.referenceCount">
            Reference modification count. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.Iterator.current">
            Index of current element. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.Iterator.next">
            Index of next element. 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.Iterator.#ctor">
            Simple constructor.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.Iterator.hasNext">
            Check if there is a next element in the map.
            @return true if there is a next element
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.Iterator.key">
            Get the key of current entry.
            @return key of current entry
            @exception ConcurrentModificationException if the map is modified during iteration
            @exception NoSuchElementException if there is no element left in the map
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.Iterator.value">
            Get the value of current entry.
            @return value of current entry
            @exception ConcurrentModificationException if the map is modified during iteration
            @exception NoSuchElementException if there is no element left in the map
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.OpenIntToDoubleHashMap.Iterator.advance">
            Advance iterator one step further.
            @exception ConcurrentModificationException if the map is modified during iteration
            @exception NoSuchElementException if there is no element left in the map
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.Precision.equalsWithRelativeTolerance(System.Double,System.Double,System.Double)">
             Returns true if both arguments are NaN or neither is NaN and they are
             equal as defined by {@link #equals(float,float) equals(x, y, 1)}.
            
             @param x first value
             @param y second value
             @return {@code true} if the values are equal or both are NaN.
             @since 2.2
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Util.Precision.equals(System.Single,System.Single,System.Single)">
             Returns true if both arguments are equal or within the range of allowed
             error (inclusive).
            
             @param x first value
             @param y second value
             @param eps the amount of absolute error to allow.
             @return {@code true} if the values are equal or within range of each other.
             @since 2.2
        </member>
        <member name="T:Syn.Speech.Instrumentation.BestPathAccuracyTracker">
            <summary>
            Tracks and reports recognition accuracy based upon the highest scoring path in a Result.
            </summary>
        </member>
        <member name="T:Syn.Speech.Instrumentation.AccuracyTracker">
            <summary>
            Tracks and reports recognition accuracy
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.IResultListener.NewResult(Syn.Speech.Results.Result)">
            <summary>
             Method called when a new result is generated
            </summary>
            <param name="result">The new result.</param>
        </member>
        <member name="T:Syn.Speech.Instrumentation.IResetable">
            <summary>
            Defines the interface for an object that is resetable
            </summary>
        </member>
        <member name="M:Syn.Speech.Instrumentation.IResetable.Reset">
            <summary>
            Resets this component. Typically this is for components that keep track of statistics
            </summary>
        </member>
        <member name="M:Syn.Speech.Recognizers.IStateListener.StatusChanged(Syn.Speech.Recognizers.Recognizer.State)">
            <summary>
            Called when the status has changed.
            </summary>
            <param name="status">status the new status</param>
        </member>
        <member name="T:Syn.Speech.Instrumentation.IMonitor">
            <summary>
            Common empty interface for Configurable monitors
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.AccuracyTracker.PropRecognizer">
            <summary>
            The property that defines which recognizer to monitor
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.AccuracyTracker.PropShowSummary">
            <summary>
            The property that defines whether summary accuracy information is displayed
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.AccuracyTracker.PropShowDetails">
            <summary>
            The property that defines whether detailed accuracy information is displayed
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.AccuracyTracker.PropShowResults">
            <summary>
            The property that defines whether recognition results should be displayed.
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.AccuracyTracker.PropShowAlignedResults">
            <summary>
            The property that defines whether recognition results should be displayed.
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.AccuracyTracker.PropShowRawResults">
            <summary>
            The property that defines whether recognition results should be displayed.
            </summary>
        </member>
        <member name="M:Syn.Speech.Instrumentation.AccuracyTracker.ShowDetails(System.String)">
             Shows the complete details.
            
             @param rawText the RAW result
        </member>
        <member name="P:Syn.Speech.Instrumentation.AccuracyTracker.Aligner">
             Retrieves the aligner used to track the accuracy stats
            
             @return the aligner
        </member>
        <member name="F:Syn.Speech.Instrumentation.BestPathAccuracyTracker.PropShowFullPath">
            The property that define whether the full token path is displayed 
        </member>
        <member name="M:Syn.Speech.Instrumentation.BestPathAccuracyTracker.ShowFullPath(Syn.Speech.Results.Result)">
             Dumps the best path
            
             @param result the result to dump
        </member>
        <member name="T:Syn.Speech.Instrumentation.ConfigMonitor">
            <summary>
            Shows the configuration currently in use. This monitor is typically added as a recognition monitor such that the configuration is shown immediately after the recognizer is allocated.
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.ConfigMonitor.PropShowConfig">
            <summary>
            The property that is used to indicate whether or not this monitor should show the current configuration.
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.ConfigMonitor.PropShowConfigAsHtml">
            <summary>
            The property that is used to indicate whether or not this monitor should dump the configuration in an HTML document
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.ConfigMonitor.PropShowConfigAsGdl">
            <summary>
            The property that is used to indicate whether or not this monitor should dump the configuration in an GDL document
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.ConfigMonitor.PropSaveConfigAsXML">
            <summary>
            The property that is used to indicate whether or not this monitor should save the configuration in an XML document
            </summary>
        </member>
        <member name="T:Syn.Speech.Instrumentation.RecognizerMonitor">
            <summary>
            Monitor the state transitions of a given recognizer. This monitor maintains lists of components that should be 'run' when a recognizer state change is detected.
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.RecognizerMonitor.PropRecognizer">
            <summary>
            The property for the recognizer to monitor
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.RecognizerMonitor.PropAllocatedMonitors">
            <summary>
            The property that defines all of the monitors to call when the recognizer is allocated
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.RecognizerMonitor.PropDeallocatedMonitors">
            <summary>
            The property that defines all of the monitors to call when the recognizer is deallocated
            </summary>
        </member>
        <member name="T:Syn.Speech.Instrumentation.RejectionTracker">
            <summary>
            Tracks and reports rejection accuracy.
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.RejectionTracker.PropRecognizer">
            <summary>
            The property that defines which recognizer to monitor
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.RejectionTracker.PropShowSummary">
            <summary>
            The property that defines whether summary accuracy information is displayed
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.RejectionTracker.PropShowDetails">
            <summary>
            The property that defines whether detailed accuracy information is displayed
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.RejectionTracker._numUtterances">
            <summary>
            total number of utterances
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.RejectionTracker._numOutOfGrammarUtterances">
            <summary>
            actual number of out-of-grammar utterance
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.RejectionTracker._numCorrectOutOfGrammarUtterances">
            <summary>
            number of correctly classified in-grammar utterances
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.RejectionTracker._numFalseOutOfGrammarUtterances">
            <summary>
            number of in-grammar utterances misrecognized as out-of-grammar
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.RejectionTracker._numCorrectInGrammarUtterances">
            <summary>
            number of correctly classified out-of-grammar utterances
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.RejectionTracker._numFalseInGrammarUtterances">
            <summary>
            number of out-of-grammar utterances misrecognized as in-grammar
            </summary>
        </member>
        <member name="T:Syn.Speech.Jsgf.GrammarGraph">
            <summary>
            Represents a graph of grammar nodes. A grammar graph has a single starting node and a single ending node.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.GrammarGraph._parent">
            <summary>
            Nested Class support.
            </summary>
        </member>
        <member name="M:Syn.Speech.Jsgf.GrammarGraph.#ctor(Syn.Speech.Linguist.Language.Grammar.GrammarNode,Syn.Speech.Linguist.Language.Grammar.GrammarNode,Syn.Speech.Jsgf.JSGFGrammar)">
            <summary>
            Creates a grammar graph with the given nodes.
            </summary>
            <param name="startNode">The staring node of the graph.</param>
            <param name="endNode">The ending node of the graph.</param>
            <param name="parent">The parent.</param>
        </member>
        <member name="M:Syn.Speech.Jsgf.GrammarGraph.#ctor(Syn.Speech.Jsgf.JSGFGrammar)">
            <summary>
            Creates a graph with non-word nodes for the start and ending nodes.
            </summary>
        </member>
        <member name="P:Syn.Speech.Jsgf.GrammarGraph.StartNode">
            <summary>
            Gets the starting node
            </summary>
            <value>The starting node for the graph.</value>
        </member>
        <member name="P:Syn.Speech.Jsgf.GrammarGraph.EndNode">
            <summary>
            Gets the ending node.
            </summary>
            <value>The ending node for the graph.</value>
        </member>
        <member name="T:Syn.Speech.Jsgf.GrXMLGrammar">
             Grammar for GrXML W3C Standard
             @author shmyrev
            
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Jsgf.JSGFGrammar" -->
        <member name="T:Syn.Speech.Linguist.Language.Grammar.Grammar">
             <summary>
             Classes that implement this interface create grammars. A grammar is represented internally as a graph of {@link
             GrammarNode GrammarNodes} linked together by {@link GrammarArc GrammarArcs}. Calling {@link #getInitialNode()
             getInitialNode} will return the first node of the grammar graph. To traverse the grammar graph, one should call
             GrammarNode.getSuccessors, which will return an array of GrammarArcs, from which you can reach the neighboring
             GrammarNodes.
            
             Note that all grammar probabilities are maintained in LogMath log domain.
             </summary>
        </member>
        <member name="T:Syn.Speech.Linguist.Language.Grammar.IGrammarInterface">
            <summary>
            
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Language.Grammar.Grammar.PropShowGrammar">
            <summary>
            Property to control the the dumping of the grammar
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Language.Grammar.Grammar.PropOptimizeGrammar">
            <summary>
            The default value for PROP_SHOW_GRAMMAR.
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Language.Grammar.Grammar.PropAddSilWords">
            <summary>
            Property to control whether silence words are inserted into the graph.
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Language.Grammar.Grammar.PropAddFillerWords">
            <summary>
            Property to control whether filler words are inserted into the graph.
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Language.Grammar.Grammar.PropDictionary">
            <summary>
            Property that defines the dictionary to use for this grammar.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.Allocate">
            Create the grammar
                    /// @throws java.io.IOException
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.Deallocate">
            <summary>
            Deallocate resources allocated to this grammar.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.PostProcessGrammar">
            <summary>
                    
            Perform the standard set of grammar post processing. This can include
            inserting silence nodes and optimizing out empty nodes
            
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.DumpStatistics">
            Dumps statistics for this grammar 
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.DumpRandomSentences(System.String,System.Int32)">
                    /// Dump a set of random sentences that fit this grammar
                     *
                    /// @param path  the name of the file to dump the sentences to
                    /// @param count dumps no more than this. May dump less than this depending upon the number of uniqe sentences in the
                    ///              grammar.
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.DumpRandomSentences(System.Int32)">
                    /// Dump a set of random sentences that fit this grammar
                     *
                    /// @param count dumps no more than this. May dump less than this depending upon the number of uniqe sentences in the
                    ///              grammar.
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.GetRandomSentence">
                    /// Returns a random sentence that fits this grammar
                     *
                    /// @return a random sentence that fits this grammar
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.SelectRandomSuccessor(Syn.Speech.Linguist.Language.Grammar.GrammarNode)">
                    /// Given a node, select a random successor from the set of possible successor nodes
                     *
                    /// @param node the node
                    /// @return a random successor node.
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.DumpGrammar(System.String)">
            Dumps the grammar
                    /// @param name
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.NewGrammar">
            Prepare to create a new grammar 
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.CreateGrammar">
                    /// Creates a grammar. Subclasses of grammar should implement this method.
                     *
                    /// @return the initial node for the grammar
                    /// @throws java.io.IOException if the grammar could not be loaded
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.CreateGrammar(System.String)">
                    /// Create class from reference text (not implemented).
                     *
                    /// @param bogusText dummy variable
                    /// @throws NoSuchMethodException if called with reference sentence
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.CreateGrammarNode(System.Int32,System.String[][])">
                    /// Returns a new GrammarNode with the given set of alternatives.
                     *
                    /// @param identity the id for this node
                    /// @param alts     the set of alternative word lists for this GrammarNode
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.CreateGrammarNode(System.String)">
            <summary>
            Returns a new GrammarNode with the given single word. If the word is not in the dictionary, an empty node is
            created. The grammar id is automatically assigned
            </summary>
            <param name="word">the word for this grammar node</param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.CreateGrammarNode(System.Boolean)">
                    /// Creates an empty  grammar node in this grammar. The gramar ID is automatically assigned.
                     *
                    /// @param isFinal if true, this is a final node
                    /// @return the grammar node
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.CreateGrammarNode(System.Int32,System.String)">
            <summary>
            Returns a new GrammarNode with the given single word. If the word is not in the dictionary, an empty node is
            created
            </summary>
            <param name="identity">the id for this node</param>
            <param name="word">the word for this grammar node</param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.CreateGrammarNode(System.Int32,System.Boolean)">
                    /// Creates a grammar node in this grammar with the given identity
                     *
                    /// @param identity the identity of the node
                    /// @param isFinal  if true, this is a final node
                    /// @return the grammar node
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.Add(Syn.Speech.Linguist.Language.Grammar.GrammarNode)">
                    /// Adds the given grammar node to the set of nodes for this grammar
                     *
                    /// @param node the grammar node
                    /// @throws Error
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.OptimizeGrammar">
                    /// Eliminate unnecessary nodes from the grammar. This method goes through the grammar and looks for branches to
                    /// nodes that have no words and have only a single exit and bypasses these nodes.
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.AddSilenceWords">
            <summary>
            Adds an optional silence word after every non-filler word in the grammar 
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.AddFillerWords">
            <summary>
            Adds an optional filler word loop after every non-filler word in the grammar 
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.Grammar.GetInterWordFillers">
                    /// Gets the set of fillers after filtering out fillers that don't go between words.
                     *
                    /// @return the set of inter-word fillers
        </member>
        <member name="P:Syn.Speech.Linguist.Language.Grammar.Grammar.InitialNode">
            <summary>
            Returns the initial node for the grammar
            </summary>
            <value>the initial grammar node</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Language.Grammar.Grammar.NumNodes">
                    /// returns the number of nodes in this grammar
                     *
                    /// @return the number of nodes
        </member>
        <member name="P:Syn.Speech.Linguist.Language.Grammar.Grammar.GrammarNodes">
            <summary>
            returns the set of of nodes in this grammar
            </summary>
            <value>the set of nodes</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Language.Grammar.Grammar.Dictionary">
                    /// Gets the dictionary for this grammar
                     *
                    /// @return the dictionary
        </member>
        <member name="F:Syn.Speech.Jsgf.JSGFGrammar.PropBaseGrammarUrl">
            <summary>
            The property that defines the location of the JSGF grammar file.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.JSGFGrammar.PropGrammarName">
            <summary>
            The property that defines the location of the JSGF grammar file.
            </summary>
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFGrammar.GetRuleGrammar">
            Returns the RuleGrammar of this JSGFGrammar.
            
            @return the RuleGrammar
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFGrammar.GetGrammarManager">
            Returns manager used to load grammars
            
            @return manager with loaded grammars
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFGrammar.LoadJSGF(System.String)">
            The JSGF grammar specified by grammarName will be loaded from the base
            url (tossing out any previously loaded grammars)
            
            @param grammarName
                       the name of the grammar
            @throws IOException
                        if an error occurs while loading or compiling the grammar
            @throws JSGFGrammarException
            @throws JSGFGrammarParseException
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFGrammar.CreateGrammar">
            Creates the grammar.
            
            @return the initial node of the Grammar
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFGrammar.ProcessRule(Syn.Speech.Jsgf.Rule.JSGFRule)">
            Parses the given Rule into a network of GrammarNodes.
            
            @param rule
                       the Rule to parse
            @return a grammar graph
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFGrammar.ProcessRuleName(Syn.Speech.Jsgf.Rule.JSGFRuleName)">
            Parses the given RuleName into a network of GrammarNodes.
            
            @param initialRuleName
                       the RuleName rule to parse
            @return a grammar graph
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFGrammar.ProcessRuleCount(Syn.Speech.Jsgf.Rule.JSGFRuleCount)">
            Parses the given RuleCount into a network of GrammarNodes.
            
            @param ruleCount
                       the RuleCount object to parse
            @return a grammar graph
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFGrammar.ProcessRuleAlternatives(Syn.Speech.Jsgf.Rule.JSGFRuleAlternatives)">
            Parses the given RuleAlternatives into a network of GrammarNodes.
            
            @param ruleAlternatives
                       the RuleAlternatives to parse
            @return a grammar graph
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFGrammar.GetNormalizedWeights(System.Collections.Generic.List{Syn.Speech.Helper.Float})">
            Normalize the weights. The weights should always be zero or greater. We
            need to convert the weights to a log probability.
            
            @param weights
                       the weights to normalize
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFGrammar.ProcessRuleSequence(Syn.Speech.Jsgf.Rule.JSGFRuleSequence)">
            Parses the given RuleSequence into a network of GrammarNodes.
            
            @param ruleSequence
                       the RuleSequence to parse
            @return the first and last GrammarNodes of the network
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFGrammar.ProcessRuleTag(Syn.Speech.Jsgf.Rule.JSGFRuleTag)">
            Parses the given RuleTag into a network GrammarNodes.
            
            @param ruleTag
                       the RuleTag to parse
            @return the first and last GrammarNodes of the network
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFGrammar.ProcessRuleToken(Syn.Speech.Jsgf.Rule.JSGFRuleToken)">
            Creates a GrammarNode with the word in the given RuleToken.
            
            @param ruleToken
                       the RuleToken that contains the word
            @return a GrammarNode with the word in the given RuleToken
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFGrammar.CommitChanges">
            Commit changes to all loaded grammars and all changes of grammar since
            the last commitChange
            
            @throws JSGFGrammarParseException
            @throws JSGFGrammarException
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFGrammar.LoadImports(Syn.Speech.Jsgf.JSGFRuleGrammar)">
            Load grammars imported by the specified RuleGrammar if they are not
            already loaded.
            
            @throws JSGFGrammarParseException
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFGrammar.LoadNamedGrammar(System.String)">
            Load named grammar from import rule
            
            @param grammarName
            @return already loaded grammar
            @throws JSGFGrammarParseException
            @throws IOException
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFGrammar.LoadFullQualifiedRules(Syn.Speech.Jsgf.JSGFRuleGrammar)">
            Load grammars imported by a fully qualified Rule Token if they are not
            already loaded.
            
            @param grammar
            @throws IOException
            @throws GrammarException
            @throws JSGFGrammarParseException
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFGrammar.GetFullRuleName(System.String)">
            Gets the fully resolved rule name
            
            @param ruleName
                       the partial name
            @return the fully resolved name
            @throws JSGFGrammarException
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFGrammar.DumpGrammar">
            Dumps interesting things about this grammar 
        </member>
        <member name="P:Syn.Speech.Jsgf.JSGFGrammar.BaseUrl">
            Sets the URL context of the JSGF grammars.
            
            @param url
                       the URL context of the grammars
        </member>
        <member name="P:Syn.Speech.Jsgf.JSGFGrammar.GrammarName">
            Returns the name of this grammar. 
        </member>
        <member name="P:Syn.Speech.Jsgf.JSGFGrammar.InitialNode">
            Returns the initial node for the grammar
            
            @return the initial grammar node
        </member>
        <member name="M:Syn.Speech.Jsgf.GrXMLGrammar.CommitChanges">
            Commit changes to all loaded grammars and all changes of grammar since
            the last commitChange
            
            @throws JSGFGrammarParseException
            @throws JSGFGrammarException
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Jsgf.JSGFRuleGrammar" -->
        <member name="F:Syn.Speech.Jsgf.JSGFRuleGrammar._ruleDocComments">
            Storage for documentation comments for rules for JSGF doc. 
        </member>
        <member name="F:Syn.Speech.Jsgf.JSGFRuleGrammar._importDocComments">
            Storage for documentation comments for imports for JSGF doc. 
        </member>
        <member name="F:Syn.Speech.Jsgf.JSGFRuleGrammar._grammarDocComment">
            Storage for documentation comments for the grammar for JSGF doc. 
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.#ctor(System.String,Syn.Speech.Jsgf.JSGFRuleGrammarManager)">
            Create a new RuleGrammar
            
            @param name
                       the name of this Grammar.
            @param manager
                       the manager for the created Grammars
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.AddGrammarDocComment(System.String)">
            Add the Grammar comment. 
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.AddImport(Syn.Speech.Jsgf.Rule.JSGFRuleName)">
            Import all rules or a specified rule from another grammar.
            
            @param importName
                       the name of the rule(s) to import.
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.AddImportDocComment(Syn.Speech.Jsgf.Rule.JSGFRuleName,System.String)">
            Add a new import comment. 
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.AddRuleDocComment(System.String,System.String)">
            Add a new RuleGrammar comment. 
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.AddSampleSentence(System.String,System.String)">
            add a sample sentence to the list of sample sentences that go with the
            specified rule
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.DeleteRule(System.String)">
            Delete a rule from the grammar.
            
            @param ruleName
                       the name of the rule.
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.GetGrammarDocComment">
            Retrieve the Grammar comment. 
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.GetImportDocComment(Syn.Speech.Jsgf.Rule.JSGFRuleName)">
            Retrieve an import comment. 
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.GetJSGFTags(System.String)">
            Returns the jsgf tags associated to the given rule. Cf.
            jsgf-specification for details.
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.GetKnownRule(System.String)">
            Gets the Rule with the given name after it has been stripped, or throws
            an Exception if it is unknown.
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.GetRule(System.String)">
            Return the data structure for the named rule.
            
            @param ruleName
                       the name of the rule.
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.GetRuleDocComment(System.String)">
            Retrieve a RuleGrammar comment. 
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.IsRulePublic(System.String)">
            Test whether the specified rule is public.
            
            @param ruleName
                       the name of the rule.
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.GetImports">
            List the current imports. 
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.GetRuleNames">
            List the names of all rules define in this Grammar. 
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.RemoveImport(Syn.Speech.Jsgf.Rule.JSGFRuleName)">
            Remove an import.
            
            @param importName
                       the name of the rule(s) to remove.
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.Resolve(Syn.Speech.Jsgf.Rule.JSGFRuleName)">
            Resolve a simple or qualified rule name as a full rule name.
            
            @param ruleName
                       the name of the rule.
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.ResolveAllRules">
            Resolve and link up all rule references contained in all rules. 
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.ResolveRule(Syn.Speech.Jsgf.Rule.JSGFRule)">
            Resolve the given rule. 
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.SetEnabled(System.Boolean)">
            Set the enabled property of the Grammar.
            
            @param enabled
                       the new desired state of the enabled property.
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.SetEnabled(System.String,System.Boolean)">
            Set the enabled state of the listed rule.
            
            @param ruleName
                       the name of the rule.
            @param enabled
                       the new enabled state.
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.SetRule(System.String,Syn.Speech.Jsgf.Rule.JSGFRule,System.Boolean)">
            Set a rule in the grammar either by creating a new rule or updating an
            existing rule.
            
            @param ruleName
                       the name of the rule.
            @param rule
                       the definition of the rule.
            @param isPublic
                       whether this rule is public or not.
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.ToString">
            Returns a string containing the specification for this grammar.
            
            @return specification for this grammar.
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.FormatComment(System.String)">
            Expands the given String comment into: A. a multi-line comment if the
            provided String contains any newline characters. B. a single-line comment
            if comment does not contain any newline characters.
            
            @param comment
                       The String to expand into a multi or single line comment.
            @return If the provided string is not null, the multi or single line
                    representation of the provided comment, otherwise an empty string
                    ("").
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammar.SaveJSGF(System.IO.FileInfo)">
            This JSGFRule grammar will be saved to the file in the provided URL,
            Overwriting any contents in the provided file, or creating a new one if
            it does not exist.
            
            @param url
                       The URL to save this JSGFRuleGrammar to.
            @throws URISyntaxException
                        If there was a problem converting the given url to uri.
            @throws IOException
                        if an error occurs while saving or compiling the grammar
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammarManager.StoreGrammar(Syn.Speech.Jsgf.JSGFRuleGrammar)">
            <summary>
            Add a grammar to the grammar list.
            </summary>
            <param name="grammar">The grammar.</param>
        </member>
        <member name="M:Syn.Speech.Jsgf.JSGFRuleGrammarManager.RetrieveGrammar(System.String)">
            <summary>
            Retrieve a grammar from the grammar list.
            </summary>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="T:Syn.Speech.Jsgf.Parser.JavaCharStream">
            <summary>
            An implementation of interface CharStream, 
            where the stream is assumed to contain only ASCII characters (with java-like unicode escape processing).
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JavaCharStream.StaticFlag">
            <summary>
            Whether parser is static.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JavaCharStream.Bufpos">
            Position in buffer. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.BeginToken">
            @return starting character for token. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.ReadChar">
            Read a character. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.GetEndColumn">
            Get end column. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.GetEndLine">
            Get end line. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.GetBeginColumn">
            @return column of token start 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.GetBeginLine">
            @return line number of token start 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.Backup(System.Int32)">
            Retreat. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.#ctor(System.IO.TextReader,System.Int32,System.Int32,System.Int32)">
            Constructor. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.#ctor(System.IO.TextReader,System.Int32,System.Int32)">
            Constructor. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.#ctor(System.IO.TextReader)">
            Constructor. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.ReInit(System.IO.TextReader,System.Int32,System.Int32,System.Int32)">
            Reinitialise. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.ReInit(System.IO.TextReader,System.Int32,System.Int32)">
            Reinitialise. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.ReInit(System.IO.TextReader)">
            Reinitialise. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.#ctor(System.IO.Stream,System.String,System.Int32,System.Int32,System.Int32)">
            Constructor. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.#ctor(System.IO.Stream,System.Int32,System.Int32,System.Int32)">
            Constructor. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.#ctor(System.IO.Stream,System.String,System.Int32,System.Int32)">
            Constructor. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.#ctor(System.IO.Stream,System.Int32,System.Int32)">
            Constructor. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.#ctor(System.IO.Stream,System.String)">
            Constructor. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.#ctor(System.IO.Stream)">
            Constructor. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.ReInit(System.IO.Stream,System.String,System.Int32,System.Int32,System.Int32)">
            Reinitialise. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.ReInit(System.IO.Stream,System.Int32,System.Int32,System.Int32)">
            Reinitialise. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.ReInit(System.IO.Stream,System.String,System.Int32,System.Int32)">
            Reinitialise. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.ReInit(System.IO.Stream,System.Int32,System.Int32)">
            Reinitialise. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.ReInit(System.IO.Stream,System.String)">
            Reinitialise. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.ReInit(System.IO.Stream)">
            Reinitialise. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.GetImage">
            @return token image as String 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.GetSuffix(System.Int32)">
            @return suffix 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.Done">
            Set buffers back to null when finished. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JavaCharStream.AdjustBeginLineColumn(System.Int32,System.Int32)">
            <summary>
            Method to adjust line and column numbers for the start of a token.
            </summary>
            <param name="newLine">The new line.</param>
            <param name="newCol">The new col.</param>
        </member>
        <member name="P:Syn.Speech.Jsgf.Parser.JSGFEncoding.GetEncoding">
            <summary>
            Extra Method. Gets the Encoding using the encoding's name. 
            </summary>
            <value>
            The get encoding.
            </value>
        </member>
        <member name="T:Syn.Speech.Jsgf.Parser.JSGFParserConstants">
            <summary>
            Token literal values and constants.
            Generated by org.javacc.parser.OtherFilesGen#start()
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.Eof">
            <summary>
            End of File.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.SingleLineComment">
            <summary>
            RegularExpression Id.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.Grammar">
            <summary>
            RegularExpression Id.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.Import">
            <summary>
            RegularExpression Id.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.Public">
            <summary>
            RegularExpression Id.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.IntegerLiteral">
            <summary>
            RegularExpression Id.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.FloatingPointLiteral">
            <summary>
            RegularExpression Id.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.StringLiteral">
            <summary>
            RegularExpression Id.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.Tag">
            <summary>
            RegularExpression Id.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.Identifier">
            <summary>
            RegularExpression Id.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.FormalComment">
            <summary>
            RegularExpression Id.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.MultiLineComment">
            <summary>
            RegularExpression Id.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.DecimalLiteral">
            <summary>
            RegularExpression Id.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.Exponent">
            <summary>
            RegularExpression Id.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.CharacterLiteral">
            <summary>
            RegularExpression Id.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.Letter">
            <summary>
            RegularExpression Id.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.Digit">
            <summary>
            RegularExpression Id.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.Default">
            <summary>
            Lexical state.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.InSingleLineComment">
            <summary>
            Lexical state.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.InFormalComment">
            <summary>
            Lexical state.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.InMultiLineComment">
            <summary>
            Lexical state.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserConstants.TokenImage">
            <summary>
            Literal token values.
            </summary>
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParser.NewGrammarFromJSGF(System.IO.Stream,Syn.Speech.Jsgf.JSGFRuleGrammarFactory)">
            newGrammarFromJSGF - Once JavaCC supports Readers we will change this
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParser.NewGrammarFromJSGF(System.IO.TextReader,Syn.Speech.Jsgf.JSGFRuleGrammarFactory)">
            newGrammarFromJSGF - Once JavaCC supports Readers we will change this
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParser.NewGrammarFromJSGF(Syn.Speech.Helper.URL,Syn.Speech.Jsgf.JSGFRuleGrammarFactory)">
            newGrammarFromURL
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParser.RuleForJSGF(System.String)">
            ruleForJSGF
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParser.ExtractKeywords(Syn.Speech.Jsgf.JSGFRuleGrammar,System.String,System.String)">
            extract @keywords from documentation comments
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParser.token_source">
            Generated Token Manager. 
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParser.token">
            Current token. 
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParser.jj_nt">
            Next token. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParser.#ctor(System.IO.Stream)">
            Constructor with InputStream. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParser.#ctor(System.IO.Stream,System.String)">
            Constructor with InputStream and supplied encoding 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParser.ReInit(System.IO.Stream)">
            Reinitialize. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParser.ReInit(System.IO.Stream,System.String)">
            Reinitialize. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParser.#ctor(System.IO.TextReader)">
            Constructor. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParser.ReInit(System.IO.TextReader)">
            Reinitialize. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParser.#ctor(Syn.Speech.Jsgf.Parser.JSGFParserTokenManager)">
            Constructor with generated Token Manager. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParser.ReInit(Syn.Speech.Jsgf.Parser.JSGFParserTokenManager)">
            Reinitialize. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParser.GetNextToken">
            Get the next Token. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParser.GetToken(System.Int32)">
            Get the specific Token. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParser.GenerateParseException">
            Generate ParseException. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParser.enable_tracing">
            Enable tracing. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParser.disable_tracing">
            Disable tracing. 
        </member>
        <member name="T:Syn.Speech.Jsgf.Parser.JSGFParserTokenManager">
            <summary>
            Token Manager. 
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserTokenManager.DebugStream">
            <summary>
            Debug output.
            </summary>
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParserTokenManager.SetDebugStream(System.IO.TextWriter)">
            <summary>
            Set debug output.
            </summary>
            <param name="ds">The ds.</param>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserTokenManager.jjstrLiteralImages">
            <summary>
            Token literal values.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserTokenManager.LexStateNames">
            Lexer state names. 
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.JSGFParserTokenManager.JjnewLexState">
            Lex State array. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParserTokenManager.#ctor(Syn.Speech.Jsgf.Parser.JavaCharStream)">
            Constructor. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParserTokenManager.#ctor(Syn.Speech.Jsgf.Parser.JavaCharStream,System.Int32)">
            Constructor. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParserTokenManager.ReInit(Syn.Speech.Jsgf.Parser.JavaCharStream)">
            Reinitialise parser. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParserTokenManager.ReInit(Syn.Speech.Jsgf.Parser.JavaCharStream,System.Int32)">
            Reinitialise parser. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParserTokenManager.SwitchTo(System.Int32)">
            Switch to specified lex state. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.JSGFParserTokenManager.GetNextToken">
            <summary>
            Gets the next token.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Syn.Speech.Jsgf.Parser.ParseException">
             This exception is thrown when parse errors are encountered.
             You can explicitly create objects of this exception type by
             calling the method generateParseException in the generated
             parser.
            
             You can modify this class to customize your error reporting
             mechanisms so long as you retain the public fields.
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.ParseException.#ctor(Syn.Speech.Jsgf.Parser.Token,System.Int32[][],System.String[])">
            This constructor is used by the method "generateParseException"
            in the generated parser.  Calling this constructor generates
            a new object of this type with the fields "currentToken",
            "expectedTokenSequences", and "tokenImage" set.
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.ParseException.#ctor">
            The following constructors are for use by you for whatever
            purpose you can think of.  Constructing the exception in this
            manner makes the exception behave in the normal way - i.e., as
            documented in the class "Throwable".  The fields "errorToken",
            "expectedTokenSequences", and "tokenImage" do not contain
            relevant information.  The JavaCC generated code does not use
            these constructors.
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.ParseException.#ctor(System.String)">
            Constructor with message. 
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.ParseException.CurrentToken">
            This is the last token that has been consumed successfully.  If
            this object has been created due to a parse error, the token
            followng this token will (therefore) be the first error token.
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.ParseException.ExpectedTokenSequences">
            Each entry in this array is an array of integers.  Each array
            of integers represents a sequence of tokens (by their ordinal
            values) that is expected at this point of the parse.
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.ParseException.TokenImage">
            This is a reference to the "tokenImage" array of the generated
            parser within which the parse error occurred.  This array is
            defined in the generated ...Constants interface.
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.ParseException.Initialise(Syn.Speech.Jsgf.Parser.Token,System.Int32[][],System.String[])">
            It uses "currentToken" and "expectedTokenSequences" to generate a parse
            error message and returns it.  If this object has been created
            due to a parse error, and you do not catch it (it gets thrown
            from the parser) the correct error message
            gets displayed.
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.ParseException.Eol">
            The end of line string for this machine.
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.ParseException.Add_Escapes(System.String)">
            Used to convert raw characters to their escaped version
            when these raw version cannot be used as part of an ASCII
            string literal.
        </member>
        <member name="T:Syn.Speech.Jsgf.Parser.Token">
            <summary>
            Describes the input token stream.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.Token.Kind">
            An integer that describes the kind of this token.  This numbering
            system is determined by JavaCCParser, and a table of these numbers is
            stored in the file ...Constants.java.
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.Token.BeginLine">
            <summary>
            The line number of the first character of this Token.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.Token.BeginColumn">
            <summary>
            The column number of the first character of this Token.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.Token.EndLine">
            <summary>
            The line number of the last character of this Token.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.Token.EndColumn">
            <summary>
            The column number of the last character of this Token.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.Token.Image">
            The string image of the token.
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.Token.Next">
            A reference to the next regular (non-special) token from the input
            stream.  If this is the last token from the input stream, or if the
            token manager has not read tokens beyond this one, this field is
            set to null.  This is true only if this token is also a regular
            token.  Otherwise, see below for a description of the contents of
            this field.
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.Token.SpecialToken">
            This field is used to access special tokens that occur prior to this
            token, but after the immediately preceding regular (non-special) token.
            If there are no such special tokens, this field is set to null.
            When there are more than one such special token, this field refers
            to the last of these special tokens, which in turn refers to the next
            previous special token through its specialToken field, and so on
            until the first special token (whose specialToken field is null).
            The next fields of special tokens refer to other special tokens that
            immediately follow it (without an intervening regular token).  If there
            is no such token, this field is null.
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.Token.GetValue">
            An optional attribute value of the Token.
            Tokens which are not used as syntactic sugar will often contain
            meaningful values that will be used later on by the compiler or
            interpreter. This attribute value is often different from the image.
            Any subclass of Token that actually wants to return a non-null value can
            override this method as appropriate.
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.Token.#ctor">
            No-argument constructor
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.Token.#ctor(System.Int32)">
            Constructs a new token for the specified Image.
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.Token.#ctor(System.Int32,System.String)">
            Constructs a new token for the specified Image and Kind.
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.Token.ToString">
            Returns the image.
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.Token.NewToken(System.Int32,System.String)">
             Returns a new Token object, by default. However, if you want, you
             can create and return subclass objects based on the value of ofKind.
             Simply add the cases to the switch for all those special cases.
             For example, if you have a subclass of Token called IDToken that
             you want to create if ofKind is ID, simply add something like :
            
                case MyParserConstants.ID : return new IDToken(ofKind, image);
            
             to the following switch statement. Then you can cast matchedToken
             variable to the appropriate type and use sit in your lexical actions.
        </member>
        <member name="T:Syn.Speech.Jsgf.Parser.TokenMgrError">
            <summary>
            Token Manager Error.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.TokenMgrError.LEXICAL_ERROR">
            <summary>
            Lexical error occurred.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.TokenMgrError.StaticLexerError">
            <summary>
            An attempt was made to create a second instance of a static token manager.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.TokenMgrError.InvalidLexicalState">
            <summary>
             Tried to change to an invalid lexical state.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.TokenMgrError.LoopDetected">
            <summary>
            Detected (and bailed out of) an infinite loop in the token manager.
            </summary>
        </member>
        <member name="F:Syn.Speech.Jsgf.Parser.TokenMgrError.errorCode">
            <summary>
            Indicates the reason why the exception is thrown. It will have one of the above 4 values.
            </summary>
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.TokenMgrError.AddEscapes(System.String)">
            <summary>
            Replaces unprintable characters by their escaped (or unicode escaped) equivalents in the given string
            </summary>
            <param name="str">The string.</param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.TokenMgrError.LexicalError(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char)">
            Returns a detailed message for the Error when it is thrown by the
            token manager to indicate a lexical error.
            Parameters :
               EOFSeen     : indicates if EOF caused the lexical error
               curLexState : lexical state in which this error occurred
               errorLine   : line number when the error occurred
               errorColumn : column number when the error occurred
               errorAfter  : prefix that was seen before this error occurred
               curchar     : the offending character
            Note: You can customize the lexical error message by modifying this method.
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.TokenMgrError.GetMessage">
             You can also modify the body of this method to customize your error messages.
             For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
             of end-users concern, so you can return something like :
            
                 "Internal Error : Please file a bug report .... "
            
             from this method for such cases in the release version of your parser.
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.TokenMgrError.#ctor">
            No arg constructor. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.TokenMgrError.#ctor(System.String,System.Int32)">
            Constructor with message and reason. 
        </member>
        <member name="M:Syn.Speech.Jsgf.Parser.TokenMgrError.#ctor(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char,System.Int32)">
            Full Constructor. 
        </member>
        <member name="T:Syn.Speech.Jsgf.RuleStack">
            <summary>
            Manages a stack of grammar graphs that can be accessed by grammar name.
            </summary>
        </member>
        <member name="M:Syn.Speech.Jsgf.RuleStack.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Jsgf.RuleStack"/> class and creates a name stack
            </summary>
        </member>
        <member name="M:Syn.Speech.Jsgf.RuleStack.Push(System.String,Syn.Speech.Jsgf.GrammarGraph)">
            <summary>
            Pushes the grammar graph on the stack
            </summary>
        </member>
        <member name="M:Syn.Speech.Jsgf.RuleStack.Pop">
            <summary>
            remove the top graph on the stack.
            </summary>
        </member>
        <member name="M:Syn.Speech.Jsgf.RuleStack.Contains(System.String)">
            <summary>
            Checks to see if the stack contains a graph with the given name.
            </summary>
            <param name="name">The graph name.</param>
            <returns>The grammar graph associated with the name if found, otherwise null</returns>
        </member>
        <member name="M:Syn.Speech.Jsgf.RuleStack.Clear">
            <summary>
            Clears this name stack.
            </summary>
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.IHMM">
            <summary>
            Represents a hidden-markov-model. An HMM consists of a unit (context dependent or independent), a transition matrix
            from state to state, and a sequence of senones associated with each state. This representation of an HMM is a
            specialized left-to-right markov model. No backward transitions are allowed.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.IHMM.GetState(System.Int32)">
            <summary>
            Retrieves the hmm state
            </summary>
            <param name="which"></param>
            <returns>which the state of interest</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.IHMM.GetInitialState">
            <summary>
            Gets the initial states (with probabilities) for this HMM
            </summary>
            <returns>the set of arcs that transition to the initial states for this HMM</returns>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.IHMM.Unit">
            <summary>
            Gets the  unit associated with this HMM
            </summary>
            <value>the unit associated with this HMM</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.IHMM.BaseUnit">
            <summary>
            Gets the  base unit associated with this HMM
            </summary>
            <value>the unit associated with this HMM</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.IHMM.Order">
            <summary>
            Returns the order of the HMM
            </summary>
            <value>the order of the HMM</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.IHMM.Position">
            <summary>
            Retrieves the position of this HMM.
            </summary>
            <value>the position for this HMM</value>
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.IHMMState">
            <summary>
            Represents a single state in an HMM
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.IHMMState.GetMixtureComponents">
            <summary>
            Returns the mixture components associated with this Gaussian
            </summary>
            <returns>the array of mixture components</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.IHMMState.GetMixtureId">
            <summary>
            Gets the id of the mixture
            </summary>
            <returns>the id</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.IHMMState.GetLogMixtureWeights">
            <summary>
            
            </summary>
            <returns>the mixture weights vector</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.IHMMState.GetScore(Syn.Speech.FrontEnds.IData)">
            <summary>
            Gets the score for this HMM state
            </summary>
            <param name="data">the data to be scored</param>
            <returns>the acoustic score for this state.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.IHMMState.GetSuccessors">
            <summary>
            Retrieves the state of successor states for this state
            </summary>
            <returns>the set of successor state arcs</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.IHMMState.IsExitState">
            <summary>
            Determines if this state is an exit state of the HMM
            </summary>
            <returns>true if the state is an exit state</returns>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.IHMMState.HMM">
            <summary>
            Gets the HMM associated with this state
            </summary>
            <value>the HMM</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.IHMMState.State">
            <summary>
            Gets the state
            </summary>
            <value>the state</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.IHMMState.IsEmitting">
            <summary>
            Determines if this HMMState is an emitting state
            </summary>
            <value>true if the state is an emitting state</value>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.ILoader.Load">
            <summary>
            Loads the acoustic model.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.ILoader.LogInfo">
            <summary>
            Logs information about this loader 
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.ILoader.Update(Syn.Speech.Decoders.Adaptation.Transform,Syn.Speech.Decoders.Adaptation.ClusteredDensityFileData)">
            <summary>
            Apply the transform
            </summary>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.ILoader.MeansPool">
            <summary>
            ets the pool of means for this loader.
            </summary>
            <value>The pool.</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.ILoader.MeansTransformationMatrixPool">
            <summary>
            Gets the means transformation matrix pool.
            </summary>
            <value>The pool.</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.ILoader.MeansTransformationVectorPool">
            <summary>
            Gets the means transformation vector pool.
            </summary>
            <value>The pool.</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.ILoader.VariancePool">
            <summary>
            Gets the variance pool.
            </summary>
            <value>The pool.</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.ILoader.VarianceTransformationMatrixPool">
            <summary>
            Gets the variance transformation matrix pool.
            </summary>
            <value>The pool.</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.ILoader.VarianceTransformationVectorPool">
            <summary>
            Gets the variance transformation vector pool.
            </summary>
            <value>The pool.</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.ILoader.MixtureWeightsPool">
            <summary>
            Gets the mixture weights pool.
            </summary>
            <value>The pool.</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.ILoader.TransitionMatrixPool">
            <summary>
            Gets the transition matrix pool.
            </summary>
            <value>The pool.</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.ILoader.TransformMatrix">
            <summary>
            Gets the transformation matrix.
            </summary>
            <value>The matrix.</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.ILoader.SenonePool">
            <summary>
            Gets the senone pool for this loader.
            </summary>
            <value>The pool.</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.ILoader.HMMManager">
            <summary>
            Gets the HMM Manager for this loader.
            </summary>
            <value>The HMM Manager.</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.ILoader.ContextIndependentUnits">
            <summary>
            Gets the map of context indepent units. The map can be accessed by unit name.
            </summary>
            <value>The map of context independent units.</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.ILoader.LeftContextSize">
            <summary>
            Gets the size of the left context for context dependent units.
            </summary>
            <value>The left context size.</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.ILoader.RightContextSize">
            <summary>
            Gets the size of the right context for context dependent units.
            </summary>
            <value>The left context size.</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.ILoader.Properties">
            <summary>
            Gets the model properties.
            </summary>
            <value></value>
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.Tiedstate.ISenone">
            <summary>
            Represents a set of acoustic data that can be scored against a feature
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.ISenone.GetScore(Syn.Speech.FrontEnds.IData)">
            <summary>
            Calculates the score for this senone based upon the given feature.
            </summary>
            <param name="feature">The feature vector to score this senone against.</param>
            <returns>The score for this senone in LogMath log base.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.ISenone.CalculateComponentScore(Syn.Speech.FrontEnds.IData)">
            <summary>
            Calculates the component scores for the mixture components in this senone based upon the given feature.
            </summary>
            <param name="feature">The feature vector to score this senone against.</param>
            <returns>The scores for this senone in LogMath log base.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.ISenone.Dump(System.String)">
            <summary>
            Dumps a senone
            </summary>
            <param name="msg">The annotation for the dump.</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.ISenone.GetLogMixtureWeights">
            <summary>
            Gets the mixture weights vector.
            </summary>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.ISenone.ID">
            <summary>
            Gets the ID for this senone
            </summary>
            <value>
            The senone id.
            </value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.ISenone.MixtureComponents">
            <summary>
            Gets the mixture components associated with this Gaussian.
            </summary>
            <value>
            The array of mixture components.
            </value>
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.Tiedstate.Pool`1">
            <summary>
            Used to pool shared objects in the acoustic model
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Pool`1.#ctor(System.String)">
                    /// Creates a new pool.
                     *
                    /// @param name the name of the pool
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Pool`1.Get(System.Int32)">
                    /// Returns the object with the given ID from the pool.
                     *
                    /// @param id the id of the object
                    /// @return the object
                    /// @throws IndexOutOfBoundsException if the ID is out of range
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Pool`1.IndexOf(`0)">
                    /// Returns the ID of a given object from the pool.
                     *
                    /// @param object the object
                    /// @return the index
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Pool`1.Put(System.Int32,`0)">
                    /// Places the given object in the pool.
                     *
                    /// @param id a unique ID for this object
                    /// @param o  the object to add to the pool
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Pool`1.LogInfo">
                    /// Dump information on this pool to the given logger.
                     *
                    /// @param logger the logger to send the info to
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Pool`1.SetFeature(Syn.Speech.Linguist.Acoustic.Tiedstate.Feature,System.Int32)">
                    /// Sets a feature for this pool.
                     *
                    /// @param feature feature to set
                    /// @param value the value for the feature
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Pool`1.GetFeature(Syn.Speech.Linguist.Acoustic.Tiedstate.Feature,System.Int32)">
                    /// Retrieves a feature from this pool.
                     *
                    /// @param feature feature to get
                    /// @param defaultValue the defaultValue for the pool
                    /// @return the value for the feature
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.Pool`1.Name">
                    /// Returns the pool's name.
                     *
                    /// @return the pool name
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.Pool`1.Size">
                    /// Retrieves the size of the pool.
                     *
                    /// @return the size of the pool
        </member>
        <member name="T:Syn.Speech.Decoders.AbstractDecoder">
            <summary>
            An abstract decoder which implements all functionality which is independent of the used decoding-paradigm (pull/push).
            </summary>
        </member>
        <member name="T:Syn.Speech.Decoders.IResultProducer">
            <summary>
            Some API-elements shared by components which are able to produce Results.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.IResultProducer.AddResultListener(Syn.Speech.Decoders.IResultListener)">
            <summary>
            Registers a new listener for Result.
            </summary>
            <param name="resultListener"></param>
        </member>
        <member name="M:Syn.Speech.Decoders.IResultProducer.RemoveResultListener(Syn.Speech.Decoders.IResultListener)">
            <summary>
            Removes a listener from this ResultProducer -instance.
            </summary>
            <param name="resultListener"></param>
        </member>
        <member name="F:Syn.Speech.Decoders.AbstractDecoder.PropSearchManager">
            <summary>
            The property that defines the name of the search manager to use
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.AbstractDecoder.PropResultListeners">
            <summary>
            The property that defines the name of the search manager to use
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.AbstractDecoder.AutoAllocate">
            <summary>
            If set to true the used search-manager will be automatically allocated
             in <code>newProperties()</code>.
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.AbstractDecoder.FireNonFinalResults">
            <summary>
            If set to <code>false</code> the used search-manager all registered
            result listeners will be notified only for final results. Per default
            non-final results don't trigger notification, because in most
            application the utterance final result will be sufficient.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.AbstractDecoder.#ctor(Syn.Speech.Decoders.Search.ISearchManager,System.Boolean,System.Boolean,System.Collections.Generic.List{Syn.Speech.Decoders.IResultListener})">
            <summary>
            
            </summary>
            <param name="searchManager"></param>
            <param name="fireNonFinalResults"></param>
            <param name="autoAllocate"></param>
            <param name="resultListeners"></param>
        </member>
        <member name="M:Syn.Speech.Decoders.AbstractDecoder.Decode(System.String)">
            <summary>
            Decode frames until recognition is complete
            </summary>
            <param name="referenceText">the reference text (or null)</param>
            <returns>a result</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.AbstractDecoder.Allocate">
            <summary>
            Allocate resources necessary for decoding
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.AbstractDecoder.Deallocate">
            <summary>
            Deallocate resources
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.AbstractDecoder.AddResultListener(Syn.Speech.Decoders.IResultListener)">
            <summary>
            Adds a result listener to this recognizer. A result listener is called whenever a new result is generated by the
            recognizer. This method can be called in any state.
            </summary>
            <param name="resultListener"></param>
        </member>
        <member name="M:Syn.Speech.Decoders.AbstractDecoder.RemoveResultListener(Syn.Speech.Decoders.IResultListener)">
            <summary>
            Removes a previously added result listener. This method can be called in any state.
            </summary>
            <param name="resultListener">the listener to remove</param>
        </member>
        <member name="M:Syn.Speech.Decoders.AbstractDecoder.FireResultListeners(Syn.Speech.Results.Result)">
            <summary>
            Fires new results as soon as they become available.
            </summary>
            <param name="result">the new result</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Adaptation.Stats.FillRegLowerPart">
            <summary>
            Fill lower part of Legetter's set of G matrices.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Adaptation.Transform.Store(System.String,System.Int32)">
            <summary>
            Writes the transformation to file in a format that could further be used in Sphinx3 and Sphinx4.
            </summary>
            <param name="filePath">The file path.</param>
            <param name="index">The index.</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Adaptation.Transform.ComputeMllrTransforms(System.Double[][][][][],System.Double[][][][])">
            <summary>
            Used for computing the actual transformations (A and B matrices). These are stored in As and Bs.
            </summary>
            <param name="regLs">The reg ls.</param>
            <param name="regRs">The reg rs.</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Adaptation.Transform.Load(System.String)">
             <summary>
            Read the transformation from a file
             </summary>
             <param name="filePath">The file path.</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Adaptation.Transform.Update(Syn.Speech.Decoders.Adaptation.Stats)">
            <summary>
            Stores in current object a transform generated on the provided stats.
            </summary>
            <param name="stats">Provided stats that were previously collected from Result objects..</param>
        </member>
        <member name="P:Syn.Speech.Decoders.Adaptation.Transform.As">
            <summary>
            Used for access to A matrix.
            </summary>
            <value>A matrix (representing A from A*x + B = C)</value>
        </member>
        <member name="P:Syn.Speech.Decoders.Adaptation.Transform.Bs">
            <summary>
            Used for access to B matrix.
            </summary>
            <value>B matrix (representing B from A*x + B = C)</value>
        </member>
        <member name="F:Syn.Speech.Decoders.Decoder.PropFeatureBlockSize">
            <summary>
            The property for the number of features to recognize at once.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Decoder.Decode(System.String)">
            <summary>
            Decode frames until recognition is complete.
            </summary>
            <param name="referenceText">referenceText the reference text (or null)</param>
            <returns>a result</returns>
        </member>
        <member name="T:Syn.Speech.Decoders.Pruner.IPruner">
            <summary>
            Provides a mechanism for pruning a set of StateTokens
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Pruner.IPruner.StartRecognition">
            <summary>
            Starts the pruner 
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Pruner.IPruner.Prune(Syn.Speech.Decoders.Search.ActiveList)">
            <summary>
            prunes the given set of states 
            </summary>
            <param name="stateTokenList">a list containing StateToken objects to be scored</param>
            <returns>the pruned list, (may be the sample list as stateTokenList)</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Pruner.IPruner.StopRecognition">
            <summary>
            Performs post-recognition cleanup. 
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Pruner.IPruner.Allocate">
            <summary>
            Allocates resources necessary for this pruner
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Pruner.IPruner.Deallocate">
            <summary>
            Deallocates resources necessary for this pruner 
            </summary>
        </member>
        <member name="T:Syn.Speech.Decoders.Pruner.NullPruner">
            <summary>
            A Null pruner. Does no actual pruning
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Pruner.NullPruner.#ctor">
            Creates a simple pruner 
        </member>
        <member name="M:Syn.Speech.Decoders.Pruner.NullPruner.StartRecognition">
            starts the pruner 
        </member>
        <member name="M:Syn.Speech.Decoders.Pruner.NullPruner.StopRecognition">
            Performs post-recognition cleanup. 
        </member>
        <member name="T:Syn.Speech.Decoders.Pruner.SimplePruner">
            <summary>
            Performs the default pruning behavior which is to invoke the purge on the active list
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Pruner.SimplePruner.StartRecognition">
            Starts the pruner 
        </member>
        <member name="M:Syn.Speech.Decoders.Pruner.SimplePruner.Prune(Syn.Speech.Decoders.Search.ActiveList)">
                    /// prunes the given set of states
                     *
                    /// @param activeList a activeList of tokens
        </member>
        <member name="M:Syn.Speech.Decoders.Pruner.SimplePruner.StopRecognition">
            Performs post-recognition cleanup. 
        </member>
        <member name="T:Syn.Speech.Decoders.Scorer.BackgroundModelNormalizer">
            <summary>
            Normalizes a set of Tokens against the best scoring Token of a background model.
            </summary>
        </member>
        <member name="T:Syn.Speech.Decoders.Scorer.IScoreNormalizer">
             <summary>
             Describes all API-elements that are necessary  to normalize token-scores after these have been computed by an
             AcousticScorer.
            
             @author Holger Brandl
             @see Decoder.Scorer.AcousticScorer
             @see Decoder.Search.Token
             </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Scorer.IScoreNormalizer.Normalize``1(System.Collections.Generic.List{``0},Syn.Speech.Decoders.Scorer.IScoreable)">
                    /// Normalizes the scores of a set of Tokens.
                     *
                    /// @param scoreableList The set of scores to be normalized
                    /// @param bestToken     The best scoring Token of the above mentioned list. Although not strictly necessary it's
                    ///                      included because of convenience reasons and to reduce computational overhead.
                    /// @return The best token after the all <code>Token</code>s have been normalized. In most cases normalization won't
                    ///         change the order but to keep the API open for any kind of approach it seemed reasonable to include this.
        </member>
        <member name="F:Syn.Speech.Decoders.Scorer.BackgroundModelNormalizer.ActiveListProvider">
            <summary>
            The active list provider used to determined the best token for normalization. If this reference is not defined no normalization will be applied.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Scorer.BackgroundModelNormalizer.#ctor(Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Decoders.Scorer.BackgroundModelNormalizer"/> class.
            </summary>
            <param name="activeListProvider">The active list provider used to determined the best token for normalization. 
            If this reference is not defined no normalization will be applied.</param>
        </member>
        <member name="T:Syn.Speech.Decoders.Scorer.IAcousticScorer">
            <summary>
            Provides a mechanism for scoring a set of HMM states
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Scorer.IAcousticScorer.Allocate">
            <summary>
            Allocates resources for this scorer 
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Scorer.IAcousticScorer.Deallocate">
            <summary>
            Deallocates resources for this scorer 
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Scorer.IAcousticScorer.StartRecognition">
            <summary>
            starts the scorer 
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Scorer.IAcousticScorer.StopRecognition">
            <summary>
            stops the scorer 
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Scorer.IAcousticScorer.CalculateScores``1(System.Collections.Generic.List{``0})">
            <summary>
            Scores the given set of states
            </summary>
            <param name="scorableList">a list containing Scoreable objects to be scored</param>
            <returns>the best scoring scoreable, or null if there are no more frames to score</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Scorer.IScoreable.CalculateScore(Syn.Speech.FrontEnds.IData)">
            <summary>
            Calculates a score against the given data. The score can be retrieved with get score
            </summary>
            <param name="data">the data to be scored</param>
            <returns>the score for the data</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Scorer.IScoreable.NormalizeScore(System.Single)">
            <summary>
            Normalizes a previously calculated score
            </summary>
            <param name="maxScore"></param>
            <returns>the normalized score</returns>
        </member>
        <member name="P:Syn.Speech.Decoders.Scorer.IScoreable.Score">
            <summary>
            Retrieves a previously calculated (and possibly normalized) score
            </summary>
            <value>the score</value>
        </member>
        <member name="P:Syn.Speech.Decoders.Scorer.IScoreable.FrameNumber">
            <summary>
            Returns the frame number that this Scoreable should be scored against.
            </summary>
            <value>the frame number that this Scoreable should be scored against.</value>
        </member>
        <member name="T:Syn.Speech.Decoders.Scorer.IScoreProvider">
            <summary>
            Thing that can provide the score
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Scorer.IScoreProvider.GetScore(Syn.Speech.FrontEnds.IData)">
            <summary>
            Provides the score.
            </summary>
            <param name="data">The data.</param>
            <returns>the score</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Scorer.IScoreProvider.GetComponentScore(Syn.Speech.FrontEnds.IData)">
            <summary>
            Provides component score
            </summary>
            <param name="feature">The feature.</param>
            <returns>the score</returns>
        </member>
        <member name="T:Syn.Speech.Decoders.Scorer.MaxScoreNormalizer">
            <summary>
            Performs a simple normalization of all token-scores by
            </summary>
        </member>
        <member name="T:Syn.Speech.Decoders.Scorer.SimpleAcousticScorer">
             <summary>
             Implements some basic scorer functionality, including a simple default
             acoustic scoring implementation which scores within the current thread,
             that can be changed by overriding the {@link #doScoring} method.
            
             Note that all scores are maintained in LogMath log base.
            
             @author Holger Brandl
             </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Scorer.SimpleAcousticScorer.FeatureFrontend">
            <summary>
             Property the defines the frontend to retrieve features from for scoring
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Scorer.SimpleAcousticScorer.ScoreNormalizer">
                    /// An optional post-processor for computed scores that will normalize scores. If not set, no normalization will
                    /// applied and the token scores will be returned unchanged.
        </member>
        <member name="M:Syn.Speech.Decoders.Scorer.SimpleAcousticScorer.#ctor(Syn.Speech.FrontEnds.BaseDataProcessor,Syn.Speech.Decoders.Scorer.IScoreNormalizer)">
                    /// @param frontEnd the frontend to retrieve features from for scoring
                    /// @param scoreNormalizer optional post-processor for computed scores that will normalize scores. If not set, no normalization will
                    /// applied and the token scores will be returned unchanged.
        </member>
        <member name="M:Syn.Speech.Decoders.Scorer.SimpleAcousticScorer.CalculateScores``1(System.Collections.Generic.List{``0})">
            <summary>
            Scores the given set of states.
            </summary>
            <param name="scoreableList">A list containing scoreable objects to be scored</param>
            <returns>The best scoring scoreable, or <code>null</code> if there are no more features to score</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Scorer.SimpleAcousticScorer.DoScoring``1(System.Collections.Generic.List{``0},Syn.Speech.FrontEnds.IData)">
                    /// Scores a a list of <code>Scoreable</code>s given a <code>Data</code>-object.
                     *
                    /// @param scoreableList The list of Scoreables to be scored
                    /// @param data          The <code>Data</code>-object to be used for scoring.
                    /// @return the best scoring <code>Scoreable</code> or <code>null</code> if the list of scoreables was empty.
                    /// @throws Exception 
        </member>
        <member name="T:Syn.Speech.Decoders.Scorer.ThreadedAcousticScorer">
            <summary>
            An acoustic scorer that breaks the scoring up into a configurable number of separate threads.
            
            All scores are maintained in LogMath log base
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Scorer.ThreadedAcousticScorer.PropThreadPriority">
                    /// The property that controls the thread priority of scoring threads.
                    /// Must be a value between {@link Thread#MIN_PRIORITY} and {@link Thread#MAX_PRIORITY}, inclusive.
                    /// The default is {@link Thread#NORM_PRIORITY}.
        </member>
        <member name="F:Syn.Speech.Decoders.Scorer.ThreadedAcousticScorer.PropNumThreads">
                    /// The property that controls the number of threads that are used to score HMM states. If the isCpuRelative
                    /// property is false, then is is the exact number of threads that are used to score HMM states. If the isCpuRelative
                    /// property is true, then this value is combined with the number of available processors on the system. If you want
                    /// to have one thread per CPU available to score states, set the NUM_THREADS property to 0 and the isCpuRelative to
                    /// true. If you want exactly one thread to process scores set NUM_THREADS to 1 and isCpuRelative to false.
                    /// <p/>
                    /// If the value is 1 isCpuRelative is false no additional thread will be instantiated, and all computation will be
                    /// done in the calling thread itself. The default value is 0.
        </member>
        <member name="F:Syn.Speech.Decoders.Scorer.ThreadedAcousticScorer.PropIsCpuRelative">
                    /// The property that controls whether the number of available CPUs on the system is used when determining
                    /// the number of threads to use for scoring. If true, the NUM_THREADS property is combined with the available number
                    /// of CPUS to determine the number of threads. Note that the number of threads is contained to be never lower than
                    /// zero. Also, if the number of threads is 0, the states are scored on the calling thread, no separate threads are
                    /// started. The default value is false.
        </member>
        <member name="F:Syn.Speech.Decoders.Scorer.ThreadedAcousticScorer.PropMinScoreablesPerThread">
                    /// The property that controls the minimum number of scoreables sent to a thread. This is used to prevent
                    /// over threading of the scoring that could happen if the number of threads is high compared to the size of the
                    /// active list. The default is 50
        </member>
        <member name="M:Syn.Speech.Decoders.Scorer.ThreadedAcousticScorer.#ctor(Syn.Speech.FrontEnds.BaseDataProcessor,Syn.Speech.Decoders.Scorer.IScoreNormalizer,System.Int32,System.Boolean,System.Int32,System.Int32)">
                    /// @param frontEnd
                    ///            the frontend to retrieve features from for scoring
                    /// @param scoreNormalizer
                    ///            optional post-processor for computed scores that will
                    ///            normalize scores. If not set, no normalization will applied
                    ///            and the token scores will be returned unchanged.
                    /// @param minScoreablesPerThread
                    ///            the number of threads that are used to score HMM states. If
                    ///            the isCpuRelative property is false, then is is the exact
                    ///            number of threads that are used to score HMM states. If the
                    ///            isCpuRelative property is true, then this value is combined
                    ///            with the number of available processors on the system. If you
                    ///            want to have one thread per CPU available to score states, set
                    ///            the NUM_THREADS property to 0 and the isCpuRelative to true.
                    ///            If you want exactly one thread to process scores set
                    ///            NUM_THREADS to 1 and isCpuRelative to false.
                    ///            <p/>
                    ///            If the value is 1 isCpuRelative is false no additional thread
                    ///            will be instantiated, and all computation will be done in the
                    ///            calling thread itself. The default value is 0.
                    /// @param cpuRelative
                    ///            controls whether the number of available CPUs on the system is
                    ///            used when determining the number of threads to use for
                    ///            scoring. If true, the NUM_THREADS property is combined with
                    ///            the available number of CPUS to determine the number of
                    ///            threads. Note that the number of threads is constrained to be
                    ///            never lower than zero. Also, if the number of threads is 0,
                    ///            the states are scored on the calling thread, no separate
                    ///            threads are started. The default value is false.
                    /// @param numThreads
                    ///            the minimum number of scoreables sent to a thread. This is
                    ///            used to prevent over threading of the scoring that could
                    ///            happen if the number of threads is high compared to the size
                    ///            of the active list. The default is 50
                    /// @param threadPriority
                    ///            the thread priority of scoring threads. Must be a value between
                    ///            {@link Thread#MIN_PRIORITY} and {@link Thread#MAX_PRIORITY}, inclusive.
                    ///            The default is {@link Thread#NORM_PRIORITY}.
        </member>
        <member name="T:Syn.Speech.Decoders.Search.ActiveListFactory">
            <summary>
            Creates new active lists. 
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.ActiveListFactory.PropAbsoluteBeamWidth">
            <summary>
            property that sets the desired (or target) size for this active list.  This is sometimes referred to as the beam
            size 
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.ActiveListFactory.PropRelativeBeamWidth">
            <summary>
            Property that sets the minimum score relative to the maximum score in the list for pruning.  Tokens with a score
            less than relativeBeamWidth/// maximumScore will be pruned from the list
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.ActiveListFactory.PropStrictPruning">
            <summary>
            Property that indicates whether or not the active list will implement 'strict pruning'.  When strict pruning is
            enabled, the active list will not remove tokens from the active list until they have been completely scored.  If
            strict pruning is not enabled, tokens can be removed from the active list based upon their entry scores. The
            default setting is false (disabled).
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ActiveListFactory.#ctor(System.Int32,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Decoders.Search.ActiveListFactory"/> class.
            </summary>
            <param name="absoluteBeamWidth">Width of the absolute beam.</param>
            <param name="relativeBeamWidth">Width of the relative beam.</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ActiveListFactory.NewInstance">
            <summary>
            Creates a new active list of a particular type
            </summary>
            <returns></returns>
        </member>
        <member name="T:Syn.Speech.Decoders.Search.ActiveListManager">
            <summary>
            An active list is maintained as a sorted list
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.ActiveListManager.PropAbsoluteWordBeamWidth">
            <summary>
            The property that specifies the absolute word beam width
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.ActiveListManager.PropRelativeWordBeamWidth">
            <summary>
            The property that specifies the relative word beam width
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ActiveListManager.Add(Syn.Speech.Decoders.Search.Token)">
            <summary>
            Adds the given token to the list
            </summary>
            <param name="token">The token to add.</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ActiveListManager.GetNonEmittingListIterator">
            <summary>
            Gets an Iterator of all the non-emitting ActiveLists. The iteration order is the same as the search state order.
            </summary>
            <returns>An Iterator of non-emitting ActiveLists.</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ActiveListManager.GetEmittingList">
            <summary>
            Gets the emitting ActiveList from the manager
            </summary>
            <returns>The emitting ActiveList</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ActiveListManager.ClearEmittingList">
            <summary>
            Clears emitting list in manager.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ActiveListManager.Dump">
            <summary>
            Dumps out debug info for the active list manager.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.ActiveListManager.SetNumStateOrder(System.Int32)">
            <summary>
            Sets the total number of state types to be managed
            </summary>
            <param name="numStateOrder">The total number of state types.</param>
        </member>
        <member name="T:Syn.Speech.Decoders.Search.AlternateHypothesisManager">
            <summary>
            Manager for pruned hypothesis
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.AlternateHypothesisManager.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Decoders.Search.AlternateHypothesisManager"/> class.
            </summary>
            <param name="maxEdges">The maximum edges allowed.</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.AlternateHypothesisManager.AddAlternatePredecessor(Syn.Speech.Decoders.Search.Token,Syn.Speech.Decoders.Search.Token)">
            <summary>
            Collects adds alternate predecessors for a token that would have lost because of viterbi.
            </summary>
            <param name="token">A token that has an alternate lower scoring predecessor that still might be of interest.</param>
            <param name="predecessor">A predecessor that scores lower than token.getPredecessor()..</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.AlternateHypothesisManager.GetAlternatePredecessors(Syn.Speech.Decoders.Search.Token)">
            <summary>
            Returns a list of alternate predecessors for a token..
            </summary>
            <param name="token">A token that may have alternate lower scoring predecessor that still might be of interest.</param>
            <returns>A list of predecessors that scores lower than token.getPredecessor().</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.AlternateHypothesisManager.Purge">
             <summary>
            Purge all but max number of alternate preceding token hypotheses.
             </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.NonEmittingListIterator.CheckPriorLists">
            <summary>
            Check that all lists prior to listPtr is empty.
            </summary>
            <exception cref="T:System.Exception">At while processing state order
                                        + _listPtr + , state order  + i +  not empty</exception>
        </member>
        <member name="T:Syn.Speech.Decoders.Search.PartitionActiveListFactory">
            <summary>
            A factory for PartitionActiveLists
            </summary>
        </member>
        <member name="T:Syn.Speech.Decoders.Search.Partitioner">
            <summary>
            Partitions a list of tokens according to the token score, used
            in {@link PartitionActiveListFactory}. This method is supposed 
            to provide O(n) performance so it's more preferable than 
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.Partitioner.MaxDepth">
            <summary>
            Max recursion depth
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Partitioner.EndPointPartition(Syn.Speech.Decoders.Search.Token[],System.Int32,System.Int32)">
                    /// Partitions sub-array of tokens around the end token. 
                    /// Put all elements less or equal then pivot to the start of the array,
                    /// shifting new pivot position
                     *
                    /// @param tokens the token array to partition
                    /// @param start      the starting index of the subarray
                    /// @param end      the pivot and the ending index of the subarray, inclusive
                    /// @return the index (after partitioning) of the element around which the array is partitioned
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Partitioner.MidPointPartition(Syn.Speech.Decoders.Search.Token[],System.Int32,System.Int32)">
                    /// Partitions sub-array of tokens around the x-th token by selecting the midpoint of the token array as the pivot.
                    /// Partially solves issues with slow performance on already sorted arrays.
                     *
                    /// @param tokens the token array to partition
                    /// @param start      the starting index of the subarray
                    /// @param end      the ending index of the subarray, inclusive
                    /// @return the index of the element around which the array is partitioned
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Partitioner.Partition(Syn.Speech.Decoders.Search.Token[],System.Int32,System.Int32)">
                    /// Partitions the given array of tokens in place, so that the highest scoring n token will be at the beginning of
                    /// the array, not in any order.
                     *
                    /// @param tokens the array of tokens to partition
                    /// @param size   the number of tokens to partition
                    /// @param n      the number of tokens in the final partition
                    /// @return the index of the last element in the partition
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Partitioner.FindBest(Syn.Speech.Decoders.Search.Token[],System.Int32)">
                    /// Simply find the best token and put it in the last slot
                    /// 
                    /// @param tokens array of tokens
                    /// @param size the number of tokens to partition
                    /// @return index of the best token
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Partitioner.MidPointSelect(Syn.Speech.Decoders.Search.Token[],System.Int32,System.Int32,System.Int32,System.Int32)">
                    /// Selects the token with the ith largest token score.
                     *
                    /// @param tokens       the token array to partition
                    /// @param start        the starting index of the subarray
                    /// @param end          the ending index of the subarray, inclusive
                    /// @param targetSize   target size of the partition
                    /// @param depth        recursion depth to avoid stack overflow and fall back to simple partition.
                    /// @return the index of the token with the ith largest score
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Partitioner.SimplePointSelect(Syn.Speech.Decoders.Search.Token[],System.Int32,System.Int32,System.Int32)">
                    /// Fallback method to get the partition
                     *
                    /// @param tokens       the token array to partition
                    /// @param start        the starting index of the subarray
                    /// @param end          the ending index of the subarray, inclusive
                    /// @param targetSize   target size of the partition
                    /// @return the index of the token with the ith largest score
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleActiveList.#ctor(System.Int32,System.Single)">
             Creates an empty active list
            
             @param absoluteBeamWidth    the absolute beam width
             @param logRelativeBeamWidth the relative beam width (in the log domain)
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleActiveList.Add(Syn.Speech.Decoders.Search.Token)">
             Adds the given token to the list
            
             @param token the token to add
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleActiveList.Replace(Syn.Speech.Decoders.Search.Token,Syn.Speech.Decoders.Search.Token)">
             Replaces an old token with a new token
            
             @param oldToken the token to replace (or null in which case, replace works like add).
             @param newToken the new token to be placed in the list.
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleActiveList.Purge">
             Purges excess members. Remove all nodes that fall below the relativeBeamWidth
            
             @return a (possible new) active list
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleActiveList.Iterator">
             Retrieves the iterator for this tree.
            
             @return the iterator for this token list
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleActiveList.GetTokens">
             Gets the set of all tokens
            
             @return the set of tokens
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleActiveList.GetBeamThreshold">
             gets the beam threshold best upon the best scoring token
            
             @return the beam threshold
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleActiveList.GetBestScore">
             gets the best score in the list
            
             @return the best score
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleActiveList.SetBestToken(Syn.Speech.Decoders.Search.Token)">
             Sets the best scoring token for this active list
            
             @param token the best scoring token
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleActiveList.GetBestToken">
             Gets the best scoring token for this active list
            
             @return the best scoring token
        </member>
        <member name="P:Syn.Speech.Decoders.Search.SimpleActiveList.Size">
             Returns the number of tokens on this active list
            
             @return the size of the active list
        </member>
        <member name="T:Syn.Speech.Decoders.Search.SimpleActiveListFactory">
            <summary>
            A factory for simple active lists
            </summary>
        </member>
        <member name="T:Syn.Speech.Decoders.Search.SimpleActiveListManager">
             <summary>
             A list of ActiveLists. Different token types are placed in different lists.
            
             </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.SimpleActiveListManager.PropCheckPriorListsEmpty">
            <summary>
            This property is used in the Iterator returned by the getNonEmittingListIterator() method. When the
            Iterator.next() method is called, this property determines whether the lists prior to that returned by next() are
            empty (they should be empty). If they are not empty, an Error will be thrown.
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.SimpleActiveListManager.PropActiveListFactories">
            <summary>
            The property that defines the name of the active list factory to be used by this search manager.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleActiveListManager.CreateActiveLists">
                    /// Creates the emitting and non-emitting active lists. When creating the non-emitting active lists, we will look at
                    /// their respective beam widths (eg, word beam, unit beam, state beam).
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleActiveListManager.Add(Syn.Speech.Decoders.Search.Token)">
                    /// Adds the given token to the list
                     *
                    /// @param token the token to add
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleActiveListManager.FindListFor(Syn.Speech.Decoders.Search.Token)">
                    /// Given a token find the active list associated with the token type
                     *
                    /// @param token
                    /// @return the active list
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleActiveListManager.GetEmittingList">
                    /// Returns the emitting ActiveList from the manager
                     *
                    /// @return the emitting ActiveList
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleActiveListManager.ClearEmittingList">
                    /// Clears emitting list in manager
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleActiveListManager.Dump">
            Outputs debugging info for this list manager 
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleActiveListManager.DumpList(Syn.Speech.Decoders.Search.ActiveList)">
                       /// Dumps out debugging info for the given active list
                        *
                       /// @param al the active list to dump
        </member>
        <member name="T:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager">
            <summary>
            Provides the breadth first search. To perform recognition an application should call initialize before recognition
            begins, and repeatedly call <code> recognize </code> until Result.isFinal() returns true. Once a final result has
            been obtained, <code> terminate </code> should be called.
            
            All scores and probabilities are maintained in the log math log domain.
            
            For information about breadth first search please refer to "Spoken Language Processing", X. Huang, PTR
            
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.PropLinguist">
            <summary>
            The property that defines the name of the linguist to be used by this search manager. 
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.PropPruner">
            <summary>
            The property that defines the name of the linguist to be used by this search manager.
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.PropScorer">
            <summary>
            The property that defines the name of the scorer to be used by this search manager.
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.PropActiveListFactory">
            <summary>
            The property that defines the name of the active list factory to be used by this search manager. 
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.PropShowTokenCount">
            <summary>
                    
            The property that when set to <code>true</code> will cause the recognizer to count up all the tokens in the
            active list after every frame.
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.PropRelativeWordBeamWidth">
            <summary>
            The property that sets the minimum score relative to the maximum score in the word list for pruning. Words with a
            score less than relativeBeamWidth/// maximumScore will be pruned from the list
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.PropWantEntryPruning">
            <summary>
            The property that controls whether or not relative beam pruning will be performed on the entry into a
            state.
            </summary>
        </member>
        <member name="F:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.PropGrowSkipInterval">
            <summary>
            The property that controls the number of frames processed for every time the decode growth step is skipped.
            Setting this property to zero disables grow skipping. Setting this number to a small integer will increase the
            speed of the decoder but will also decrease its accuracy. The higher the number, the less often the grow code is
            skipped.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.#ctor(Syn.Speech.Linguist.Linguist,Syn.Speech.Decoders.Pruner.IPruner,Syn.Speech.Decoders.Scorer.IAcousticScorer,Syn.Speech.Decoders.Search.ActiveListFactory,System.Boolean,System.Double,System.Int32,System.Boolean,System.Int32)">
                    /// 
                    /// @param linguist
                    /// @param pruner
                    /// @param scorer
                    /// @param activeListFactory
                    /// @param showTokenCount
                    /// @param relativeWordBeamWidth
                    /// @param growSkipInterval
                    /// @param wantEntryPruning
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.StartRecognition">
            <summary>
            Called at the start of recognition. Gets the search manager ready to recognize.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.Recognize(System.Int32)">
                    /// Performs the recognition for the given number of frames.
                     *
                    /// @param nFrames the number of frames to recognize
                    /// @return the current result or null if there is no Result (due to the lack of frames to recognize)
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.UndoLastGrowStep">
                    /// Because the growBranches() is called although no data is left after the last speech frame, the ordering of the
                    /// active-list might depend on the transition probabilities and (penalty-scores) only. Therefore we need to undo the last
                    /// grow-step up to final states or the last emitting state in order to fix the list.
                    /// @return newly created list
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.StopRecognition">
            <summary>
            Terminates a recognition
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.Recognize">
                    /// Performs recognition for one frame. Returns true if recognition has been completed.
                     *
                    /// @return <code>true</code> if recognition is completed.
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.LocalStart">
            <summary>
            Gets the initial grammar node from the linguist and creates a GrammarNodeToken.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.LocalStop">
            Local cleanup for this search manager 
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.GrowBranches">
                    /// Goes through the active list of tokens and expands each token, finding the set of successor tokens until all the
                    /// successor tokens are emitting tokens.
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.ScoreTokens">
            <summary>
            Calculate the acoustic scores for the active list. The active list should contain only emitting tokens.
            </summary>
            <returns><code>true</code> if there are more frames to score, otherwise, false</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.GetTotalTime">
                    /// Returns the total time since we start4ed
                     *
                    /// @return the total time (in seconds)
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.PruneBranches">
            <summary>
            Removes unpromising branches from the active list.
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.GetBestToken(Syn.Speech.Linguist.ISearchState)">
                    /// Gets the best token for this state
                     *
                    /// @param state the state of interest
                    /// @return the best token
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.CollectSuccessorTokens(Syn.Speech.Decoders.Search.Token)">
                    /// Collects the next set of emitting tokens from a token and accumulates them in the active or result lists
                     *
                    /// @param token the token to collect successors from
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.IsVisited(Syn.Speech.Decoders.Search.Token)">
                    /// Determines whether or not we've visited the state associated with this token since the previous frame.
                     *
                    /// @param t the token to check
                    /// @return true if we've visited the search state since the last frame
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.ShowTokenCount">
            Counts all the tokens in the active list (and displays them). This is an expensive operation. 
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.GetBestTokenMap">
                    /// Returns the best token map.
                     *
                    /// @return the best token map
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.SetBestTokenMap(Syn.Speech.Helper.HashMap{Syn.Speech.Linguist.ISearchState,Syn.Speech.Decoders.Search.Token})">
                    /// Sets the best token Map.
                     *
                    /// @param bestTokenMap the new best token Map
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.GetResultList">
                    /// Returns the result list.
                     *
                    /// @return the result list
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.Allocate">
            <summary>
            @see Search.SearchManager#allocate()
            </summary>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.CurrentFrameNumber">
                    /// Returns the current frame number.
                     *
                    /// @return the current frame number
        </member>
        <member name="P:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.GrowTimer">
                    /// Returns the Timer for growing.
                     *
                    /// @return the Timer for growing
        </member>
        <member name="P:Syn.Speech.Decoders.Search.SimpleBreadthFirstSearchManager.TokensCreated">
                    /// Returns the tokensCreated StatisticsVariable.
                     *
                    /// @return the tokensCreated StatisticsVariable.
        </member>
        <member name="T:Syn.Speech.Decoders.Search.SortingActiveListFactory">
            <summary>
            @author plamere
            </summary>
        </member>
        <member name="T:Syn.Speech.Decoders.Search.SortingActiveList">
            An active list that tries to be simple and correct. This type of active list will be slow, but should exhibit
            correct behavior. Faster versions of the ActiveList exist (HeapActiveList, TreeActiveList).
            <p/>
            This class is not thread safe and should only be used by a single thread.
            <p/>
            Note that all scores are maintained in the LogMath log base.
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SortingActiveList.#ctor(System.Int32,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Decoders.Search.SortingActiveList"/> class.
            </summary>
            <param name="absoluteBeamWidth">Width of the absolute beam.</param>
            <param name="logRelativeBeamWidth">Width of the log relative beam.</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SortingActiveList.Purge">
                       /// Purges excess members. Reduce the size of the token list to the absoluteBeamWidth
                        *
                       /// @return a (possible new) active list
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SortingActiveList.GetBeamThreshold">
                       /// gets the beam threshold best upon the best scoring token
                        *
                       /// @return the beam threshold
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SortingActiveList.GetBestScore">
                       /// gets the best score in the list
                        *
                       /// @return the best score
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SortingActiveList.SetBestToken(Syn.Speech.Decoders.Search.Token)">
                       /// Sets the best scoring token for this active list
                        *
                       /// @param token the best scoring token
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SortingActiveList.GetBestToken">
                       /// Gets the best scoring token for this active list
                        *
                       /// @return the best scoring token
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SortingActiveList.Iterator">
                       /// Retrieves the iterator for this tree.
                        *
                       /// @return the iterator for this token list
        </member>
        <member name="M:Syn.Speech.Decoders.Search.SortingActiveList.GetTokens">
                       /// Gets the list of all tokens
                        *
                       /// @return the list of tokens
        </member>
        <member name="P:Syn.Speech.Decoders.Search.SortingActiveList.Size">
                       /// Returns the number of tokens on this active list
                        *
                       /// @return the size of the active list
        </member>
        <member name="T:Syn.Speech.Decoders.Search.Token">
            <summary>
            Represents a single state in the recognition trellis. Subclasses of a token are used to represent the various
            emitting state.
            All scores are maintained in LogMath log base
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Token.#ctor(Syn.Speech.Decoders.Search.Token,Syn.Speech.Linguist.ISearchState,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Internal constructor for a token. Used by classes Token, CombineToken, ParallelToken
            </summary>
            <param name="predecessor">the predecessor for this token</param>
            <param name="state">the SentenceHMMState associated with this token</param>
            <param name="logTotalScore">the total entry score for this token (in LogMath log base)</param>
            <param name="logInsertionScore"></param>
            <param name="logLanguageScore">the language score associated with this token (in LogMath log base)</param>
            <param name="frameNumber">the frame number associated with this token</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Token.#ctor(Syn.Speech.Linguist.ISearchState,System.Int32)">
            <summary>
            Creates the initial token with the given word history depth
            </summary>
            <param name="state">the SearchState associated with this token</param>
            <param name="frameNumber">the frame number for this token</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Token.#ctor(Syn.Speech.Decoders.Search.Token,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a Token with the given acoustic and language scores and predecessor.
            </summary>
            <param name="predecessor">the predecessor Token</param>
            <param name="logTotalScore">the log acoustic score</param>
            <param name="logAcousticScore">the log language score</param>
            <param name="logInsertionScore"></param>
            <param name="logLanguageScore"></param>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Token.CalculateScore(Syn.Speech.FrontEnds.IData)">
            <summary>
            Calculates a score against the given feature. The score can be retrieved 
            with get score. The token will keep a reference to the scored feature-vector.
            </summary>
            <param name="feature">the feature to be scored</param>
            <returns>the score for the feature</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Token.NormalizeScore(System.Single)">
            <summary>
            Normalizes a previously calculated score
            </summary>
            <param name="maxLogScore">the score to normalize this score with</param>
            <returns>the normalized score</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Token.ToString">
            <summary>
            Retrieves the string representation of this object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Token.DumpTokenPath">
            <summary>
            dumps a branch of tokens 
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Token.DumpTokenPath(System.Boolean)">
            <summary>
            dumps a branch of tokens
            </summary>
            <param name="includeHmmStates">if true include all sentence hmm states</param>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Token.GetWordPath(System.Boolean,System.Boolean)">
            <summary>
            Returns the string of words leading up to this token.
            </summary>
            <param name="wantFiller">if true, filler words are added</param>
            <param name="wantPronunciations">if true append [ phoneme phoneme ... ] after each word</param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Token.GetWordPathNoFiller">
            <summary>
            Returns the string of words for this token, with no embedded filler words
            </summary>
            <returns>the string of words</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Token.GetWordPath">
            <summary>
            Returns the string of words for this token, with embedded silences
            </summary>
            <returns>the string of words</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Token.GetWordUnitPath">
            <summary>
            Returns the string of words and units for this token, with embedded silences.
            </summary>
            <returns>the string of words and units</returns>public IWord getWord() 
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Token.GetWord">
            <summary>
            Returns the word of this Token, the search state is a WordSearchState. If the search state is not a
            WordSearchState, return null.
            </summary>
            <returns>the word of this Token, or null if this is not a word token</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Token.ShowCount">
            <summary>
            Shows the token count
            </summary>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Token.Validate">
            <summary>
            Determines if this branch is valid
            </summary>
            <returns>true if the token and its predecessors are valid</returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.Token.System#Collections#Generic#IComparer{Syn#Speech#Decoders#Scorer#IScoreable}#Compare(Syn.Speech.Decoders.Scorer.IScoreable,Syn.Speech.Decoders.Scorer.IScoreable)">
             <summary>  
            A {@code Scoreable} comparator that is used to order scoreables according to their score,
             in descending order.
                 Note: since a higher score results in a lower natural order,
                 statements such as {@code Collections.min(list, Scoreable.COMPARATOR)}
                 actually return the Scoreable with the <b>highest</b> score,
                 in contrast to the natural meaning of the word "min".   
             </summary>
             <param name="t1"></param>
             <param name="t2"></param>
             <returns></returns>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.Token.Predecessor">
            <summary>
            Returns the predecessor for this token, or null if this token has no predecessors
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.Token.FrameNumber">
            <summary>
            Returns the frame number for this token. Note that for tokens that are associated with non-emitting states, the
            frame number represents the next frame number.  For emitting states, the frame number represents the current
            frame number.
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.Token.Data">
            <summary>
            Gets or sets the feature for this Token.
            </summary>
            <value>
            The data.
            </value>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.Token.Score">
            <summary>
            Gets or sets the score for the token. The score is a combination of language and acoustic scores.
            while setting the new score for the token is (in logMath log base)
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.Token.WorkingScore">
            <summary>
            Gets the working score. The working score is used to maintain non-final
            scores during the search. Some search algorithms such as bushderby use
            the working score.
            Sets the working score for this token.
            </summary>
            <value>the working score (in logMath log base)</value>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.Token.LanguageScore">
            <summary>
            Returns the language score associated with this token
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.Token.InsertionScore">
            <summary>
            Returns the insertion score associated with this token.
            Insertion score is the score of the transition between
            states. It might be transition score from the acoustic model,
            phone insertion score or word insertion probability from
            the linguist.
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.Token.AcousticScore">
            <summary>
            Returns the acoustic score for this token (in logMath log base).
            Acoustic score is a sum of frame GMM.
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.Token.SearchState">
            <summary>
            Returns the SearchState associated with this token
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.Token.IsEmitting">
            <summary>
            Determines if this token is associated with an emitting state. An emitting state is a state that can be scored
            acoustically.
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.Token.IsFinal">
            <summary>
            Determines if this token is associated with a final SentenceHMM state.
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.Token.IsWord">
            <summary>
            Determines if this token marks the end of a word
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.Token.ScoreFormat">
            <summary>
            Return the DecimalFormat object for formatting the print out of scores.
            </summary>
            <value>the DecimalFormat object for formatting score print outs</value>
        </member>
        <member name="P:Syn.Speech.Decoders.Search.Token.NumberFormat">
            <summary>
            Return the DecimalFormat object for formatting the print out of numbers
            </summary>
            <value></value>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.TokenArrayIterator.HasNext">
            <summary>
            Returns true if the iteration has more tokens.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.TokenArrayIterator.Next">
            <summary>
            Returns the next token in the iteration.
            </summary>
            <returns></returns>
            <exception cref="T:Syn.Speech.Helper.NoSuchElementException"></exception>
        </member>
        <member name="M:Syn.Speech.Decoders.Search.TokenArrayIterator.Remove">
            Unimplemented, throws an Error if called. 
        </member>
        <member name="T:Syn.Speech.FrontEnds.AutoCepstrum">
            <summary>
            Cepstrum is an auto-configurable DataProcessor which is used to compute a
            specific cepstrum (for a target acoustic model) given the spectrum. The
            Cepstrum is computed using a pipeline of front end components which are
            selected, customized or ignored depending on the feat.params file which
            characterizes the target acoustic model for which this cepstrum is computed.
            A typical legacy MFCC Cepstrum will use a MelFrequencyFilterBank, followed
            by a DiscreteCosineTransform. A typical denoised MFCC Cepstrum will use a
            MelFrequencyFilterBank, followed by a Denoise component, followed by a
            DiscreteCosineTransform2, followed by a Lifter component. The
            MelFrequencyFilterBank parameters (numberFilters, minimumFrequency and
            maximumFrequency) are auto-configured based on the values found in
            feat.params.
            @author Horia Cucu
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.AutoCepstrum.PropLoader">
            <summary>
            The property specifying the acoustic model for which this cepstrum will
            be configured. For this acoustic model (AM) it is mandatory to specify a
            location in the configuration file. The Cepstrum will be configured
            based on the feat.params file that will be found in the specified AM
            location.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.AutoCepstrum.FilterBank">
            <summary>
            The filter bank which will be used for creating the cepstrum. The filter
            bank is always inserted in the pipeline and its minimum frequency,
            maximum frequency and number of filters are configured based on the
            "lowerf", "upperf" and "nfilt" values in the feat.params file of the
            target acoustic model.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.AutoCepstrum.Denoise">
            <summary>
            The denoise component which could be used for creating the cepstrum. The
            denoise component is inserted in the pipeline only if
            "-remove_noise yes" is specified in the feat.params file of the target
            acoustic model.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.AutoCepstrum.Dct">
            <summary>
            The property specifying the DCT which will be used for creating the
            cepstrum. If "-transform legacy" is specified in the feat.params file of
            the target acoustic model or if the "-transform" parameter does not
            appear in this file at all, the legacy DCT component is inserted in the
            pipeline. If "-transform dct" is specified in the feat.params file of
            the target acoustic model, then the current DCT component is inserted in
            the pipeline.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Syn.Speech.FrontEnds.AutoCepstrum.Lifter" -->
        <member name="F:Syn.Speech.FrontEnds.AutoCepstrum.SelectedDataProcessors">
            <summary>
            The list of <code>DataProcessor</code>s which were auto-configured for
            this Cepstrum component.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.AutoCepstrum.GetData">
            <summary>
            Returns the processed Data output, basically calls <code>getData()</code> on the last processor.
            </summary>
            <returns>
            A Data object that has been processed by the cepstrum.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.FrontEnds.AutoCepstrum.ToString" -->
        <member name="P:Syn.Speech.FrontEnds.AutoCepstrum.Predecessor">
            <summary>
            Sets the predecessor for this DataProcessor. The predecessor is actually the spectrum builder.
            </summary>
            <value>
            The predecessor of this DataProcessor
            </value>
        </member>
        <member name="T:Syn.Speech.FrontEnds.DataBlocker">
            <summary>
            A <code>DataProcessor</code> which wraps incoming <code>DoubleData</code>-objects into equally size blocks of defined
            length.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.DataBlocker.PropBlockSizeMs">
            <summary>
            The property for the block size of generated data-blocks in milliseconds.
            </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.DataEndSignal">
            <summary>
            A signal that indicates the end of data.
            </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Signal">
             <summary>
              Indicates events like beginning or end of data, data dropped, quality changed, etc.. It implements the Data
             interface, and it will pass between DataProcessors to inform them about the Data that is passed between
             DataProcessors.
            
             @see Data
             @see DataProcessor
             </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Signal._props">
            <summary>
            A (lazily initialized) collection of names properties of this signal. This collection might contain infos about
            the file being processed, shift-size of frame-length of the windowing process, etc.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Signal.#ctor(System.Int64)">
            <summary>
            Constructs a Signal with the given name.
            </summary>
            <param name="time">The time this Signal is created.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Signal.GetProps">
            <summary>
            Returns the properties associated to this signal.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Syn.Speech.FrontEnds.Signal.Time">
            <summary>
            Returns the time this Signal was created.
            </summary>
            <value>The time this Signal was created</value>
        </member>
        <member name="M:Syn.Speech.FrontEnds.DataEndSignal.#ctor(System.Int64)">
            <summary>
            Constructs a DataEndSignal.
            </summary>
            <param name="duration">The duration of the entire data stream in milliseconds.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.DataEndSignal.#ctor(System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.DataEndSignal"/> class.
            </summary>
            <param name="duration">The duration of the entire data stream in milliseconds.</param>
            <param name="time">The creation time of the DataEndSignal.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.DataEndSignal.ToString">
            <summary>
             Returns the string "DataEndSignal".
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:Syn.Speech.FrontEnds.DataEndSignal.Duration">
            <summary>
            Returns the duration of the entire data stream in milliseconds
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.DataProcessingException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.DataProcessingException"/> class.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.DataProcessingException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.DataProcessingException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.DataProcessingException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.DataProcessingException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="cause">The inner exception.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.DataProcessingException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.DataProcessingException"/> class.
            </summary>
            <param name="cause">The inner exception.</param>
        </member>
        <member name="T:Syn.Speech.FrontEnds.DataStartSignal">
            <summary>
            A signal that indicates the start of data.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.DataStartSignal.SpeechTaggedFeatureStream">
            <summary>
            A constant that is attached to all DataStartSignal passing this component. This allows subsequent
            <code>DataProcessor</code>s (like the <code>Scorer</code>) to adapt their processing behavior.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.DataStartSignal.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.DataStartSignal"/> class.
            </summary>
            <param name="sampleRate">The sampling rate of the started data stream.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.DataStartSignal.#ctor(System.Int32,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.DataStartSignal"/> class.
            </summary>
            <param name="sampleRate">The sampling rate of the started data stream..</param>
            <param name="time">The time this DataStartSignal is created.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.DataStartSignal.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.DataStartSignal"/> class.
            </summary>
            <param name="sampleRate">The sampling rate of the started data stream.</param>
            <param name="tagAsVadStream"><code>true</code> if this feature stream will contain vad-signals.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.DataStartSignal.#ctor(System.Int32,System.Int64,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.DataStartSignal"/> class.
            </summary>
            <param name="sampleRate">The sampling rate of the started data stream..</param>
            <param name="time">The time this DataStartSignal is created.</param>
            <param name="tagAsVadStream"><code>true</code> if this feature stream will contain vad-signals.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.DataStartSignal.ToString">
            <summary>
            Returns the string "DataStartSignal".
            </summary>
        </member>
        <member name="P:Syn.Speech.FrontEnds.DataStartSignal.SampleRate">
            <summary>
            Gets the sampling rate of the started data stream.
            </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Denoises.Denoise">
            <summary>
            The noise filter, same as implemented in sphinxbase/sphinxtrain/pocketsphinx.
            Noise removal algorithm is inspired by the following papers Computationally
            Efficient Speech Enchancement by Spectral Minina Tracking by G. Doblinger
            Power-Normalized Cepstral Coefficients (PNCC) for Robust Speech Recognition
            by C. Kim.
            For the recent research and state of art see papers about IMRCA and A
            Minimum-Mean-Square-Error Noise Reduction Algorithm On Mel-Frequency Cepstra
            For Robust Speech Recognition by Dong Yu and others
            </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.DoubleData">
            <summary>
            A Data object that holds data of primitive type double.
            </summary>
        </member>
        <member name="T:Syn.Speech.Util.machlearn.OVector">
            <summary>
            An real-valued observation. 
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.machlearn.OVector.#ctor(System.Double[])">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Util.machlearn.OVector"/> class.
            Constructs a new observation for a given feature-vector.
            </summary>
            <param name="values">The values.</param>
        </member>
        <member name="M:Syn.Speech.Util.machlearn.OVector.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Util.machlearn.OVector"/> class. Creates a one-dimensional instance of this class
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="P:Syn.Speech.Util.machlearn.OVector.Values">
            <summary>
            Returns the values of this observation.
            </summary>
            <value>the values</value>
        </member>
        <member name="P:Syn.Speech.Util.machlearn.OVector.Dimension">
            <summary>
            Returns the dimension of this observation.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.DoubleData.#ctor(System.Double[],System.Int32,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.DoubleData"/> class.
            </summary>
            <param name="values">The data values.</param>
            <param name="sampleRate">The sample rate of the data.</param>
            <param name="firstSampleNumber">The position of the first sample in the original data.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.DoubleData.#ctor(System.Double[],System.Int32,System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.DoubleData"/> class.
            </summary>
            <param name="values">The data values.</param>
            <param name="sampleRate">The sample rate of the data.</param>
            <param name="collectTime">The time at which this data is collected.</param>
            <param name="firstSampleNumber">The position of the first sample in the original data.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.DoubleData.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents that describes the data.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:Syn.Speech.FrontEnds.DoubleData.SampleRate">
            <summary>
            Gets the sample rate of the data.
            </summary>
        </member>
        <member name="P:Syn.Speech.FrontEnds.DoubleData.FirstSampleNumber">
            <summary>
            Gets the position of the first sample in the original data. The very first sample number is zero.
            </summary>
        </member>
        <member name="P:Syn.Speech.FrontEnds.DoubleData.CollectTime">
            <summary>
            Gets the time in milliseconds at which the audio data is collected.
            </summary>
            <value>
            The difference, in milliseconds, between the time the audio data is collected and midnight, January 1, 1970
            </value>
        </member>
        <member name="T:Syn.Speech.FrontEnds.EndPoint.AbstractVoiceActivityDetector">
            <summary>
            An abstract analyzer that signals about presense of speech in last processing frame.
            This information is used in noise filtering components to estimate noise spectrum
            for example.
            </summary>
        </member>
        <member name="P:Syn.Speech.FrontEnds.EndPoint.AbstractVoiceActivityDetector.IsSpeech">
            <summary>
            Returns the state of speech detected.
            </summary>
            <value>If last processed data object was classified as speech.</value>
        </member>
        <member name="T:Syn.Speech.FrontEnds.EndPoint.ExcessiveNonSpeechPruner">
            <summary>
            Removes excessive non-speech-segments from a speech stream. 
            Compared with <code>NonSpeechDatatFilter</code> this component does not remove all non-speech frames. 
            It just reduces the non-speech parts to a user defined length.
            <see cref="T:Syn.Speech.FrontEnds.EndPoint.SpeechMarker"/>
            <see cref="T:Syn.Speech.FrontEnds.EndPoint.NonSpeechDataFilter"/>
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.EndPoint.ExcessiveNonSpeechPruner.PropMaxNonSpeechTimeMs">
            <summary>
            The property for the maximum amount of (subsequent) none-speech time (in ms) to be preserved in the speech stream.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.ExcessiveNonSpeechPruner.GetData">
            <summary>
            Returns the processed Data output.
            </summary>
            <returns>
            an Data object that has been processed by this DataProcessor
            </returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.ExcessiveNonSpeechPruner.GetAudioTime(Syn.Speech.FrontEnds.IData)">
            <summary>
            Returns the amount of audio data in milliseconds in the given SpeechClassifiedData object.
            </summary>
            <param name="data">The SpeechClassifiedData object.</param>
            <returns>The amount of audio data in milliseconds.</returns>
        </member>
        <member name="T:Syn.Speech.FrontEnds.EndPoint.NonSpeechDataFilter">
            <summary>
            Given a sequence of Data, filters out the non-speech regions. The sequence of Data should have the speech and
            non-speech regions marked out by the SpeechStartSignal and SpeechEndSignal, using the <see cref="T:Syn.Speech.FrontEnds.EndPoint.SpeechMarker"/>
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.NonSpeechDataFilter.Initialize">
            <summary>
            Initializes this DataProcessor. 
            </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.EndPoint.NonSpeechDataSingleUttFilter">
            <summary>
             Given a sequence of Data, filters out the non-speech regions. The sequence of
             Data should have the speech and non-speech regions marked out by the
            SpeechStartSignal and SpeechEndSignal, using the <see cref="T:Syn.Speech.FrontEnds.EndPoint.SpeechMarker"/>
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.NonSpeechDataSingleUttFilter.Initialize">
            <summary>
            Initializes this DataProcessor.
            </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.EndPoint.SpeechClassifiedData">
            <summary>
            A container for DoubleData class that indicates whether the contained DoubleData is speech or not. 
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechClassifiedData.#ctor(Syn.Speech.FrontEnds.DoubleData,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.EndPoint.SpeechClassifiedData"/> class.
            </summary>
            <param name="doubleData">The DoubleData.</param>
            <param name="isSpeech">Indicates whether the DoubleData is speech.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechClassifiedData.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:Syn.Speech.FrontEnds.EndPoint.SpeechClassifiedData.IsSpeech">
            <summary>
            Gets or sets a value indicating whether this SpeechClassifiedData is speech or not.
            </summary>
            <value>
              <c>true</c> if this instance is speech; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Syn.Speech.FrontEnds.EndPoint.SpeechClassifiedData.Values">
            <summary>
            Gets the data values.
            </summary>
        </member>
        <member name="P:Syn.Speech.FrontEnds.EndPoint.SpeechClassifiedData.SampleRate">
            <summary>
            Gets the sample rate of the data.
            </summary>
            <value>
            Gets the sample rate of the data.
            </value>
        </member>
        <member name="P:Syn.Speech.FrontEnds.EndPoint.SpeechClassifiedData.CollectTime">
            <summary>
            Gets the time in milliseconds at which the audio data is collected.
            </summary>
            <value>
            The difference, in milliseconds, between the time the audio data is collected and midnight, January 1, 1970.
            </value>
        </member>
        <member name="P:Syn.Speech.FrontEnds.EndPoint.SpeechClassifiedData.FirstSampleNumber">
            <summary>
            Gets the position of the first sample in the original data. The very first sample number is zero.
            </summary>
            <value>
            The position of the first sample in the original data
            </value>
        </member>
        <member name="P:Syn.Speech.FrontEnds.EndPoint.SpeechClassifiedData.DoubleData">
            <summary>
            Gets the DoubleData contained by this SpeechClassifiedData.
            </summary>
            <value>
            The DoubleData contained by this SpeechClassifiedData.
            </value>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.FrontEnds.EndPoint.SpeechClassifier" -->
        <member name="F:Syn.Speech.FrontEnds.EndPoint.SpeechClassifier.PropFrameLengthMs">
            <summary>
            The property specifying the endpointing frame length in milliseconds.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.EndPoint.SpeechClassifier.PropMinSignal">
            <summary>
            The property specifying the minimum signal level used to update the background signal level.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.EndPoint.SpeechClassifier.PropThreshold">
            <summary>
             The property specifying the threshold. If the current signal level is greater than the background level by
             this threshold, then the current signal is marked as speech. Therefore, a lower threshold will make the
             endpointer more sensitive, that is, mark more audio as speech. A higher threshold will make the endpointer less
             sensitive, that is, mark less audio as speech.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.EndPoint.SpeechClassifier.PropAdjustment">
            <summary>
            The property specifying the adjustment.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechClassifier.Initialize">
            <summary>
            Initializes this LevelTracker endpointer and DataProcessor predecessor.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechClassifier.Reset">
            <summary>
            Resets this LevelTracker to a starting state.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechClassifier.LogRootMeanSquare(System.Double[])">
            <summary>
            Returns the logarithm base 10 of the root mean square of the given samples.
            </summary>
            <param name="samples">The samples.</param>
            <returns>The calculated log root mean square in log 10.</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechClassifier.Classify(Syn.Speech.FrontEnds.DoubleData)">
            <summary>
             Classifies the given audio frame as speech or not, and updates the endpointing parameters.
            </summary>
            <param name="audio">The audio frame.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechClassifier.ResetStats">
            <summary>
            Reset statistics.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechClassifier.CollectStats(System.Boolean)">
            <summary>
            Collects the statistics to provide information about signal to noise ratio in channel.
            </summary>
            <param name="isSpeech">If the current frame is classified as speech.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechClassifier.GetData">
            <summary>
            Returns the next Data object.
            </summary>
            <returns>
            The next Data object, or null if none available.
            </returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechClassifier.GetSnr">
            <summary>
             Retrieves accumulated signal to noise ratio in dbScale.
            </summary>
            <returns>Signal to noise ratio.</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechClassifier.GetNoisy">
            <summary>
            Return the estimation if input data was noisy enough to break
            recognition. The audio is counted noisy if signal to noise ratio
            is less then -20dB.
            </summary>
            <returns>Estimation of data being noisy.</returns>
        </member>
        <member name="P:Syn.Speech.FrontEnds.EndPoint.SpeechClassifier.IsSpeech">
            <summary>
            Method that returns if current returned frame contains speech. 
            It could be used by noise filter for example to adjust noise 
            spectrum estimation.
            </summary>
            <value>
            If current frame is speech.
            </value>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.FrontEnds.EndPoint.SpeechMarker" -->
        <member name="F:Syn.Speech.FrontEnds.EndPoint.SpeechMarker.PropStartSpeech">
            <summary>
            The property for the minimum amount of time in speech (in milliseconds) to be considered as utterance start.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.EndPoint.SpeechMarker.PropEndSilence">
            <summary>
            The property for the amount of time in silence (in milliseconds) to be considered as utterance end.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.EndPoint.SpeechMarker.PropSpeechLeader">
             <summary>
            The property for the amount of time (in milliseconds) before speech start to be included as speech data.
             </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechMarker.Initialize">
            <summary>
             Initializes this SpeechMarker.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechMarker.Reset">
            <summary>
            Resets this SpeechMarker to a starting state.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechMarker.GetData">
            <summary>
            Returns the next Data object.
            </summary>
            <returns>
            The next Data object, or null if none available.
            </returns>
        </member>
        <member name="T:Syn.Speech.FrontEnds.EndPoint.WienerFilter">
            <summary>
            The noise Wiener filter. Parameters are taken from the article
            "An Effective Subband OSF-Based VAD With Noise Reduction
            for Robust Speech Recognition" by Ramirez et all. IEEE
            Transactions on Speech And Audio Processing, Vol 13, No 6, 2005
            <br />
            Subband VAD is not implemented yet, default endpointer is used.
            The frontend configuration with filtering should look like:
            <br /><br />
            &lt;item&gt;audioFileDataSource &lt;/item&gt;<br />
            &lt;item&gt;dataBlocker &lt;/item&gt;<br />
            &lt;item&gt;preemphasizer &lt;/item&gt;<br />
            &lt;item&gt;windower &lt;/item&gt;<br />
            &lt;item&gt;fft &lt;/item&gt;<br />
            &lt;item&gt;wiener &lt;/item&gt;<br />
            &lt;item&gt;speechClassifier &lt;/item&gt;<br />
            &lt;item&gt;speechMarker &lt;/item&gt;<br />
            &lt;item&gt;nonSpeechDataFilter &lt;/item&gt;<br />
            &lt;item&gt;melFilterBank &lt;/item&gt;<br />
            &lt;item&gt;dct &lt;/item&gt;<br />
            &lt;item&gt;liveCMN &lt;/item&gt;<br />
            &lt;item&gt;featureExtraction &lt;/item&gt;<br />
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.EndPoint.WienerFilter.PropClassifier">
            <summary>
            The name of the transform matrix file.
            </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Feature.AbstractFeatureExtractor">
            <summary>
            Abstract base class for windowed feature extractors like DeltasFeatureExtractor, ConcatFeatureExtractor
            or S3FeatureExtractor. The main purpose of this it to collect window size cepstra frames in a buffer
            and let the extractor compute the feature frame with them.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Feature.AbstractFeatureExtractor.PropFeatureWindow">
            The property for the window of the DeltasFeatureExtractor. 
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.AbstractFeatureExtractor.Initialize">
            <summary>
            @see Sphincs.frontend.DataProcessor#initialize(Sphinx.frontend.CommonConfig)
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.AbstractFeatureExtractor.Reset">
            <summary>
            Resets the DeltasFeatureExtractor to be ready to read the next segment of data.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.AbstractFeatureExtractor.GetData">
            <summary>
            Returns the next Data object produced by this DeltasFeatureExtractor.
            </summary>
            <returns>the next available Data object, returns null if no Data is available</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.AbstractFeatureExtractor.ProcessFirstCepstrum(Syn.Speech.FrontEnds.IData)">
            <summary>
            Replicate the given cepstrum Data object into the first window+1 number of frames in the cepstraBuffer. 
            This is the first cepstrum in the segment.
            </summary>
            <param name="cepstrum">The Data to replicate.</param>
            <returns>The number of Features that can be computed.</returns>
            <exception cref="T:System.Exception">
            Too many UTTERANCE_START
            or
            Too many UTTERANCE_START
            </exception>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.AbstractFeatureExtractor.AddCepstrum(Syn.Speech.FrontEnds.DoubleData)">
            <summary>
            Adds the given DoubleData object to the cepstraBuffer.
            </summary>
            <param name="cepstrum">The DoubleData object to add.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.AbstractFeatureExtractor.ReplicateLastCepstrum">
            <summary>
            Replicate the last frame into the last window number of frames in the cepstraBuffer.
            </summary>
            <returns>The number of replicated Cepstrum.</returns>
            <exception cref="T:System.Exception">BufferPosition</exception>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.AbstractFeatureExtractor.ComputeFeatures(System.Int32)">
            <summary>
            Converts the Cepstrum data in the cepstraBuffer into a FeatureFrame.
            </summary>
            <param name="totalFeatures">The number of Features that will be produced.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.AbstractFeatureExtractor.ComputeFeature">
            <summary>
            Computes the next Feature.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.AbstractFeatureExtractor.ComputeNextFeature">
            <summary>
            Computes the next feature. Advances the pointers as well.
            </summary>
            <returns>The feature Data computed.</returns>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Feature.BatchAGC">
            <summary>
            Applies automatic gain control (CMN)
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.BatchAGC.Initialize">
            <summary>
            Initializes this BatchCMN.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.BatchAGC.GetData">
            <summary>
            Returns the next Data object, which is a normalized cepstrum. Signal objects are returned unmodified.
            </summary>
            <returns>
            The next available Data object, returns null if no Data object is available.
            </returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.BatchAGC.ReadUtterance">
            <summary>
            Reads the cepstra of the entire Utterance into the cepstraList.
            </summary>
            <returns>The number cepstra (with Data) read.</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.BatchAGC.NormalizeList">
            <summary>
            Normalizes the list of Data.
            </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Feature.BatchCMN">
             <summary>
              Applies cepstral mean normalization (CMN), sometimes called channel mean normalization, to incoming cepstral data.
            
             Its goal is to reduce the distortion caused by the transmission channel.  The output is mean normalized cepstral
             data.
             <p/>
             The CMN processing subtracts the mean from all the {@link Data} objects between a {@link
             edu.cmu.sphinx.frontend.DataStartSignal} and a {@link DataEndSignal} or between a {@link
             edu.cmu.sphinx.frontend.endpoint.SpeechStartSignal} and a {@link SpeechEndSignal}.  BatchCMN will read in all the {@link Data}
             objects, calculate the mean, and subtract this mean from all the {@link Data} objects. For a given utterance, it will
             only produce an output after reading all the incoming data for the utterance. As a result, this process can introduce
             a significant processing delay, which is acceptable for batch processing, but not for live mode. In the latter case,
             one should use the {@link LiveCMN}.
             <p/>
             CMN is a technique used to reduce distortions that are introduced by the transfer function of the transmission
             channel (e.g., the microphone). Using a transmission channel to transmit the input speech translates to multiplying
             the spectrum of the input speech with the transfer function of the channel (the distortion).  Since the cepstrum is
             the Fourier Transform of the log spectrum, the logarithm turns the multiplication into a summation. Averaging over
             time, the mean is an estimate of the channel, which remains roughly constant. The channel is thus removed from the
             cepstrum by subtracting the mean cepstral vector. Intuitively, the mean cepstral vector approximately describes the
             spectral characteristics of the transmission channel (e.g., microphone).
            
             @see LiveCMN
             </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.BatchCMN.Initialize">
            <summary>
            Initializes this BatchCMN.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.BatchCMN.Reset">
            <summary>
            Initializes the sums array and clears the cepstra list. 
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.BatchCMN.GetData">
            <summary>
            Returns the next Data object, which is a normalized cepstrum. Signal objects are returned unmodified.
            </summary>
            <returns>the next available Data object, returns null if no Data object is available</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.BatchCMN.ReadUtterance">
            <summary>
            Reads the cepstra of the entire Utterance into the cepstraList.
            </summary>
            <returns>the number cepstra (with Data) read</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.BatchCMN.NormalizeList">
            <summary>
            Normalizes the list of Data. 
            </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Feature.BatchVarNorm">
            <summary>
             Applies cepstral variance normalization (CVN), so that each coefficient
             will have unit variance. You need to put this element after the means
             normalizer in frontend pipeline.
             <p/>
             CVN is sited to improve the stability of the decoding with the additive
             noise, so it might be useful in some situations.
             <see cref="T:Syn.Speech.FrontEnds.Feature.LiveCMN"/>
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.BatchVarNorm.Initialize">
            <summary>
            Initializes this BatchCMN.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.BatchVarNorm.Reset">
            <summary>
            Initializes the sums array and clears the cepstra list.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.BatchVarNorm.GetData">
            <summary>
            Returns the next Data object, which is a normalized cepstrum. Signal objects are returned unmodified.
            </summary>
            <returns>
            The next available Data object, returns null if no Data object is available.
            </returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.BatchVarNorm.ReadUtterance">
            <summary>
            Reads the cepstra of the entire Utterance into the cepstraList.
            </summary>
            <returns>The number cepstra (with Data) read.</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.BatchVarNorm.NormalizeList">
            <summary>
            Normalizes the list of Data.
            </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Feature.ConcatFeatureExtractor">
            <summary>
            This component concatenate the cepstrum from the sequence of frames according to the window size.
            It's not supposed to give high accuracy alone, but combined with LDA transform it can give the same
            or even better results than conventional delta and delta-delta coefficients. The idea is that
            delta-delta computation is also a matrix multiplication thus using automatically generated
            with LDA/MLLT matrix we can gain better results.
            The model for this feature extractor should be trained with SphinxTrain with 1s_c feature type and
            with cepwin option enabled. Don't forget to set the window size accordingly.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.ConcatFeatureExtractor.ComputeNextFeature">
            <summary>
            Computes the next feature. Advances the pointers as well.
            </summary>
            <returns>
            The feature Data computed.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.FrontEnds.Feature.DeltasFeatureExtractor" -->
        <member name="M:Syn.Speech.FrontEnds.Feature.DeltasFeatureExtractor.#ctor(System.Int32)">
                     *
                    /// @param window
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.DeltasFeatureExtractor.ComputeNextFeature">
            <summary>
            Computes the next feature. Advances the pointers as well.
            </summary>
            <returns>
            The feature Data computed.
            </returns>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Feature.FeatureTransform">
             <summary>
             Implements a linear feature transformation transformation.
            
             It might be a dimension reduction or just a decorrelation transform. This
             component requires a special model trained with LDA/MLLT transform.
             </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Feature.FeatureTransform.PropLoader">
            <summary>
            The name of the transform matrix file.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.FeatureTransform.GetData">
            <summary>
            Returns the next Data object being processed by this LDA, or if it is a Signal, it is returned without modification.
            </summary>
            <returns>
            The next available Data object, returns null if no Data object is available.
            </returns>
            <exception cref="T:System.ArgumentException">dimenstion mismatch</exception>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Feature.FrameDropper">
            <summary>
             Drops certain feature frames, usually to speed up decoding. For example, if you 'dropEveryNthFrame' is set to 2, it
             will drop every other feature frame. If you set 'replaceNthWithPrevious' to 3, then you replace with 3rd frame with
             the 2nd frame, the 6th frame with the 5th frame, etc..
             </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Feature.FrameDropper.PropDropEveryNthFrame">
            <summary>
            The property that specifies dropping one in every Nth frame. If N=2, we drop every other frame. If N=3, we drop every third frame, etc..
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Feature.FrameDropper.PropReplaceNthWithPrevious">
            <summary>
            The property that specifies whether to replace the Nth frame with the previous frame.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.FrameDropper.Initialize">
            <summary>
            Initializes this FrameDropper.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.FrameDropper.GetData">
            <summary>
            Returns the next Data object from this FrameDropper. The Data objects belonging to a single Utterance should be preceded by a DataStartSignal and ended by a DataEndSignal.
            </summary>
            <returns>
            The next available Data object, returns null if no Data object is available.
            </returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.FrameDropper.ReadData">
            <summary>
            Read a Data object from the predecessor DataProcessor, and increment the ID count appropriately.
            </summary>
            <returns>The read Data object.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.FrontEnds.Feature.LiveCMN" -->
        <member name="F:Syn.Speech.FrontEnds.Feature.LiveCMN.PropInitialCMNWindow">
            <summary>
            The property for the live CMN initial window size.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Feature.LiveCMN.PropCMNWindow">
            <summary>
            The property for the live CMN window size.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Feature.LiveCMN.PropCMNShiftWindow">
            <summary>
            The property for the CMN shifting window. The shifting window specifies
            how many cepstrum after which we re-calculate the cepstral mean.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.LiveCMN.Initialize">
            <summary>
            Initializes this LiveCMN.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.LiveCMN.InitMeansSums">
            <summary>
            Initializes the currentMean and sum arrays with the given cepstrum
            length.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.LiveCMN.GetData">
            <summary>
            Returns the next Data object, which is a normalized Data produced by this
            class. Signals are returned unmodified.
            </summary>
            <returns>
            The next available Data object, returns null if no Data object is available.
            </returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.LiveCMN.Normalize(Syn.Speech.FrontEnds.IData)">
            <summary>
            Normalizes the given Data with using the currentMean array. Updates the
            sum array with the given Data.
            </summary>
            <param name="data">The Data object to normalize.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.LiveCMN.UpdateMeanSumBuffers">
            <summary>
            Updates the currentMean buffer with the values in the sum buffer. Then
            decay the sum buffer exponentially, i.e., divide the sum with
            numberFrames.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Feature.LiveCMN.MultiplyArray(System.Double[],System.Double)">
            <summary>
            Multiplies each element of the given array by the multiplier.
            </summary>
            <param name="array">The array to multiply.</param>
            <param name="multiplier">The amount to multiply by.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.FrontEnds.Feature.S3FeatureExtractor" -->
        <member name="M:Syn.Speech.FrontEnds.Feature.S3FeatureExtractor.ComputeNextFeature">
            <summary>
            Computes the next feature. Advances the pointers as well.
            </summary>
            <returns>
            The feature Data computed.
            </returns>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Filter.Dither">
            <summary>
            Implements a dither for the incoming packet. A small amount of random noise is added
            to the signal to avoid floating point errors and prevent the energy from
            being zero. <p/> Other {@link Data} objects are passed along unchanged through
            this Dither processor. <p/> See also {@link EnergyFilter}, an alternative to Dither.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Filter.Dither.PropMaxDither">
            <summary>
            The maximal value which could be added/subtracted to/from the signal.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Filter.Dither.PropMaxVal">
            <summary>
            The maximal value of dithered values.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Filter.Dither.PropMinVal">
            <summary>
            The minimal value of dithered values.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Filter.Dither.PropUseRandseed">
            <summary>
            The property about using random seed or not.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Filter.Dither.GetData">
            <summary>
            Returns the next DoubleData object, which is a dithered version of the input.
            </summary>
            <returns>
            The next available DoubleData object, or null if no Data is available.
            </returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Filter.Dither.Process(Syn.Speech.FrontEnds.IData)">
            <summary>
            rocess data, adding dither.
            </summary>
            <param name="input">The input.</param>
            <returns></returns>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Filter.EnergyFilter">
            <summary>
            EnergyFilter silently drops zero energy frames from the stream. This is a deterministic alternative to <see cref="T:Syn.Speech.FrontEnds.Filter.Dither"/>
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Filter.EnergyFilter.PropMaxEnergy">
            If energy is below this threshold frame is dropped 
        </member>
        <member name="M:Syn.Speech.FrontEnds.Filter.EnergyFilter.GetData">
            <summary>
            Returns the next DoubleData object, skipping frames with zero energy.
            </summary>
            <returns>
            The next available DoubleData object, or null if no Data is available.
            </returns>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Filter.Preemphasizer">
             <summary>
             Implements a high-pass filter that compensates for attenuation in the audio data. Speech signals have an attenuation
             (a decrease in intensity of a signal) of 20 dB/dec. It increases the relative magnitude of the higher frequencies
             with respect to the lower frequencies.
            
             The Preemphasizer takes a {@link Data}object that usually represents audio data as input, and outputs the same {@link
             Data}object, but with preemphasis applied. For each value X[i] in the input Data object X, the following formula is
             applied to obtain the output Data object Y:
                 
             <code> Y[i] = X[i] - (X[i-1]/// preemphasisFactor) </code>
             
             where 'i' denotes time.
             
             The preemphasis factor has a value defined by the field {@link #PROP_PREEMPHASIS_FACTOR} of 0.97. A common value for
             this factor is something around 0.97.
             
             Other {@link Data}objects are passed along unchanged through this Preemphasizer.
             <p/>
             The Preemphasizer emphasizes the high frequency components, because they usually contain much less energy than lower
             frequency components, even though they are still important for speech recognition. It is a high-pass filter because
             it allows the high frequency components to "pass through", while weakening or filtering out the low frequency
             components.
             </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Filter.Preemphasizer.PropPreemphasisFactor">
            The property for preemphasis factor/alpha. 
        </member>
        <member name="M:Syn.Speech.FrontEnds.Filter.Preemphasizer.GetData">
            <summary>
            Returns the next Data object being processed by this Preemphasizer, or if it is a Signal, it is returned without
            modification.
            </summary>
            <returns>the next available Data object, returns null if no Data object is available</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Filter.Preemphasizer.ApplyPreemphasis(System.Double[])">
            <summary>
            Applies pre-emphasis filter to the given Audio. The preemphasis is applied in place.
            </summary>
            <param name="_in">audio data</param>
        </member>
        <member name="T:Syn.Speech.FrontEnds.FloatData">
            <summary>
            A Data object that holds data of primitive type float.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FloatData.#ctor(System.Single[],System.Int32,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.FloatData"/> class.
            </summary>
            <param name="values">The data values.</param>
            <param name="sampleRate">The sample rate of the data.</param>
            <param name="firstSampleNumber">The position of the first sample in the original data.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FloatData.#ctor(System.Single[],System.Int32,System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.FloatData"/> class.
            </summary>
            <param name="values">The data values.</param>
            <param name="sampleRate">The sample rate of the data.</param>
            <param name="collectTime">The time at which this data is collected.</param>
            <param name="firstSampleNumber">The position of the first sample in the original data.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FloatData.ToFloatData(Syn.Speech.FrontEnds.IData)">
            Converts a given Data-object into a <code>FloatData</code> if possible.
                    ///  @param data
        </member>
        <member name="P:Syn.Speech.FrontEnds.FloatData.Values">
            <summary>
            Gets the values of this data.
            </summary>
        </member>
        <member name="P:Syn.Speech.FrontEnds.FloatData.SampleRate">
            <summary>
            Gets the sample rate of this data.
            </summary>
        </member>
        <member name="P:Syn.Speech.FrontEnds.FloatData.FirstSampleNumber">
            <summary>
            Gets the position of the first sample in the original data. The very first sample number is zero.
            </summary>
        </member>
        <member name="P:Syn.Speech.FrontEnds.FloatData.CollectTime">
            <summary>
            Gets the time in milliseconds at which the audio data is collected.
            </summary>
            <value>
            the difference, in milliseconds, between the time the audio data is collected and midnight, January 1, 1970
            </value>
        </member>
        <member name="T:Syn.Speech.FrontEnds.FrequencyWarp.FrequencyWarper">
            <summary>
             Defines the Bark frequency warping function. This class provides methods to convert frequencies from a linear scale
             to the bark scale. The bark scale is originated from measurements of the critical bandwidth. Please find more details
             in books about psychoacoustics or speech analysis/recognition.
             @author <a href="mailto:rsingh@cs.cmu.edu">rsingh</a>
             @version 1.0
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.FrequencyWarper.HertzToBark(System.Double)">
            <summary>
            Compute Bark frequency from linear frequency in Hertz.The function is:bark = 6.0*log(hertz/600 + sqrt((hertz/600)^2 + 1)).
            </summary>
            <param name="hertz">The input frequency in Hertz.</param>
            <returns>The frequency in a Bark scale</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.FrequencyWarper.BarkToHertz(System.Double)">
            <summary>
            Compute linear frequency in Hertz from Bark frequency. The function is: hertz = 300*(exp(bark/6.0) - exp(-bark/6.0))
            </summary>
            <param name="bark">The input frequency in Barks.</param>
            <returns>The frequency in Hertz.</returns>
        </member>
        <member name="T:Syn.Speech.FrontEnds.FrequencyWarp.LinearPredictor">
            <summary>
            Computes the linear predictive model using the Levinson-Durbin algorithm. Linear prediction assumes that a signal can
            be model as a linear combination of previous samples, that is, the current sample x[i] can be modeled as:
            <p/>
            <pre> x[i] = a[0] + a[1] /// x[i - 1] + a[2] /// x[i - 2] + ... </pre>
            <p/>
            The summation on the right hand side of the equation involves a finite number of terms. The number of previous
            samples used is the order of the linear prediction.
            <p/>
            This class also provides a method to compute LPC cepstra, that is, the cepstra computed from LPC coefficients, as
            well as a method to compute the bilinear transformation of the LPC
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.LinearPredictor.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.FrequencyWarp.LinearPredictor"/> class with the given order.
            </summary>
            <param name="order">The order of the LinearPredictor.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.LinearPredictor.GetARFilter(System.Double[])">
            <summary>
            Method to compute Linear Prediction Coefficients for a frame of speech. Assumes the following sign convention:<br> prediction(x[t]) = Sum_i {Ar[i] * x[t-i]}</br>
            </summary>
            <param name="autocor">The autocor.</param>
            <returns>The energy of the frame (alpha in the Levinson recursion).</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.LinearPredictor.ReflectionCoeffsToArParameters(System.Double[],System.Int32)">
            <summary>
            Computes AR parameters from a given set of reflection coefficients.
            </summary>
            <param name="rc">Double array of reflection coefficients. The RC array must begin at 1 (RC[0] is a dummy value).</param>
            <param name="lpcorder">AR order desired.</param>
            <returns>AR parameters</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.FrontEnds.FrequencyWarp.LinearPredictor.GetData(System.Int32)" -->
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.LinearPredictor.GetBilinearCepstra(System.Double,System.Int32)">
            <summary>
            Computes a bi-linear frequency warped version of the LPC cepstrum from the LPC cepstrum. The recursive algorithm
            used is defined in Oppenheim's paper in Proceedings of IEEE, June 1972 The program has been written using g[x,y]
            = g_o[x,-y] where g_o is the array used by Oppenheim. To handle the reversed array index the recursion has been
            done DOWN the array index.
            </summary>
            <param name="warp">The warping coefficient. For 16KHz speech 0.6 is good valued..</param>
            <param name="nbilincepstra">The number of bilinear cepstral values to be computed from the linear frequencycepstrum.</param>
            <returns>A bi-linear frequency warped version of the LPC cepstrum.</returns>
        </member>
        <member name="T:Syn.Speech.FrontEnds.FrequencyWarp.MelFilter">
             <summary>
             /**
             Defines a triangular mel-filter. The {@link edu.cmu.sphinx.frontend.frequencywarp.MelFrequencyFilterBank} creates
             mel-filters and filters spectrum data using the method {@link #filterOutput(double[]) filterOutput}.
             <p/>
             A mel-filter is a triangular shaped bandpass filter.  When a mel-filter is constructed, the parameters
             <code>leftEdge</code>, <code>rightEdge</code>, <code>centerFreq</code>, <code>initialFreq</code>, and
             <code>deltaFreq</code> are given to the {@link MelFilter Constructor}. The first three arguments to the constructor,
             i .e. <code>leftEdge</code>, <code>rightEdge</code>, and <code>centerFreq</code>, specify the filter's slopes. The
             total area under the filter is 1. The filter is shaped as a triangle. Knowing the distance between the center
             frequency and each of the edges, it is easy to compute the slopes of the two sides in the triangle - the third side
             being the frequency axis. The last two arguments, <code>initialFreq</code> and <code>deltaFreq</code>, identify the
             first frequency bin that falls inside this filter and the spacing between successive frequency bins. All frequencies
             here are considered in a linear scale.
             <p/>
             </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.MelFilter.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructs a filter from the parameters.
            <p/>
            In the current implementation, the filter is a bandpass filter with a triangular shape.  We're given the left and
            right edges and the center frequency, so we can determine the right and left slopes, which could be not only
            asymmetric but completely different. We're also given the initial frequency, which may or may not coincide with
            the left edge, and the frequency step.
            </summary>
            <param name="leftEdge">The filter's lowest passing frequency.</param>
            <param name="centerFreq">The filter's center frequency.</param>
            <param name="rightEdge">The filter's highest passing frequency.</param>
            <param name="initialFreq">The first frequency bin in the pass band.</param>
            <param name="deltaFreq">The step in the frequency axis between frequency bins.</param>
            <exception cref="T:System.ArgumentException">
            deltaFreq has zero value
            or
            Filter boundaries too close
            or
            Number of elements in mel
                                    +  is zero.
            </exception>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.MelFilter.FilterOutput(System.Double[])">
            <summary>
            Compute the output of a filter. We're given a power spectrum, to which we apply the appropriate weights.
            </summary>
            <param name="spectrum">The input power spectrum to be filtered.</param>
            <returns>The filtered value, in fact a weighted average of power in the frequency range of the filter pass band.</returns>
        </member>
        <member name="T:Syn.Speech.FrontEnds.FrequencyWarp.MelFilter2">
             <summary>
             Defines a triangular mel-filter.
             The {@link MelFrequencyFilterBank2} creates mel-filters and filters spectrum
             data using the method {@link #filterOutput(double[]) filterOutput}.
            
             A mel-filter is a triangular shaped bandpass filter. When a mel-filter is
             constructed, the parameters <code>leftEdge</code>, <code>rightEdge</code>,
             <code>centerFreq</code>, <code>initialFreq</code>, and
             <code>deltaFreq</code> are given to the {@link MelFilter2 Constructor}. The
             first three arguments to the constructor, i.e. <code>leftEdge</code>,
             <code>rightEdge</code>, and <code>centerFreq</code>, specify the filter's
             slopes. The total area under the filter is 1. The filter is shaped as a
             triangle. Knowing the distance between the center frequency and each of the
             edges, it is easy to compute the slopes of the two sides in the triangle -
             the third side being the frequency axis. The last two arguments,
             <code>initialFreq</code> and <code>deltaFreq</code>, identify the first
             frequency bin that falls inside this filter and the spacing between
             successive frequency bins. All frequencies here are considered in a linear
             scale.
             
             <see cref="T:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank2"/>
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank" -->
        <member name="F:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank.PropNumberFilters">
             <summary>
            The property for the number of filters in the filterbank.
             </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank.PropMinFreq">
            <summary>
            The property for the minimum frequency covered by the filterbank.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank.PropMaxFreq">
            <summary>
            The property for the maximum frequency covered by the filterbank.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank.LinToMelFreq(System.Double)">
            <summary>
            Compute mel frequency from linear frequency.
            <para>Since we don't have <code>log10()</code>, we have to compute it using natural log: <b>log10(x) = ln(x) / ln(10)</b></para>
            </summary>
            <param name="inputFreq">The input frequency in linear scale.</param>
            <returns>The frequency in a mel scale.</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank.MelToLinFreq(System.Double)">
            <summary>
            Compute linear frequency from mel frequency.
            </summary>
            <param name="inputFreq">The input frequency in mel scale.</param>
            <returns>The frequency in a linear scale.</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank.SetToNearestFrequencyBin(System.Double,System.Double)">
            <summary>
            Sets the given frequency to the nearest frequency bin from the FFT. The FFT can be thought of as a sampling of
            the actual spectrum of a signal. We use this function to find the sampling point of the spectrum that is closest
            to the given frequency.
            </summary>
            <param name="inFreq">The input frequency.</param>
            <param name="stepFreq">The distance between frequency bins.</param>
            <returns>The closest frequency bin.</returns>
            <exception cref="T:System.ArgumentException">stepFreq is zero</exception>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank.BuildFilterbank(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Build a mel filterbank with the parameters given. Each filter will be shaped as a triangle. The triangles overlap
            so that they cover the whole frequency range requested. The edges of a given triangle will be by default at the
            center of the neighboring triangles.
            </summary>
            <param name="numberFftPoints">Number of points in the power spectrum.</param>
            <param name="numberFilters">The number of filters in the filterbank.</param>
            <param name="minFreq">The lowest frequency in the range of interest.</param>
            <param name="maxFreq">The highest frequency in the range of interest.</param>
            <exception cref="T:System.ArgumentException">
            Number of FFT points is zero
            or
            Number of filters illegal: 
                                    + numberFilters
            </exception>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank.Process(Syn.Speech.FrontEnds.DoubleData)">
            <summary>
            Process data, creating the power spectrum from an input audio frame.
            </summary>
            <param name="input">input power spectrum</param>
            <returns>power spectrum</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank.GetData">
            <summary>
            Reads the next Data object, which is the power spectrum of an audio input frame. 
            Signals are returned unmodified.
            </summary>
            <returns>the next available Data or Signal object, or returns null if no Data is available</returns>
        </member>
        <member name="T:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank2">
            <summary>
            Filters an input power spectrum through a bank of number of mel-filters. The
            output is an array of filtered values, typically called mel-spectrum, each
            corresponding to the result of filtering the input spectrum through an
            individual filter. Therefore, the length of the output array is equal to the
            number of filters created.
            </summary>
            <see cref="T:Syn.Speech.FrontEnds.FrequencyWarp.MelFilter2"/>
        </member>
        <member name="F:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank2.PropNumberFilters">
            <summary>
            The property for the number of filters in the filterbank.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank2.PropMinFreq">
            <summary>
            The property for the minimum frequency covered by the filterbank.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank2.PropMaxFreq">
            <summary>
            The property for the maximum frequency covered by the filterbank.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank2.LinearToMel(System.Double)">
            <summary>
            Compute mel frequency from linear frequency.
            </summary>
            <param name="inputFreq">The input frequency in linear scale.</param>
            <returns>The frequency in a mel scale.</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank2.BuildFilterbank(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Build a mel filterbank with the parameters given. Each filter will be  shaped as a triangle. The triangles overlap so that they cover the whole
            frequency range requested. The edges of a given triangle will be by default at the center of the neighboring triangles.
            </summary>
            <param name="windowLength">Number of points in the power spectrum.</param>
            <param name="numberFilters">Bumber of filters in the filterbank.</param>
            <param name="minFreq">The lowest frequency in the range of interest.</param>
            <param name="maxFreq">The highest frequency in the range of interest.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank2.Process(Syn.Speech.FrontEnds.DoubleData)">
            <summary>
            Process data, creating the power spectrum from an input audio frame.
            </summary>
            <param name="input">The input power spectrum.</param>
            <returns>power spectrum</returns>
            <exception cref="T:System.ArgumentException">Window size is incorrect: in.length == 
                                    + values.Length
                                    + , numberFftPoints == 
                                    + ((windowLength &gt;&gt; 1) + 1)</exception>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.MelFrequencyFilterBank2.GetData">
            <summary>
            Reads the next Data object, which is the power spectrum of an audio input frame. Signals are returned unmodified.
            </summary>
            <returns>
            The next available Data or Signal object, or returns null if no Data is available.
            </returns>
        </member>
        <member name="T:Syn.Speech.FrontEnds.FrequencyWarp.PLPCepstrumProducer">
            <summary>
            Computes the PLP cepstrum from a given PLP Spectrum. The power spectrum has the amplitude compressed by computing the
            cubed root of the PLP spectrum.  This operation is an approximation to the power law of hearing and simulates the
            non-linear relationship between sound intensity and perceived loudness.  Computationally, this operation is used to
            reduce the spectral amplitude of the critical band to enable all-pole modeling with relatively low order AR filters.
            The inverse discrete cosine transform (IDCT) is then applied to the autocorrelation coefficients. A linear prediction
            filter is then estimated from the autocorrelation values, and the linear prediction cepstrum (LPC cepstrum) is
            finally computed from the LP filter.
             @author <a href="mailto:rsingh@cs.cmu.edu">rsingh</a>
            </summary>
            <see cref="T:Syn.Speech.FrontEnds.FrequencyWarp.LinearPredictor"/>
        </member>
        <member name="F:Syn.Speech.FrontEnds.FrequencyWarp.PLPCepstrumProducer.PropNumberFilters">
            <summary>
            The property for the number of filters in the filter bank.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.FrequencyWarp.PLPCepstrumProducer.PropCepstrumLength">
            <summary>
            The property specifying the length of the cepstrum data.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.FrequencyWarp.PLPCepstrumProducer.PropLpcOrder">
            <summary>
            The property specifying the LPC order.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.PLPCepstrumProducer.Initialize">
            <summary>
            Constructs a PLPCepstrumProducer.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.PLPCepstrumProducer.ComputeCosine">
            <summary>
            Compute the Cosine values for IDCT.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.PLPCepstrumProducer.PowerLawCompress(System.Double[])">
            <summary>
            Applies the intensity loudness power law. This operation is an approximation to the power law of hearing and
            simulates the non-linear relationship between sound intensity and percieved loudness. Computationally, this
            operation is used to reduce the spectral amplitude of the critical band to enable all-pole modeling with
            relatively low order AR filters.
            </summary>
            <param name="inspectrum">The inspectrum.</param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.PLPCepstrumProducer.GetData">
            <summary>
            Returns the next Data object, which is the PLP cepstrum of the input frame. 
            However, it can also be other Data objects like a EndPointSignal.
            </summary>
            <returns>
            The next available Data object, returns null if no Data object is available.
            </returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.PLPCepstrumProducer.Process(Syn.Speech.FrontEnds.DoubleData)">
            <summary>
            Process data, creating the PLP cepstrum from an input audio frame.
            </summary>
            <param name="input">A PLP Spectrum frame.</param>
            <returns>a PLP Data frame</returns>
            <exception cref="T:System.ArgumentException">PLPSpectrum size is incorrect: plpspectrum.length ==  +
                                        plpspectrum.Length + , numberPLPFilters ==  +
                                        _numberPlpFilters</exception>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.PLPCepstrumProducer.ApplyCosine(System.Double[])">
            <summary>
            Compute the discrete Cosine transform for the given power spectrum.
            </summary>
            <param name="plpspectrum">The PLPSpectrum data.</param>
            <returns></returns>
        </member>
        <member name="T:Syn.Speech.FrontEnds.FrequencyWarp.PLPFilter">
             Defines a filter used by the {@link PLPFrequencyFilterBank} class. The filter is defined by a function in the {@link
             #PLPFilter Constructor}. A set of equally spaced frequencies in a linear scale is passed to the constructor, which
             returns the weights for each of the frequency bins, such that the filter has the shape defined by this piecewise
             function in the bark scale.
            
             @author <a href="mailto:rsingh@cs.cmu.edu">rsingh</a>
             @version 1.0
             @see PLPFrequencyFilterBank
        </member>
        <member name="F:Syn.Speech.FrontEnds.FrequencyWarp.PLPFilter.CenterFreqInHz">
            <summary>
            The center frequency of the filter in Hertz. 
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.FrequencyWarp.PLPFilter.CenterFreqInBark">
            <summary>
            The center frequency of the filter in Bark.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.FrontEnds.FrequencyWarp.PLPFilter.#ctor(System.Double[],System.Double)" -->
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.PLPFilter.FilterOutput(System.Double[])">
            <summary>
            Compute the PLP spectrum at the center frequency of this filter for a given power spectrum.
            </summary>
            <param name="spectrum">The input power spectrum to be filtered.</param>
            <returns>The PLP spectrum value</returns>
            <exception cref="T:System.ArgumentException">Mismatch in no. of DFT points  + spectrum.Length +
                                             in spectrum and in filter  + _numDftPoints</exception>
        </member>
        <member name="T:Syn.Speech.FrontEnds.FrequencyWarp.PLPFrequencyFilterBank">
            <summary>
            Filters an input power spectrum through a PLP filterbank. The filters in the filterbank are placed in the frequency
            axis so as to mimic the critical band, representing different perceptual effect at different frequency bands. The
            filter outputs are also scaled for equal loudness preemphasis. The filter shapes are defined by the {@link PLPFilter}
            class. Like the {@link MelFrequencyFilterBank2}, this filter bank has characteristics defined by the {@link
            #PROP_NUMBER_FILTERS number of filters}, the {@link #PROP_MIN_FREQ minimum frequency}, and the {@link #PROP_MAX_FREQ
            maximum frequency}. Unlike the {@link MelFrequencyFilterBank2}, the minimum and maximum frequencies here refer to the
            <b>center</b> frequencies of the filters located at the leftmost and rightmost positions, and not to the edges.
            Therefore, this filter bank spans a frequency range that goes beyond the limits suggested by the minimum and maximum
            frequencies.
            @author <a href="mailto:rsingh@cs.cmu.edu">rsingh</a>
            @version 1.0
            @see PLPFilter
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.FrequencyWarp.PLPFrequencyFilterBank.PropNumberFilters">
            <summary>
            The property for the number of filters in the filterbank.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.FrequencyWarp.PLPFrequencyFilterBank.PropMinFreq">
            <summary>
            The property for the center frequency of the lowest filter in the filterbank.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.FrequencyWarp.PLPFrequencyFilterBank.PropMaxFreq">
            <summary>
            The property for the center frequency of the highest filter in the filterbank.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.PLPFrequencyFilterBank.Initialize">
            <summary>
            Initializes this PLPFrequencyFilterBank object.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.PLPFrequencyFilterBank.BuildCriticalBandFilterbank">
             Build a PLP filterbank with the parameters given. The center frequencies of the PLP filters will be uniformly
             spaced between the minimum and maximum analysis frequencies on the Bark scale. on the Bark scale.
            
             @throws IllegalArgumentException
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.PLPFrequencyFilterBank.LoudnessScalingFunction(System.Double)">
            This function return the equal loudness preemphasis factor at any frequency. The preemphasis function is given
            by
            <p/>
            E(w) = f^4 / (f^2 + 1.6e5) ^ 2 * (f^2 + 1.44e6) / (f^2 + 9.61e6)
            <p/>
            This is more modern one from HTK, for some reason it's preferred over old variant, and 
            it doesn't require conversion to radians
            <p/>
            E(w) = (w^2+56.8e6)*w^4/((w^2+6.3e6)^2(w^2+0.38e9)(w^6+9.58e26))
            <p/>
            where w is frequency in radians/second
            @param freq
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.PLPFrequencyFilterBank.BuildEqualLoudnessScalingFactors">
            <summary>
            Create an array of equal loudness preemphasis scaling terms for all the filters.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.PLPFrequencyFilterBank.Process(Syn.Speech.FrontEnds.DoubleData)">
            <summary>
            Process data, creating the power spectrum from an input audio frame.
            </summary>
            <param name="input">Input power spectrum.</param>
            <returns>PLP power spectrum</returns>
            <exception cref="T:System.ArgumentException">Window size is incorrect: in.length ==  + values.Length +, numberFftPoints ==  + ((_numberFftPoints &gt;&gt; 1) + 1)</exception>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrequencyWarp.PLPFrequencyFilterBank.GetData">
            <summary>
            Reads the next Data object, which is the power spectrum of an audio input frame. 
            However, it can also be other Data objects like a Signal, which is returned unmodified.
            </summary>
            <returns>
            The next available Data object, returns null if no Data object is available.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.FrontEnds.FrontEnd" -->
        <member name="F:Syn.Speech.FrontEnds.FrontEnd.PropPipeline">
            <summary>
            the name of the property list of all the components of the frontend pipe line 
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrontEnd.NewProperties(Syn.Speech.Util.Props.PropertySheet)">
            <summary>
            @see Configurable#newProperties(sphincs.util.props.PropertySheet)
            </summary>
            <param name="ps"></param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrontEnd.Initialize">
            <summary>
            @see Sphincs.FrontEnd.DataProcessor#initialize(Sphincs.FrontEnd.CommonConfig)
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrontEnd.SetDataSource(Syn.Speech.FrontEnds.IDataProcessor)">
                    /// Sets the source of data for this front end. It basically sets the predecessor of the first DataProcessor of this
                    /// front end.
                     *
                    /// @param dataSource the source of data
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrontEnd.GetElements">
            Returns the collection of <code>DataProcessor</code>s which setup this <code>FrontEnd</code>.
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrontEnd.GetData">
            <summary>
            Returns the processed Data output, basically calls <code>getData()</code> on the last processor.
            </summary>
            <returns>an Data object that has been processed by this front end</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrontEnd.AddSignalListener(Syn.Speech.FrontEnds.ISignalListener)">
            <summary>
            Add a listener to be called when a signal is detected.
            </summary>
            <param name="listener">The listener to be added.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrontEnd.RemoveSignalListener(Syn.Speech.FrontEnds.ISignalListener)">
            <summary>
            Removes a listener for signals.
            </summary>
            <param name="listener">The listener the listener to be removed.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.FrontEnd.FireSignalListeners(Syn.Speech.FrontEnds.Signal)">
            <summary>
            Fire all listeners for signals.
            </summary>
            <param name="signal">Signal the signal that occurred.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.FrontEnds.FrontEnd.ToString" -->
        <member name="P:Syn.Speech.FrontEnds.FrontEnd.Predecessor">
            <summary>
            Sets the source of data for this front end. It basically calls <code>setDataSource(dataSource)</code>.
            </summary>
        </member>
        <member name="P:Syn.Speech.FrontEnds.FrontEnd.LastDataProcessor">
            <summary>
            Gets the last data processor within the <code>DataProcessor</code> chain of this <code>FrontEnd</code>.
            </summary>
            <value></value>
        </member>
        <member name="T:Syn.Speech.FrontEnds.GainControlProcessor">
             Allows to modify the gain of an audio-signal.  If the gainFactor is 1 the signal passes this
             <code>DataProcessor</code> unchanged.
            
             @author Holger Brandl
        </member>
        <member name="T:Syn.Speech.FrontEnds.ISignalListener">
            <summary>
            The listener interface for being informed when a {@link Signal Signal} is generated.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.ISignalListener.SignalOccurred(Syn.Speech.FrontEnds.Signal)">
            <summary>
            Method called when a signal is detected.
            </summary>
            <param name="signal">The signal.</param>
        </member>
        <member name="T:Syn.Speech.FrontEnds.EndPoint.SpeechEndSignal">
            <summary>
            A signal that indicates the end of speech.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechEndSignal.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.EndPoint.SpeechEndSignal"/> class.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechEndSignal.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.EndPoint.SpeechEndSignal"/> class with the given creation time.
            </summary>
            <param name="time">Time the creation time of the SpeechEndSignal.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechEndSignal.ToString">
            <summary>
            Returns the string "SpeechEndSignal".
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:Syn.Speech.FrontEnds.EndPoint.SpeechStartSignal">
            <summary>
            A signal that indicates the start of speech. 
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechStartSignal.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.EndPoint.SpeechStartSignal"/> class.
            Constructs a SpeechStartSignal.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechStartSignal.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.EndPoint.SpeechStartSignal"/> class.
            Constructs a SpeechStartSignal at the given time.
            </summary>
            <param name="time">The time this SpeechStartSignal is created.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.EndPoint.SpeechStartSignal.ToString">
            <summary>
            Returns the string "SpeechStartSignal".
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Transform.DiscreteCosineTransform2">
            <summary>
            Applies the optimized MelCosine filter used in pocketsphinx to the given melspectrum.
            </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Transform.DiscreteCosineTransform">
            <summary>
            Applies a logarithm and then a Discrete Cosine Transform (DCT) to the input data. The input data is normally the mel
            spectrum. It has been proven that, for a sequence of real numbers, the discrete cosine transform is equivalent to the
            discrete Fourier transform. Therefore, this class corresponds to the last stage of converting a signal to cepstra,
            defined as the inverse Fourier transform of the logarithm of the Fourier transform of a signal. The property {@link
            #PROP_CEPSTRUM_LENGTH}refers to the dimensionality of the coefficients that are actually returned, defaulting to
            13. When the input is mel-spectrum, the vector returned is the MFCC (Mel-Frequency
            Cepstral Coefficient) vector, where the 0-th element is the energy value.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Transform.DiscreteCosineTransform.PropNumberFilters">
            <summary>
            The property for the number of filters in the filterbank.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Transform.DiscreteCosineTransform.PropCepstrumLength">
            <summary>
            The property for the size of the cepstrum.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.DiscreteCosineTransform.Initialize">
            <summary>
            
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.DiscreteCosineTransform.GetData">
            <summary>
            Returns the next DoubleData object, which is the mel cepstrum of the input frame. Signals are returned
            unmodified.
            </summary>
            <returns>the next available DoubleData melcepstrum, or Signal object, or null if no Data is available</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.DiscreteCosineTransform.Process(Syn.Speech.FrontEnds.DoubleData)">
            <summary>
            Process data, creating the mel cepstrum from an input spectrum frame.
            </summary>
            <param name="input">a MelSpectrum frame</param>
            <returns> mel Cepstrum frame</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.DiscreteCosineTransform.ComputeMelCosine">
            <summary>
            Compute the MelCosine filter bank. 
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.DiscreteCosineTransform.ApplyMelCosine(System.Double[])">
            <summary>
            Apply the MelCosine filter to the given melspectrum.
            </summary>
            <param name="melspectrum">The MelSpectrum data.</param>
            <returns>MelCepstrum data produced by apply the MelCosine filter to the MelSpectrum data.</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.DiscreteCosineTransform2.ApplyMelCosine(System.Double[])">
            <summary>
            Apply the optimized MelCosine filter used in pocketsphinx to the given melspectrum.
            </summary>
            <param name="melspectrum">The MelSpectrum data.</param>
            <returns>
            MelCepstrum data produced by apply the MelCosine filter to the MelSpectrum data.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.FrontEnds.Transform.DiscreteFourierTransform" -->
        <member name="F:Syn.Speech.FrontEnds.Transform.DiscreteFourierTransform.PropNumberFFTPoints">
            <summary>
            The property for the number of points in the Fourier Transform.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Transform.DiscreteFourierTransform.PropInvert">
            <summary>
            The property for the invert transform.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.DiscreteFourierTransform.Initialize">
            <summary>
            @see Sphincs.frontend.DataProcessor#initialize(Sphincs.frontend.CommonConfig)
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.DiscreteFourierTransform.InitializeFFT">
            <summary>
            Initialize all the data structures necessary for computing FFT.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.DiscreteFourierTransform.InitComplexArrays">
            <summary>
            Initialize all the Complex arrays that will be necessary for FFT.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.DiscreteFourierTransform.Process(Syn.Speech.FrontEnds.DoubleData)">
            <summary>
            Process data, creating the power spectrum from an input frame.
            </summary>
            <param name="input">the input frame</param>
            <returns>a DoubleData that is the power spectrum of the input frame</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.DiscreteFourierTransform.ComputeLogBase2(System.Int32)">
            <summary>
            Make sure the number of points in the FFT is a power of 2 by computing its log base 2 and checking for
            remainders.
            </summary>
            <param name="numberFftPoints">The number of points in the FFT.</param>
            <exception cref="T:System.ArgumentException">Not a power of 2:  + numberFftPoints</exception>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.DiscreteFourierTransform.CreateWeightFft(System.Int32,System.Boolean)">
                    /// Initializes the <b>weightFft[]</b> vector. <p><b>weightFft[k] = w ^ k</b></p> where: <p><b>w = exp(-2/// PI/// i /
                    /// N)</b></p> <p><b>i</b> is a complex number such that <b>i/// i = -1</b> and <b>N</b> is the number of points in
                    /// the FFT. Since <b>w</b> is complex, this is the same as</p> <p><b>Re(weightFft[k]) = cos ( -2/// PI/// k /
                    /// N)</b></p> <p><b>Im(weightFft[k]) = sin ( -2/// PI/// k / N)</b></p>
                     *
                    /// @param numberFftPoints number of points in the FFT
                    /// @param invert          whether it's direct (false) or inverse (true) FFT
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.DiscreteFourierTransform.GetData">
            <summary>
            Reads the next DoubleData object, which is a data frame from which we'll compute the power spectrum. Signal
            objects just pass through unmodified.
            </summary>
            <returns>the next available power spectrum DoubleData object, or null if no Spectrum object is available</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.DiscreteFourierTransform.GetNumberFftPoints(System.Int32)">
            <summary>
            Returns the ideal number of FFT points given the number of samples. The ideal number of FFT points is the closest
            power of 2 that is equal to or larger than the number of samples in the incoming window.
            </summary>
            <param name="numberSamples">The number of samples in the incoming window.</param>
            <returns>The closest power of 2 that is equal to or larger than the number of samples in the incoming window.</returns>
            <exception cref="T:System.Exception">Invalid # of FFT points:  + fftPoints</exception>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.DiscreteFourierTransform.RecurseFft(System.Numerics.Complex[],System.Double[],System.Int32,System.Boolean)">
            <summary>
            Establish the recursion. The FFT computation will be computed by as a recursion. Each stage in the butterfly will
            be fully computed during recursion. In fact, we use the mechanism of recursion only because it's the simplest way
            of switching the "input" and "output" vectors. The output of a stage is the input to the next stage. The
            butterfly computes elements in place, but we still need to switch the vectors. We could copy it (not very
            efficient...) or, in C, switch the pointers. We can avoid the pointers by using recursion.
            </summary>
            <param name="input">The input sequence.</param>
            <param name="output">The output sequence.</param>
            <param name="numberFftPoints">The number of points in the FFT.</param>
            <param name="invert">Whether it's direct (false) or inverse (true) FFT.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.DiscreteFourierTransform.SquaredMagnitudeComplex(System.Numerics.Complex)">
            <summary>
            Method to compute the squared magnitude of a complex number.
            </summary>
            <param name="_this">The _this.</param>
            <returns>the squared magnitude of the complex number</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.DiscreteFourierTransform.ButterflyStage(System.Numerics.Complex[],System.Numerics.Complex[],System.Int32,System.Int32)">
                    /// Compute one stage in the FFT butterfly. The name "butterfly" appears because this method computes elements in
                    /// pairs, and a flowgraph of the computation (output "0" comes from input "0" and "1" and output "1" comes from
                    /// input "0" and "1") resembles a butterfly.
                    /// <p/>
                    /// We repeat <code>butterflyStage</code> for <b>log_2(numberFftPoints)</b> stages, by calling the recursion with the
                    /// argument <code>currentDistance</code> divided by 2 at each call, and checking if it's still > 0.
                     *
                    /// @param from            the input sequence at each stage
                    /// @param to              the output sequence
                    /// @param numberFftPoints the total number of points
                    /// @param currentDistance the "distance" between elements in the butterfly
        </member>
        <member name="T:Syn.Speech.FrontEnds.Transform.KaldiDiscreteCosineTransform">
            <summary>
            DCT implementation that conforms to one used in Kaldi.
            </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Transform.Lifter">
            <summary>
            Applies the Lifter to the input mel-cepstrum to 
            smooth cepstrum values
            
            @author Horia Cucu
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Transform.Lifter.PropLifterValue">
            <summary>
            The property for the value of the lifterValue.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.Lifter.GetData">
            <summary>
            Returns the next DoubleData object, which is the lifted mel-cepstrum of the input mel-cepstrum. Signals are returned unmodified.
            </summary>
            <returns>
            The next available DoubleData lifted mel-cepstrum, or Signal object, or null if no Data is available.
            </returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.Lifter.LiftCepstrum(Syn.Speech.FrontEnds.DoubleData)">
            <summary>
            Lifts the input mel-cepstrum.
            </summary>
            <param name="input">A mel-cepstrum frame.</param>
            <exception cref="T:System.ArgumentException">MelCepstrum size is incorrect: 
                                            + melcepstrum.length ==  + melCepstrum.Length
                                            + , cepstrumSize ==  + CepstrumSize</exception>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Transform.Lifter.ComputeLifterWeights">
            <summary>
            Computes the Lifter weights.
            </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Util.AudioContinuityTester">
             <summary>
            {@code FrontEnd} element that asserts the audio-stream to be continuous. This is often a mandatory property for
            frontend setups. The component operates on the acoustic data level and needs to plugged into the frontend
            before the actual feature extraction starts.
             This component can help to debug new VAD implementations, where it has been shown that data-blocks easily get lost.
             @author Holger Brandl
             </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Util.DataConverter">
            <summary>
            A simple converter which converts <code>DoubleData</code> to <code>FloatData</code> and vv (depending on its configuration). 
            All remaining <code>Data</code>s will pass this processor unchanged.
            @author Holger Brandl
            </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Util.DataDumper">
            <summary>
            Dumps the data
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.DataDumper.PropEnable">
            <summary>
            The property that specifies whether data dumping is enabled
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.DataDumper.PropOutputFormat">
            <summary>
            The property that specifies the format of the output.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.DataDumper.PropOutputSignals">
            <summary>
            The property that enables the output of signals.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.DataDumper.Initialize">
            <summary>
            Initializes this DataProcessor. This is typically called after the DataProcessor has been configured.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.DataDumper.GetData">
            <summary>
            Reads and returns the next Data object from this DataProcessor, return null if there is no more audio data.
            </summary>
            <returns>
            The next Data or <code>null</code> if none is available
            </returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.DataDumper.DumpData(Syn.Speech.FrontEnds.IData)">
            <summary>
            Dumps the given input data.
            </summary>
            <param name="input">The data to dump.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.FrontEnds.Util.EnergyPlotter" -->
        <member name="F:Syn.Speech.FrontEnds.Util.EnergyPlotter.PropMaxEnergy">
            <summary>
            The maximum level of energy for which a plot string will be preconstructed.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.EnergyPlotter.BuildPlots(System.Int32)">
            <summary>
            Builds the strings for the plots.
            </summary>
            <param name="maxEnergy">The maximum energy value.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.EnergyPlotter.GetPlotString(System.Int32)">
            <summary>
            Gets the plot string for the given energy.
            </summary>
            <param name="energy">The energy level.</param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.EnergyPlotter.Plot(Syn.Speech.FrontEnds.IData)">
            <summary>
            Plots the energy values of the given Data to System.out. If the Data contains a signal, it prints the signal.
            </summary>
            <param name="cepstrum">The Data to plot.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.EnergyPlotter.GetPlot(System.Int32)">
            <summary>
            Returns the corresponding plot string for the given energy value. 
            The energy value should be positive or zero. If its negative, It will output the string "-".
            </summary>
            <param name="energy">The energy value.</param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.FrontEndUtils.GetFrontEndProcessor``1(Syn.Speech.FrontEnds.IDataProcessor,``0)">
            <summary>
            Returns a the next <code>DataProcessor</code> of type <code>predecClass</code> which precedes <code>dp</code>
            </summary>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Util.IAudioFileProcessListener">
            <summary>
            An interface which is describes the functionality which is required to handle new file signals fired by the audio-data sources.
            @author Holger Brandl
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.IAudioFileProcessListener.AudioFileProcStarted(System.IO.FileInfo)">
            <summary>
            This method is invoked whenever a new file is started to become processed by an audio file data source.
            </summary>
            <param name="audioFile">The name of the new audio file.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.IAudioFileProcessListener.AudioFileProcFinished(System.IO.FileInfo)">
            <summary>
            This method is invoked whenever a file processing has finished within a audio file data source.
            </summary>
            <param name="audioFile">The name of the processed audio file.</param>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Util.DataUtil">
            <summary>
            Defines utility methods for manipulating data values.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.DataUtil.format">
            <summary>
            DecimalFormat object to be used by all the methods.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.DataUtil.decimalIntegerDigits">
            new DecimalFormat();
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.DataUtil._dumpFormat">
            <summary>
            The number format to be used by *ArrayToString() methods. The default is scientific.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.DataUtil.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:Syn.Speech.FrontEnds.Util.DataUtil"/> class from being created.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.DataUtil.BytesToValues(System.Byte[],System.Int32,System.Int32,System.Int32,System.Boolean)">
                    /// Converts a big-endian byte array into an array of doubles. Each consecutive bytes in the byte array are converted
                    /// into a double, and becomes the next element in the double array. The size of the returned array is
                    /// (length/bytesPerValue). Currently, only 1 byte (8-bit) or 2 bytes (16-bit) samples are supported.
                     *
                    /// @param byteArray     a byte array
                    /// @param offset        which byte to start from
                    /// @param length        how many bytes to convert
                    /// @param bytesPerValue the number of bytes per value
                    /// @param signedData    whether the data is signed
                    /// @return a double array, or <code>null</code> if byteArray is of zero length
                    /// @throws java.lang.ArrayIndexOutOfBoundsException
                     *
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.DataUtil.LittleEndianBytesToValues(System.Byte[],System.Int32,System.Int32,System.Int32,System.Boolean)">
                    /// Converts a little-endian byte array into an array of doubles. Each consecutive bytes of a float are converted
                    /// into a double, and becomes the next element in the double array. The number of bytes in the double is specified
                    /// as an argument. The size of the returned array is (data.length/bytesPerValue).
                     *
                    /// @param data          a byte array
                    /// @param offset        which byte to start from
                    /// @param length        how many bytes to convert
                    /// @param bytesPerValue the number of bytes per value
                    /// @param signedData    whether the data is signed
                    /// @return a double array, or <code>null</code> if byteArray is of zero length
                    /// @throws java.lang.ArrayIndexOutOfBoundsException
                     *
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.DataUtil.GetSamplesPerWindow(System.Int32,System.Single)">
            <summary>
            Gets the number of samples per window given the sample rate (in Hertz) and window size (in milliseconds).
            </summary>
            <param name="sampleRate">The sample rate in Hertz (i.e., frequency per seconds).</param>
            <param name="windowSizeInMs">The window size in milliseconds.</param>
            <returns>The number of samples per window.</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.DataUtil.GetSamplesPerShift(System.Int32,System.Single)">
            <summary>
            Returns the number of samples in a window shift given the sample rate (in Hertz) and the window shift (in milliseconds).
            </summary>
            <param name="sampleRate">The sample rate in Hertz (i.e., frequency per seconds).</param>
            <param name="windowShiftInMs">The window shift in milliseconds.</param>
            <returns>The number of samples in a window shift.</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.DataUtil.FloatData2DoubleData(Syn.Speech.FrontEnds.FloatData)">
            <summary>
            Converts DoubleData object to FloatDatas.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.DataUtil.DoubleData2FloatData(Syn.Speech.FrontEnds.DoubleData)">
            <summary>
            Converts FloatData object to DoubleData.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.InputStreamEnumeration.HasMoreElements">
            <summary>
            Tests if this enumeration contains more elements.
            </summary>
            <returns>true if and only if this enumeration object contains at least one more element to provide; false otherwise.</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.InputStreamEnumeration.NextElement">
            <summary>
            Returns the next element of this enumeration if this enumeration object has at least one more element to provide.
            </summary>
            <returns>The next element of this enumeration.</returns>
            <exception cref="T:System.Exception">Cannot convert  + _owner.NextFile +
                                         to a FileInputStream</exception>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.InputStreamEnumeration.ReadNext">
            <summary>
            Returns the name of next audio file, taking into account file skipping and the adding of silence.
            </summary>
            <returns>The name of the appropriate audio file.</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.InputStreamEnumeration.ReadNextDataFile">
            <summary>
            Returns the next audio file.
            </summary>
            <returns>The name of the next audio file.</returns>
            <exception cref="T:System.Exception">Problem reading from batch file</exception>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.InputStreamEnumeration.WriteTranscript(System.String,System.String)">
            <summary>
            Writes the transcript file.
            </summary>
            <param name="fileName">The name of the decoded file.</param>
            <param name="reference">The reference text.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.InputStreamEnumeration.WriteSilenceToTranscript">
            <summary>
            Writes silence to the transcript file.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.InputStreamEnumeration.GetSilenceCount">
            <summary>
            Gets how many times the silence file should be added between utterances.
            </summary>
            <returns>The number of times the silence file should be added between utterances.</returns>
        </member>
        <member name="T:Syn.Speech.FrontEnds.Util.StreamCepstrumSource">
            <summary>
            Produces Mel-cepstrum data from an InputStream. To set the inputstream with cepstral data, use the {@link
            #setInputStream(InputStream,Boolean) setInputStream} method, and then call {@link #getData} to obtain the Data
            objects that have cepstra data in it.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.StreamCepstrumSource.PropBinary">
            <summary>
            The property specifying whether the input is in binary.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.StreamCepstrumSource.PropFrameSizeMs">
            <summary>
             The property  name for frame size in milliseconds.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.StreamCepstrumSource.PropFrameShiftMs">
            <summary>
            The property  name for frame shift in milliseconds, which has a default value of 10F.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.StreamCepstrumSource.PropCepstrumLength">
            <summary>
            The property  specifying the length of the cepstrum data.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.StreamCepstrumSource.PropBigEndianData">
            <summary>
            The property specifying whether the input data is big-endian.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Util.StreamCepstrumSource.PropSampleRate">
            <summary>
            The property that defines the sample rate.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.StreamCepstrumSource.Initialize">
            <summary>
            Constructs a StreamCepstrumSource that reads MelCepstrum data from the given path.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.StreamCepstrumSource.SetInputStream(System.IO.Stream,System.Boolean)">
            <summary>
            Sets the InputStream to read cepstral data from.
            </summary>
            <param name="_is">The InputStream to read cepstral data from.</param>
            <param name="bigEndian">true if the InputStream data is in big-endian, false otherwise.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Util.StreamCepstrumSource.GetData">
            <summary>
            Returns the next Data object, which is the mel cepstrum of the input frame. However, it can also be other Data objects like DataStartSignal.
            </summary>
            <returns>
            The next available Data object, returns null if no Data object is available.
            </returns>
            <exception cref="T:System.Exception">
            IOException closing cepstrum stream
            or
            IOException reading from cepstrum stream
            </exception>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Window.DoubleBuffer.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.FrontEnds.Window.DoubleBuffer"/> class.
            </summary>
            <param name="size">The size.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Window.DoubleBuffer.AppendAll(System.Double[])">
            <summary>
            Appends all the elements in the given array to this DoubleBuffer.
            </summary>
            <param name="src">The array to copy from.</param>
            <returns>The resulting number of elements in this DoubleBuffer.</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Window.DoubleBuffer.Append(System.Double[],System.Int32,System.Int32)">
            <summary>
            Appends the specified elements in the given array to this DoubleBuffer.
            </summary>
            <param name="src">The array to copy from.</param>
            <param name="srcPos">Where in the source array to start from.</param>
            <param name="length">The number of elements to copy.</param>
            <returns>The resulting number of elements in this DoubleBuffer.</returns>
            <exception cref="T:System.Exception">RaisedCosineWindower:  +
                                                overflow-buffer: attempting to fill  +
                                                buffer beyond its capacity.</exception>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Window.DoubleBuffer.PadWindow(System.Int32)">
            <summary>
            If there are less than windowSize elements in this DoubleBuffer, pad the up to windowSize elements with zero.
            </summary>
            <param name="windowSize">The window size.</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Window.DoubleBuffer.Reset">
            <summary>
            Sets the number of elements in this DoubleBuffer to zero, without actually remove the elements.
            </summary>
        </member>
        <member name="P:Syn.Speech.FrontEnds.Window.DoubleBuffer.Occupancy">
            <summary>
            Gets the number of elements in this DoubleBuffer.
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.FrontEnds.Window.DoubleBuffer.Buffer">
            <summary>
            Returns the underlying double array used to store the data.
            </summary>
            <value>The underlying double array.</value>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.FrontEnds.Window.RaisedCosineWindower" -->
        <member name="F:Syn.Speech.FrontEnds.Window.RaisedCosineWindower.PropWindowSizeMs">
            <summary>
            The property for window size in milliseconds.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Window.RaisedCosineWindower.PropWindowShiftMs">
            <summary>
            The property for window shift in milliseconds, which has a default value of 10F.
            </summary>
        </member>
        <member name="F:Syn.Speech.FrontEnds.Window.RaisedCosineWindower.PropAlpha">
            <summary>
            The property for the alpha value of the Window, which is the value for the RaisedCosineWindow.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Window.RaisedCosineWindower.Initialize">
            <summary>
            @see Sphincs.frontend.DataProcessor#initialize(Sphincs.frontend.CommonConfig)
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Window.RaisedCosineWindower.CreateWindow(System.Int32)">
            <summary>
            Creates the Hamming Window.
            </summary>
            <param name="sampleRate"></param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Window.RaisedCosineWindower.GetData">
            <summary>
            Returns the next Data object, which is usually a window of the input Data, with the windowing function applied to
            it.
            </summary>
            <returns>the next available Data object, returns null if no Data object is available</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Window.RaisedCosineWindower.Process(Syn.Speech.FrontEnds.DoubleData)">
            <summary>
            Applies the Windowing to the given Data. The resulting windows are cached in the outputQueue.
            </summary>
            <param name="input">the input Data object</param>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Window.RaisedCosineWindower.ProcessUtteranceEnd">
            <summary>
            What happens when an DataEndSignal is received. Basically pads up to a window of the overflow buffer with zeros,
            and then apply the Hamming window to it. Checks if buffer has data.
            </summary>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Window.RaisedCosineWindower.ApplyRaisedCosineWindow(System.Double[],System.Int32)">
            <summary>
            Applies the Hamming window to the given double array. The windows are added to the output queue. Returns the
            index of the first array element of next window that is not produced because of insufficient data.
            </summary>
            <param name="_in">the audio data to apply window and the Hamming window</param>
            <param name="length">the number of elements in the array to apply the RaisedCosineWindow</param>
            <returns>the index of the first array element of the next window</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Window.RaisedCosineWindower.GetWindowCount(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets the number of windows in the given array, given the windowSize and windowShift.
            </summary>
            <param name="arraySize">The size of the array.</param>
            <param name="windowSize">The window size.</param>
            <param name="windowShift">The window shift.</param>
            <returns>the number of windows</returns>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Window.RaisedCosineWindower.GetWindowShiftInMs">
            <summary>
            Returns the shift size used to window the incoming speech signal. This value might be used by other components to
            determine the time resolution of feature vectors.
            </summary>
            <returns>The shift of the window.</returns>
            <exception cref="T:System.SystemException"></exception>
        </member>
        <member name="M:Syn.Speech.FrontEnds.Window.RaisedCosineWindower.RoundToFrames(System.Int64)">
             <summary>
            Rounds a given sample-number to the number of samples will be processed by this instance including the padding samples at the end..
             </summary>
             <param name="samples">The samples.</param>
             <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Fsts.Arc" -->
        <member name="M:Syn.Speech.Fsts.Arc.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Fsts.Arc"/> class.
            </summary>
        </member>
        <member name="M:Syn.Speech.Fsts.Arc.#ctor(System.Int32,System.Int32,System.Single,Syn.Speech.Fsts.State)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Fsts.Arc"/> class.
            </summary>
            <param name="iLabel">The input label's id.</param>
            <param name="oLabel">The output label's id.</param>
            <param name="weight">The arc's weight.</param>
            <param name="nextState">The arc's next state.</param>
        </member>
        <member name="P:Syn.Speech.Fsts.Arc.Weight">
            <summary>
            Get the arc's weight
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Fsts.Arc.Ilabel">
            <summary>
            Gets or sets the input label's id.
            </summary>
            <value>
            The ilabel.
            </value>
        </member>
        <member name="P:Syn.Speech.Fsts.Arc.Olabel">
            <summary>
            Gets or sets the output label's id.
            </summary>
            <value>
            The olabel.
            </value>
        </member>
        <member name="P:Syn.Speech.Fsts.Arc.NextState">
            <summary>
            Gets or sets the next state
            </summary>
            <value>
            The state of the next.
            </value>
        </member>
        <member name="M:Syn.Speech.Fsts.Convert.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:Syn.Speech.Fsts.Convert"/> class from being created.
            </summary>
        </member>
        <member name="M:Syn.Speech.Fsts.Export.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:Syn.Speech.Fsts.Export"/> class from being created.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Fsts.Fst" -->
        <member name="M:Syn.Speech.Fsts.Fst.#ctor">
                    /// Default Constructor
        </member>
        <member name="M:Syn.Speech.Fsts.Fst.#ctor(System.Int32)">
                    /// Constructor specifying the initial capacity of the states ArrayList (this
                    /// is an optimization used in various operations)
                    /// 
                    /// @param numStates
                    ///            the initial capacity
        </member>
        <member name="M:Syn.Speech.Fsts.Fst.#ctor(Syn.Speech.Fsts.Semirings.Semiring)">
                    /// Constructor specifying the fst's semiring
                    /// 
                    /// @param s
                    ///            the fst's semiring
        </member>
        <member name="M:Syn.Speech.Fsts.Fst.SetStart(Syn.Speech.Fsts.State)">
                    /// Set the initial state
                    /// 
                    /// @param start
                    ///            the initial state
        </member>
        <member name="M:Syn.Speech.Fsts.Fst.GetNumStates">
                    /// Get the number of states in the fst
        </member>
        <member name="M:Syn.Speech.Fsts.Fst.AddState(Syn.Speech.Fsts.State)">
                    /// Adds a state to the fst
                    /// 
                    /// @param state
                    ///            the state to be added
        </member>
        <member name="M:Syn.Speech.Fsts.Fst.WriteStringMap(System.IO.StreamWriter,System.String[])">
                    /// Serializes a symbol map to an ObjectOutputStream
                    /// 
                    /// @param out
                    ///            the ObjectOutputStream. It should be already be initialized by
                    ///            the caller.
                    /// @param map
                    ///            the symbol map to serialize
                    /// @throws IOException
        </member>
        <member name="M:Syn.Speech.Fsts.Fst.WriteFst(System.IO.StreamWriter)">
                    /// Serializes the current Fst instance to an ObjectOutputStream
                    /// 
                    /// @param out
                    ///            the ObjectOutputStream. It should be already be initialized by
                    ///            the caller.
                    /// @throws IOException
        </member>
        <member name="M:Syn.Speech.Fsts.Fst.SaveModel(System.String)">
                    /// Saves binary model to disk
                    /// 
                    /// @param filename
                    ///            the binary model filename
                    /// @throws IOException
        </member>
        <member name="M:Syn.Speech.Fsts.Fst.ReadStringMap(System.IO.Stream)">
                    /// Deserializes a symbol map from an ObjectInputStream
                    /// 
                    /// @param in
                    ///            the ObjectInputStream. It should be already be initialized by
                    ///            the caller.
                    /// @return the deserialized symbol map
                    /// @throws IOException
                    /// @throws ClassNotFoundException
        </member>
        <member name="M:Syn.Speech.Fsts.Fst.ReadFst(System.IO.Stream)">
                    /// Deserializes an Fst from an ObjectInputStream
                    /// 
                    /// @param in
                    ///            the ObjectInputStream. It should be already be initialized by
                    ///            the caller.
                    /// @return
                    /// @throws IOException
                    /// @throws ClassNotFoundException
        </member>
        <member name="M:Syn.Speech.Fsts.Fst.LoadModel(System.String)">
                    /// Deserializes an Fst from disk
                    /// 
                    /// @param filename
                    ///            the binary model filename
                    /// @throws IOException
                    /// @throws ClassNotFoundException
        </member>
        <member name="M:Syn.Speech.Fsts.Fst.DeleteState(Syn.Speech.Fsts.State)">
                    /// Deletes a state
                    /// 
                    /// @param state
                    ///            the state to delete
        </member>
        <member name="M:Syn.Speech.Fsts.Fst.RemapStateIds">
                    /// Remaps the states' ids.
                    /// 
                    /// States' ids are renumbered starting from 0 up to @see
                    /// {@link edu.cmu.sphinx.fst.Fst#getNumStates()}
        </member>
        <member name="P:Syn.Speech.Fsts.Fst.Start">
                    /// Get the initial states
        </member>
        <member name="P:Syn.Speech.Fsts.Fst.Semiring">
                    /// Get the semiring
        </member>
        <member name="P:Syn.Speech.Fsts.Fst.Isyms">
                    /// Get the input symbols' array
        </member>
        <member name="P:Syn.Speech.Fsts.Fst.Osyms">
                    /// Get the output symbols' array
        </member>
        <member name="T:Syn.Speech.Fsts.ImmutableFst">
            <summary>
            An immutable finite state transducer implementation.
            
            Holds a fixed size array of {@link edu.cmu.sphinx.fst.ImmutableState} objects
            not allowing additions/deletions
            </summary>
        </member>
        <member name="M:Syn.Speech.Fsts.ImmutableFst.#ctor">
                    /// Default private constructor.
                    /// 
                    /// An ImmutableFst cannot be created directly. It needs to be deserialized.
                    /// 
                    /// @see edu.cmu.sphinx.fst.ImmutableFst#loadModel(String)
        </member>
        <member name="M:Syn.Speech.Fsts.ImmutableFst.#ctor(System.Int32)">
                    /// Private Constructor specifying the capacity of the states array
                    /// 
                    /// An ImmutableFst cannot be created directly. It needs to be deserialized.
                    /// 
                    /// @see edu.cmu.sphinx.fst.ImmutableFst#loadModel(String)
                    /// 
                    /// @param numStates
                    ///            the number of fst's states
        </member>
        <member name="M:Syn.Speech.Fsts.ImmutableFst.ReadImmutableFst(System.IO.Stream)">
                    /// Deserializes an ImmutableFst from an ObjectInputStream
                    /// 
                    /// @param in
                    ///            the ObjectInputStream. It should be already be initialized by
                    ///            the caller.
                    /// @return
                    /// @throws IOException
                    /// @throws ClassNotFoundException
        </member>
        <member name="M:Syn.Speech.Fsts.ImmutableFst.LoadModel(System.String)">
            <summary>
            Deserializes an ImmutableFst from disk
            </summary>
            <param name="filename">the binary model filename</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Fsts.ImmutableState" -->
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Fsts.State" -->
        <member name="M:Syn.Speech.Fsts.State.#ctor">
                    /// Default Constructor
        </member>
        <member name="M:Syn.Speech.Fsts.State.#ctor(System.Single)">
                    /// Constructor specifying the state's final weight
                    /// 
                    /// @param fnlWeight
        </member>
        <member name="M:Syn.Speech.Fsts.State.#ctor(System.Int32)">
                    /// Constructor specifying the initial capacity of the arc's ArrayList (this
                    /// is an optimization used in various operations)
                    /// 
                    /// @param initialNumArcs
        </member>
        <member name="M:Syn.Speech.Fsts.State.ArcSort(System.Collections.Generic.Comparer{Syn.Speech.Fsts.Arc})">
                    /// Shorts the arc's ArrayList based on the provided Comparator
        </member>
        <member name="M:Syn.Speech.Fsts.State.SetArcs(System.Collections.Generic.List{Syn.Speech.Fsts.Arc})">
                    /// Set the state's arcs ArrayList
                    /// 
                    /// @param arcs the arcs ArrayList to set
        </member>
        <member name="M:Syn.Speech.Fsts.State.GetId">
                    /// Get the state's id
        </member>
        <member name="M:Syn.Speech.Fsts.State.GetNumArcs">
                    /// Get the number of outgoing arcs
        </member>
        <member name="M:Syn.Speech.Fsts.State.AddArc(Syn.Speech.Fsts.Arc)">
                    /// Add an outgoing arc to the state
                    /// 
                    /// @param arc the arc to add
        </member>
        <member name="M:Syn.Speech.Fsts.State.GetArc(System.Int32)">
                    /// Get an arc based on it's index the arcs ArrayList
                    /// 
                    /// @param index the arc's index
                    /// @return the arc
        </member>
        <member name="M:Syn.Speech.Fsts.State.DeleteArc(System.Int32)">
                    /// Delete an arc based on its index
                    /// 
                    /// @param index the arc's index
                    /// @return the deleted arc
        </member>
        <member name="M:Syn.Speech.Fsts.State.SetArc(System.Int32,Syn.Speech.Fsts.Arc)">
                    /// Set an arc at the specified position in the arcs' ArrayList.
                    /// 
                    /// @param index the position to the arcs' array
                    /// @param arc the arc value to set
        </member>
        <member name="P:Syn.Speech.Fsts.State.FinalWeight">
                    /// Get the state's final Weight
        </member>
        <member name="M:Syn.Speech.Fsts.ImmutableState.#ctor">
                    /// Default protected constructor.
                    /// 
                    /// An ImmutableState cannot be created directly. It needs to be deserialized
                    /// as part of an ImmutableFst.
                    /// 
                    /// @see edu.cmu.sphinx.fst.ImmutableFst#loadModel(String)
                    /// 
        </member>
        <member name="M:Syn.Speech.Fsts.ImmutableState.#ctor(System.Int32)">
                    /// Constructor specifying the capacity of the arcs array.
                    /// 
                    /// @param numArcs
        </member>
        <member name="M:Syn.Speech.Fsts.ImmutableState.SetArc(System.Int32,Syn.Speech.Fsts.Arc)">
                    /// Set an arc at the specified position in the arcs' array.
                    /// 
                    /// @param index the position to the arcs' array
                    /// @param arc the arc value to set
        </member>
        <member name="M:Syn.Speech.Fsts.ImmutableState.SetArcs(Syn.Speech.Fsts.Arc[])">
                    /// Set the state's arcs array
                    /// 
                    /// @param arcs the arcs array to set
        </member>
        <member name="T:Syn.Speech.Fsts.Import">
            <summary>
            Provides a command line utility to convert an Fst in openfst's text format to java binary fst model.
            @author John Salatas "jsalatas@users.sourceforge.net"
            </summary>
        </member>
        <member name="M:Syn.Speech.Fsts.Import.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:Syn.Speech.Fsts.Import"/> class from being created.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Fsts.Operations.ArcSort" -->
        <member name="M:Syn.Speech.Fsts.Operations.ArcSort.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:Syn.Speech.Fsts.Operations.ArcSort"/> class from being created.
            </summary>
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.ArcSort.Apply(Syn.Speech.Fsts.Fst,System.Collections.Generic.Comparer{Syn.Speech.Fsts.Arc})">
            <summary>
            Applies the ArcSort on the provided fst. Sorting can be applied either on
            input or output label based on the provided comparator.
            </summary>
            <param name="fst">the fst to sort it's arcs.</param>
            <param name="cmp">The provided Comparator.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Fsts.Operations.Compose" -->
        <member name="M:Syn.Speech.Fsts.Operations.Compose.#ctor">
                    /// Default Constructor
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.Compose.compose(Syn.Speech.Fsts.Fst,Syn.Speech.Fsts.Fst,Syn.Speech.Fsts.Semirings.Semiring,System.Boolean)">
                   /// Computes the composition of two Fsts. Assuming no epsilon transitions.
                   /// 
                   /// Input Fsts are not modified.
                   /// 
                   /// @param fst1 the first Fst
                   /// @param fst2 the second Fst
                   /// @param semiring the semiring to use in the operation
                   /// @param sorted
                   /// @return the composed Fst
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.Compose.Get(Syn.Speech.Fsts.Fst,Syn.Speech.Fsts.Fst,Syn.Speech.Fsts.Semirings.Semiring)">
                    /// Computes the composition of two Fsts. The two Fsts are augmented in order
                    /// to avoid multiple epsilon paths in the resulting Fst
                    /// 
                    /// @param fst1 the first Fst
                    /// @param fst2 the second Fst
                    /// @param semiring the semiring to use in the operation
                    /// @return the composed Fst
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.Compose.GetFilter(System.String[],Syn.Speech.Fsts.Semirings.Semiring)">
                    /// Get a filter to use for avoiding multiple epsilon paths in the resulting
                    /// Fst
                    /// 
                    /// See: M. Mohri, "Weighted automata algorithms", Handbook of Weighted
                    /// Automata. Springer, pp. 213-250, 2009.
                    /// 
                    /// @param syms the gilter's input/output symbols
                    /// @param semiring the semiring to use in the operation
                    /// @return the filter
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.Compose.Augment(System.Int32,Syn.Speech.Fsts.Fst,Syn.Speech.Fsts.Semirings.Semiring)">
                    /// Augments the labels of an Fst in order to use it for composition avoiding
                    /// multiple epsilon paths in the resulting Fst
                    /// 
                    /// Augment can be applied to both {@link edu.cmu.sphinx.fst.Fst} and
                    /// {@link edu.cmu.sphinx.fst.ImmutableFst}, as immutable fsts hold an
                    /// additional null arc for that operation
                    /// 
                    /// @param label constant denoting if the augment should take place on input
                    ///            or output labels For value equal to 0 augment will take place
                    ///            for input labels For value equal to 1 augment will take place
                    ///            for output labels
                    /// @param fst the fst to augment
                    /// @param semiring the semiring to use in the operation
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Fsts.Operations.Connect" -->
        <member name="M:Syn.Speech.Fsts.Operations.Connect.CalcCoAccessible(Syn.Speech.Fsts.Fst,Syn.Speech.Fsts.State,System.Collections.Generic.List{System.Collections.Generic.List{Syn.Speech.Fsts.State}},System.Collections.Generic.HashSet{Syn.Speech.Fsts.State})">
                /// Calculates the coaccessible states of an fst
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.Connect.DuplicatePath(System.Int32,Syn.Speech.Fsts.State,Syn.Speech.Fsts.State,System.Collections.Generic.List{System.Collections.Generic.List{Syn.Speech.Fsts.State}})">
                    /// Copies a path
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.Connect.DepthFirstSearchNext(Syn.Speech.Fsts.Fst,Syn.Speech.Fsts.State,System.Collections.Generic.List{System.Collections.Generic.List{Syn.Speech.Fsts.State}},System.Collections.Generic.List{Syn.Speech.Fsts.Arc}[],System.Collections.Generic.HashSet{Syn.Speech.Fsts.State})">
                    /// The depth first search recursion
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.Connect.AddExploredArc(System.Int32,Syn.Speech.Fsts.Arc,System.Collections.Generic.List{Syn.Speech.Fsts.Arc}[])">
                    /// Adds an arc top the explored arcs list
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.Connect.DepthFirstSearch(Syn.Speech.Fsts.Fst,System.Collections.Generic.HashSet{Syn.Speech.Fsts.State},System.Collections.Generic.List{System.Collections.Generic.List{Syn.Speech.Fsts.State}},System.Collections.Generic.List{Syn.Speech.Fsts.Arc}[],System.Collections.Generic.HashSet{Syn.Speech.Fsts.State})">
                    /// Initialization of a depth first search recursion
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.Connect.Apply(Syn.Speech.Fsts.Fst)">
                    /// Trims an Fst, removing states and arcs that are not on successful paths.
                    /// 
                    /// @param fst the fst to trim
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Fsts.Operations.Determinize" -->
        <member name="M:Syn.Speech.Fsts.Operations.Determinize.#ctor">
                   /// Default constructor
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.Determinize.Get(Syn.Speech.Fsts.Fst)">
                    /// Determinizes an fst. The result will be an equivalent fst that has the
                    /// property that no state has two transitions with the same input label. For
                    /// this algorithm, epsilon transitions are treated as regular symbols.
                    /// 
                    /// @param fst the fst to determinize
                    /// @return the determinized fst
        </member>
        <member name="T:Syn.Speech.Fsts.Operations.ExtendFinal">
            <summary>
            Extend an Fst to a single final state and undo operations.
            @author John Salatas "jsalatas@users.sourceforge.net"
            </summary>
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.ExtendFinal.#ctor">
                    /// Default Contructor
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.ExtendFinal.Apply(Syn.Speech.Fsts.Fst)">
                    /// Extends an Fst to a single final state.
                    /// 
                    /// It adds a new final state with a 0.0 (Semiring's 1) final wight and
                    /// connects the current final states to it using epsilon transitions with
                    /// weight equal to the original final state's weight.
                    /// 
                    /// @param fst the Fst to extend
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.ExtendFinal.Undo(Syn.Speech.Fsts.Fst)">
                    /// Undo of the extend operation
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Fsts.Operations.ILabelCompare" -->
        <member name="T:Syn.Speech.Fsts.Operations.NShortestPaths">
            <summary>
            N-shortest paths operation.
            
            See: M. Mohri, M. Riley,
            "An Efficient Algorithm for the n-best-strings problem", Proceedings of the
            International Conference on Spoken Language Processing 2002 (ICSLP '02).
            
            See: M. Mohri,
            "Semiring Framework and Algorithms for Shortest-Distance Problems", Journal
            of Automata, Languages and Combinatorics, 7(3), pp. 321-350, 2002.
            
            @author John Salatas "jsalatas@users.sourceforge.net"
            </summary>
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.NShortestPaths.ShortestDistance(Syn.Speech.Fsts.Fst)">
                    /// Calculates the shortest distances from each state to the final
                    /// 
                    /// @param fst
                    ///            the fst to calculate the shortest distances
                    /// @return the array containing the shortest distances
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.NShortestPaths.Get(Syn.Speech.Fsts.Fst,System.Int32,System.Boolean)">
                    /// Calculates the n-best shortest path from the initial to the final state.
                    /// 
                    /// @param fst
                    ///            the fst to calculate the nbest shortest paths
                    /// @param n
                    ///            number of best paths to return
                    /// @param determinize
                    ///            if true the input fst will bwe determinized prior the
                    ///            operation
                    /// @return an fst containing the n-best shortest paths
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Fsts.Operations.OLabelCompare" -->
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Fsts.Operations.Project" -->
        <member name="M:Syn.Speech.Fsts.Operations.Project.#ctor">
                    /// Default Constructor
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.Project.Apply(Syn.Speech.Fsts.Fst,Syn.Speech.Fsts.Operations.ProjectType)">
                    /// Projects an fst onto its domain or range by either copying each arc's
                    /// input label to its output label or vice versa.
                    /// 
                    /// 
                    /// @param fst
                    /// @param pType
        </member>
        <member name="T:Syn.Speech.Fsts.Operations.Reverse">
            <summary>
             Reverse operation.
            @author John Salatas "jsalatas@users.sourceforge.net"
            </summary>
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.Reverse.#ctor">
                   /// Default Constructor
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.Reverse.Get(Syn.Speech.Fsts.Fst)">
                    /// Reverses an fst
                    /// 
                    /// @param fst the fst to reverse
                    /// @return the reversed fst
        </member>
        <member name="T:Syn.Speech.Fsts.Operations.RmEpsilon">
            <summary>
            Remove epsilon operation.
            @author John Salatas "jsalatas@users.sourceforge.net"
            </summary>
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.RmEpsilon.Put(Syn.Speech.Fsts.State,Syn.Speech.Fsts.State,System.Single,System.Collections.Generic.Dictionary{Syn.Speech.Fsts.State,System.Single}[])">
                    /// Put a new state in the epsilon closure
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.RmEpsilon.Add(Syn.Speech.Fsts.State,Syn.Speech.Fsts.State,System.Single,System.Collections.Generic.Dictionary{Syn.Speech.Fsts.State,System.Single}[],Syn.Speech.Fsts.Semirings.Semiring)">
                    /// Add a state in the epsilon closure
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.RmEpsilon.CalcClosure(Syn.Speech.Fsts.Fst,Syn.Speech.Fsts.State,System.Collections.Generic.Dictionary{Syn.Speech.Fsts.State,System.Single}[],Syn.Speech.Fsts.Semirings.Semiring)">
                    /// Calculate the epsilon closure
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.RmEpsilon.GetPathWeight(Syn.Speech.Fsts.State,Syn.Speech.Fsts.State,System.Collections.Generic.Dictionary{Syn.Speech.Fsts.State,System.Single}[])">
                    /// Get an epsilon path's cost in epsilon closure
        </member>
        <member name="M:Syn.Speech.Fsts.Operations.RmEpsilon.Get(Syn.Speech.Fsts.Fst)">
                    /// Removes epsilon transitions from an fst.
                    /// 
                    /// It return a new epsilon-free fst and does not modify the original fst
                    /// 
                    /// @param fst the fst to remove epsilon transitions from
                    /// @return the epsilon-free fst
        </member>
        <member name="T:Syn.Speech.Fsts.Semirings.TropicalSemiring">
            <summary>
            Tropical semiring implementation.
            
            @author "John Salatas "jsalatas@users.sourceforge.net"
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Fsts.Utils.Utils" -->
        <member name="M:Syn.Speech.Fsts.Utils.Utils.Search(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Int32)">
            <summary>
            Searches an ArrayList of Strings starting from a specific position for a pattern
            </summary>
            <param name="src">The input ArrayList of Strings.</param>
            <param name="pattern">The pattern to search for.</param>
            <param name="start">The starting position.</param>
            <returns>The index of the first occurrence or -1 if no matches found.</returns>
        </member>
        <member name="M:Syn.Speech.Fsts.Utils.Utils.GetIndex(System.String[],System.String)">
            <summary>
            Get the position (index) of a particular string in a Strings array.
            The search is case insensitive.
            </summary>
            <param name="strings">The Strings array.</param>
            <param name="_string">The string to search.</param>
            <returns>The index of the first occurrence or -1 if no matches found.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Fsts.Utils.Utils.ToStringArray(Syn.Speech.Helper.HashMap{System.String,Syn.Speech.Helper.Integer})" -->
        <member name="M:Syn.Speech.Helper.Arrays.copyOf``1(``0[],System.Int32)">
            <summary>
            Java: Method copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. 
            For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. 
            For any indices that are valid in the copy but not the original, 
            the copy will contain 0.Such indices will exist if and only if the specified length is greater than that of the original array.
            </summary>
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.LUDecomposition.DEFAULT_TOO_SMALL">
            Default bound to determine effective singularity in LU decomposition. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.LUDecomposition.lu">
            Entries of LU decomposition. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.LUDecomposition.pivot">
            Pivot permutation associated with LU decomposition. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.LUDecomposition.even">
            Parity of the permutation associated with the LU decomposition. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.LUDecomposition.singular">
            Singularity indicator. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.LUDecomposition.cachedL">
            Cached value of L. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.LUDecomposition.cachedU">
            Cached value of U. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.LUDecomposition.cachedP">
            Cached value of P. 
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector">
            This class implements the {@link RealVector} interface with a double array.
            @since 2.0
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.data">
            Entries of the vector. 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.#ctor">
            Build a 0-length vector.
            Zero-length vectors may be used to initialized construction of vectors
            by data gathering. We start with zero-length and use either the {@link
            #ArrayRealVector(ArrayRealVector, ArrayRealVector)} constructor
            or one of the {@code append} method ({@link #append(double)},
            {@link #append(ArrayRealVector)}) to gather data into this vector.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.#ctor(System.Int32)">
             Construct a vector of zeroes.
            
             @param size Size of the vector.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.#ctor(System.Int32,System.Double)">
             Construct a vector with preset values.
            
             @param size Size of the vector
             @param preset All entries will be set with this value.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.#ctor(System.Double[],System.Boolean)">
             Create a new ArrayRealVector using the input array as the underlying
             data array.
             If an array is built specially in order to be embedded in a
             ArrayRealVector and not used directly, the {@code copyArray} may be
             set to {@code false}. This will prevent the copying and improve
             performance as no new array will be built and no data will be copied.
            
             @param d Data for the new vector.
             @param copyArray if {@code true}, the input array will be copied,
             otherwise it will be referenced.
             @throws NullArgumentException if {@code d} is {@code null}.
             @see #ArrayRealVector(double[])
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.#ctor(System.Double[])">
             Construct a vector from an array.
            
             @param d Array of {@code Double}s.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.#ctor(System.Double[],System.Int32,System.Int32)">
             Construct a vector from part of an array.
            
             @param d Array.
             @param pos Position of first entry.
             @param size Number of entries to copy.
             @throws NullArgumentException if {@code d} is {@code null}.
             @throws NumberIsTooLargeException if the size of {@code d} is less
             than {@code pos + size}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.#ctor(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Construct a vector from another vector, using a deep copy.
            
             @param v vector to copy.
             @throws NullArgumentException if {@code v} is {@code null}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.#ctor(Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector)">
             Construct a vector from another vector, using a deep copy.
            
             @param v Vector to copy.
             @throws NullArgumentException if {@code v} is {@code null}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.#ctor(Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector,System.Boolean)">
             Construct a vector from another vector.
            
             @param v Vector to copy.
             @param deep If {@code true} perform a deep copy, otherwise perform a
             shallow copy.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.#ctor(Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector,Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector)">
            Construct a vector by appending one vector to another vector.
            @param v1 First vector (will be put in front of the new vector).
            @param v2 Second vector (will be put at back of the new vector).
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.#ctor(Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector,Syn.Speech.Helper.Mathematics.Linear.RealVector)">
            Construct a vector by appending one vector to another vector.
            @param v1 First vector (will be put in front of the new vector).
            @param v2 Second vector (will be put at back of the new vector).
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.#ctor(Syn.Speech.Helper.Mathematics.Linear.RealVector,Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector)">
            Construct a vector by appending one vector to another vector.
            @param v1 First vector (will be put in front of the new vector).
            @param v2 Second vector (will be put at back of the new vector).
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.#ctor(Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector,System.Double[])">
            Construct a vector by appending one vector to another vector.
            @param v1 First vector (will be put in front of the new vector).
            @param v2 Second vector (will be put at back of the new vector).
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.#ctor(System.Double[],Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector)">
            Construct a vector by appending one vector to another vector.
            @param v1 First vector (will be put in front of the new vector).
            @param v2 Second vector (will be put at back of the new vector).
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.#ctor(System.Double[],System.Double[])">
            Construct a vector by appending one vector to another vector.
            @param v1 first vector (will be put in front of the new vector)
            @param v2 second vector (will be put at back of the new vector)
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.mapToSelf(Syn.Speech.Helper.Mathematics.Analysis.UnivariateFunction)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.getDataRef">
             Get a reference to the underlying data array.
             This method does not make a fresh copy of the underlying data.
            
             @return the array of entries.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.dotProduct(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.append(Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector)">
             Construct a vector by appending a vector to this vector.
            
             @param v Vector to append to this one.
             @return a new vector.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.setSubVector(System.Int32,System.Double[])">
             Set a set of consecutive elements.
            
             @param index Index of first element to be set.
             @param v Vector containing the values to set.
             @throws OutOfRangeException if the index is inconsistent with the vector
             size.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.checkVectorDimensions(Syn.Speech.Helper.Mathematics.Linear.RealVector)">
             Check if instance and specified vectors have the same dimension.
            
             @param v Vector to compare instance with.
             @throws DimensionMismatchException if the vectors do not
             have the same dimension.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.checkVectorDimensions(System.Int32)">
             Check if instance dimension is equal to some expected value.
            
             @param n Expected dimension.
             @throws DimensionMismatchException if the dimension is
             inconsistent with vector size.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.isNaN">
             Check if any coordinate of this vector is {@code NaN}.
            
             @return {@code true} if any coordinate of this vector is {@code NaN},
             {@code false} otherwise.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.isInfinite">
             Check whether any coordinate of this vector is infinite and none
             are {@code NaN}.
            
             @return {@code true} if any coordinate of this vector is infinite and
             none are {@code NaN}, {@code false} otherwise.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.GetHashCode">
            {@inheritDoc} All {@code NaN} values have the same hash code.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.combine(System.Double,System.Double,Syn.Speech.Helper.Mathematics.Linear.RealVector)">
            {@inheritDoc} 
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.walkInOptimizedOrder(Syn.Speech.Helper.Mathematics.Linear.RealVectorPreservingVisitor)">
             {@inheritDoc}
            
             In this implementation, the optimized order is the default order.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.walkInOptimizedOrder(Syn.Speech.Helper.Mathematics.Linear.RealVectorPreservingVisitor,System.Int32,System.Int32)">
             {@inheritDoc}
            
             In this implementation, the optimized order is the default order.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.walkInOptimizedOrder(Syn.Speech.Helper.Mathematics.Linear.RealVectorChangingVisitor)">
             {@inheritDoc}
            
             In this implementation, the optimized order is the default order.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.ArrayRealVector.walkInOptimizedOrder(Syn.Speech.Helper.Mathematics.Linear.RealVectorChangingVisitor,System.Int32,System.Int32)">
             {@inheritDoc}
            
             In this implementation, the optimized order is the default order.
        </member>
        <member name="T:Syn.Speech.Helper.Mathematics.Linear.MathUtils">
            <summary>
            Miscellaneous utility functions.
            </summary>
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.MathUtils.TWO_PI">
            \(2\pi\)
            @since 2.1
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.MathUtils.PI_SQUARED">
            \(\pi^2\)
            @since 3.4
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.MathUtils.#ctor">
            Class contains only static methods.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.MathUtils.GetHashCode(System.Double)">
             Returns an integer hash code representing the given double value.
            
             @param value the value to be hashed
             @return the hash code
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.MathUtils.Equals(System.Double,System.Double)">
             Returns {@code true} if the values are equal according to semantics of
             {@link Double#equals(Object)}.
            
             @param x Value
             @param y Value
             @return {@code new Double(x).equals(new Double(y))}
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.MathUtils.GetHashCode(System.Double[])">
             Returns an integer hash code representing the given double array.
            
             @param value the value to be hashed (may be null)
             @return the hash code
             @since 1.2
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.Mathematics.Linear.MathUtils.normalizeAngle(System.Double,System.Double)" -->
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.MathUtils.reduce(System.Double,System.Double,System.Double)">
             <p>Reduce {@code |a - offset|} to the primary interval
             {@code [0, |period|)}.</p>
            
             <p>Specifically, the value returned is <br/>
             {@code a - |period| * floor((a - offset) / |period|) - offset}.</p>
            
             <p>If any of the parameters are {@code NaN} or infinite, the result is
             {@code NaN}.</p>
            
             @param a Value to reduce.
             @param period Period.
             @param offset Value that will be mapped to {@code 0}.
             @return the value, within the interval {@code [0 |period|)},
             that corresponds to {@code a}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.MathUtils.copySign(System.Byte,System.Byte)">
             Returns the first argument with the sign of the second argument.
            
             @param magnitude Magnitude of the returned value.
             @param sign Sign of the returned value.
             @return a value with magnitude equal to {@code magnitude} and with the
             same sign as the {@code sign} argument.
             @throws MathArithmeticException if {@code magnitude == Byte.MIN_VALUE}
             and {@code sign >= 0}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.MathUtils.copySign(System.Int16,System.Int16)">
             Returns the first argument with the sign of the second argument.
            
             @param magnitude Magnitude of the returned value.
             @param sign Sign of the returned value.
             @return a value with magnitude equal to {@code magnitude} and with the
             same sign as the {@code sign} argument.
             @throws MathArithmeticException if {@code magnitude == Short.MIN_VALUE}
             and {@code sign >= 0}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.MathUtils.copySign(System.Int32,System.Int32)">
             Returns the first argument with the sign of the second argument.
            
             @param magnitude Magnitude of the returned value.
             @param sign Sign of the returned value.
             @return a value with magnitude equal to {@code magnitude} and with the
             same sign as the {@code sign} argument.
             @throws MathArithmeticException if {@code magnitude == Integer.MIN_VALUE}
             and {@code sign >= 0}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.MathUtils.copySign(System.Int64,System.Int64)">
             Returns the first argument with the sign of the second argument.
            
             @param magnitude Magnitude of the returned value.
             @param sign Sign of the returned value.
             @return a value with magnitude equal to {@code magnitude} and with the
             same sign as the {@code sign} argument.
             @throws MathArithmeticException if {@code magnitude == Long.MIN_VALUE}
             and {@code sign >= 0}.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.MathUtils.checkFinite(System.Double)">
             Check that the argument is a real number.
            
             @param x Argument.
             @throws NotFiniteNumberException if {@code x} is not a
             finite real number.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.MathUtils.checkFinite(System.Double[])">
             Check that all the elements are real numbers.
            
             @param val Arguments.
             @throws NotFiniteNumberException if any values of the array is not a
             finite real number.
        </member>
        <member name="M:Syn.Speech.Helper.Mathematics.Linear.MathUtils.checkNotNull(System.Object)">
             Checks that an object is not null.
            
             @param o Object to be checked.
             @throws NullArgumentException if {@code o} is {@code null}.
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.Solver.lu">
            Entries of LU decomposition. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.Solver.pivot">
            Pivot permutation associated with LU decomposition. 
        </member>
        <member name="F:Syn.Speech.Helper.Mathematics.Linear.Solver.singular">
            Singularity indicator. 
        </member>
        <member name="T:Syn.Speech.Helper.Java">
            <summary>
            Java Extensions
            </summary>
        </member>
        <member name="M:Syn.Speech.Helper.Java.CurrentTimeMillis">
            <summary>
            Extension for Java's System.currentTimeMillis
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Helper.Java.Split(System.String,System.String)">
            <summary>
            Splits the specified string using regex pattern.
            </summary>
            <param name="source">The source.</param>
            <param name="pattern">The pattern.</param>
            <returns></returns>
        </member>
        <member name="T:Syn.Speech.Helper.Map`2">
            <summary>
            Extended dictionary functionality.
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="M:Syn.Speech.Helper.Map`2.Get(`0,`1)">
            <summary>
            Fetches the value associated with the specified key.
            If no value can be found, then the defaultValue is
            returned.
            </summary>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Helper.Map`2.Get(`0)">
            <summary>
            Fetches the value associated with the specified key.
            If no value can be found, then default(V) is returned.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Helper.Map`2.Put(`0,`1)">
            <summary>
            Sets the given key in the dictionary.  If the key
            already exists, then it is remapped to the new value.
            </summary>
        </member>
        <member name="M:Syn.Speech.Helper.Map`2.Push(`0,`1)">
            <summary>
            Sets the given key in the dictionary.  If the key
            already exists, then it is remapped to the new value.
            If a value was previously mapped it is returned.
            </summary>
        </member>
        <member name="M:Syn.Speech.Helper.Map`2.PutAll(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Puts all values from the source dictionary into
            this dictionary.
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:Syn.Speech.Helper.Map`2.Remove(`0,`1@)">
            <summary>
            Removes the item from the dictionary that is associated with
            the specified key.
            </summary>
            <param name="key">Search key into the dictionary</param>
            <param name="value">The value removed from the dictionary (if found).</param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Helper.Map`2.RemoveAndReturn(`0)">
            <summary>
            Removes the item from the dictionary that is associated with
            the specified key.  The item if found is returned; if not,
            default(V) is returned.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Syn.Speech.Helper.Map`2.FirstValue">
            <summary>
            Returns the first value in the enumeration of values
            </summary>
            <returns></returns>
        </member>
        <member name="T:Syn.Speech.Instrumentation.MemoryTracker">
            <summary>
            Monitors a recognizer for memory usage
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.MemoryTracker.PropRecognizer">
            <summary>
            The property that defines which recognizer to monitor.
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.MemoryTracker.PropShowSummary">
            <summary>
            The property that defines whether summary accuracy information is displayed.
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.MemoryTracker.PropShowDetails">
            <summary>
            The property that defines whether detailed accuracy information is displayed.
            </summary>
        </member>
        <member name="M:Syn.Speech.Instrumentation.MemoryTracker.CalculateMemoryUsage(System.Boolean)">
            <summary>
            Shows memory usage
            </summary>
            <param name="show">if set to <c>true</c> [show].</param>
        </member>
        <member name="T:Syn.Speech.Instrumentation.SpeedTracker">
            <summary>
            Monitors a recognizer for speed
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.SpeedTracker.PropRecognizer">
            <summary>
            The property that defines which recognizer to monitor.
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.SpeedTracker.PropFrontend">
            <summary>
            The property that defines which frontend to monitor.
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.SpeedTracker.PropShowSummary">
            <summary>
            The property that defines whether summary accuracy information is displayed.
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.SpeedTracker.PropShowDetails">
            <summary>
            The property that defines whether detailed accuracy information is displayed.
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.SpeedTracker.PropShowResponseTime">
            <summary>
            The property that defines whether detailed response information is displayed.
            </summary>
        </member>
        <member name="F:Syn.Speech.Instrumentation.SpeedTracker.PropShowTimers">
            <summary>
            The property that defines whether detailed timer information is displayed.
            </summary>
        </member>
        <member name="M:Syn.Speech.Instrumentation.SpeedTracker.ShowAudioUsage">
            Shows the audio usage data 
        </member>
        <member name="M:Syn.Speech.Instrumentation.SpeedTracker.ShowAudioSummary">
            Shows the audio summary data 
        </member>
        <member name="M:Syn.Speech.Instrumentation.SpeedTracker.GetSpeed">
             Returns the speed of the last decoding as a fraction of real time.
            
             @return the speed of the last decoding
        </member>
        <member name="M:Syn.Speech.Instrumentation.SpeedTracker.Reset">
            Resets the speed statistics 
        </member>
        <member name="M:Syn.Speech.Instrumentation.SpeedTracker.GetCumulativeSpeed">
             Returns the cumulative speed of this decoder as a fraction of real time.
            
             @return the cumulative speed of this decoder
        </member>
        <member name="P:Syn.Speech.Instrumentation.SpeedTracker.Time">
             Returns the current time in milliseconds
            
             @return the time in milliseconds.
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.Context">
            <summary>
            Represents  the context for a unit
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.Context.EmptyContext">
            <summary>
            Represents an empty context
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Context.#ctor">
            <summary>
            No instantiations allowed
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Context.IsPartialMatch(Syn.Speech.Linguist.Acoustic.Context)">
            <summary>
            Checks to see if there is a partial match with the given context. For a simple context such as this we always
            match.
            </summary>
            <param name="context">the context to check</param>
            <returns>true if there is a partial match</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Context.ToString">
            <summary>
            Provides a string representation of a context
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Context.Equals(System.Object)">
            <summary>
            Determines if an object is equal to this context
            </summary>
            <param name="o">the object to check</param>
            <returns>true if the objects are equal</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Context.GetHashCode">
            <summary>
            calculates a hashCode for this context. Since we defined an equals for context, we must define a hashCode as
            well
            </summary>
            <returns></returns>
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.HMMPool">
            <summary>
            The HMMPool provides the ability to manage units via small integer IDs.  Context Independent units and context
            dependent units can be converted to an ID. IDs can be used to quickly retrieve a unit or an hmm associated with the
            unit.  This class operates under the constraint that context sizes are exactly one, which is generally only valid for
            large vocabulary tasks.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.HMMPool.#ctor(Syn.Speech.Linguist.Acoustic.AcousticModel,Syn.Speech.Linguist.Acoustic.UnitManager)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Linguist.Acoustic.HMMPool"/> class.
            </summary>
            <param name="model">The model to use for the pool</param>
            <param name="unitManager">The unit manager.</param>
            <exception cref="T:System.Exception">
            LexTreeLinguist: Unsupported left context size
            or
            LexTreeLinguist: Unsupported right context size
            </exception>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.HMMPool.SynthesizeUnit(System.Int32)">
                    /// Given a unit ID, generate a full context dependent unit that will allow us to look for a suitable hmm
                     *
                    /// @param id the unit id
                    /// @return a context dependent unit for the ID
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.HMMPool.GetUnit(System.Int32)">
                    /// Gets the unit for the given id
                     *
                    /// @param unitID the id for the unit
                    /// @return the unit associated with the ID
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.HMMPool.GetHMM(System.Int32,Syn.Speech.Linguist.Acoustic.HMMPosition)">
                    /// Given a unit id and a position, return the HMM associated with the
                    /// unit/position.
                     *
                    /// @param unitID   the id of the unit
                    /// @param position the position within the word
                    /// @return the hmm associated with the unit/position
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.HMMPool.GetId(Syn.Speech.Linguist.Acoustic.Unit)">
                    /// given a unit return its ID
                     *
                    /// @param unit the unit
                    /// @return an ID
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.HMMPool.GetSimpleUnitId(Syn.Speech.Linguist.Acoustic.Unit)">
                    /// Returns a context independent ID
                     *
                    /// @param unit the unit of interest
                    /// @return the ID of the central unit (ignoring any context)
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.HMMPool.BuildId(System.Int32,System.Int32,System.Int32)">
                    /// Builds an id from the given unit and its left and right unit ids
                     *
                    /// @param unitID  the id of the central unit
                    /// @param leftID  the id of the left context unit
                    /// @param rightID the id of the right context unit
                    /// @return the id for the context dependent unit
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.HMMPool.GetLeftUnitId(System.Int32)">
                    /// Given a unit id extract the left context unit id
                     *
                    /// @param id the unit id
                    /// @return the unit id of the left context (0 means no left context)
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.HMMPool.GetRightUnitId(System.Int32)">
                    /// Given a unit id extract the right context unit id
                     *
                    /// @param id the unit id
                    /// @return the unit id of the right context (0 means no right context)
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.HMMPool.GetCentralUnitId(System.Int32)">
                    /// Given a unit id extract the central unit id
                     *
                    /// @param id the unit id
                    /// @return the central unit id
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.HMMPool.GetUnitNameFromId(System.Int32)">
                    /// Given an ID, build up a name for display
                     *
                    /// @return the name baed on the ID
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.HMMPool.GetHMM(Syn.Speech.Linguist.Acoustic.Unit,Syn.Speech.Linguist.Acoustic.Unit,Syn.Speech.Linguist.Acoustic.Unit,Syn.Speech.Linguist.Acoustic.HMMPosition)">
                    /// Retrieves an HMM for a unit in context. If there is no direct match, the
                    /// nearest match will be used. Note that we are currently only dealing with,
                    /// at most, single unit left and right contexts.
                    /// 
                    /// @param base the base CI unit
                    /// @param lc  the left context
                    /// @param rc the right context
                    /// @param pos the position of the base unit within the word
                    /// @return the HMM. (This should never return null)
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.HMMPool.DumpInfo">
            <summary>
             Dumps out info about this pool.
            </summary>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.HMMPool.NumCiUnits">
                    /// Returns the number of CI units
                     *
                    /// @return the number of CI Units
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.HmmStateArc">
            <summary>
            Represents a transition to single state in an HMM. 
            All probabilities are maintained in linear base.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.HmmStateArc.#ctor(Syn.Speech.Linguist.Acoustic.IHMMState,System.Single)">
                    /// Constructs an HMMStateArc
                     *
                    /// @param hmmState    destination state for this arc
                    /// @param probability the probability for this transition
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.HmmStateArc.ToString">
            <summary>
            Returns a string representation of the arc
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.HmmStateArc.HmmState">
                    /// Gets the HMM associated with this state
                     *
                    /// @return the HMM
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.HmmStateArc.LogProbability">
                    /// Gets log transition probability
                     *
                    /// @return the probability in the LogMath log domain
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.AcousticModel">
            <summary>
            Represents the generic interface to the Acoustic Model for sphinx4
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.AcousticModel.PropLocation">
            <summary>
            The directory where the acoustic model data can be found.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.AcousticModel.Allocate">
            <summary>
            Gets this acoustic model ready to use, allocating all necessary resources.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.AcousticModel.Deallocate">
            <summary>
            Deallocates previously allocated resources.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.AcousticModel.LookupNearestHMM(Syn.Speech.Linguist.Acoustic.Unit,Syn.Speech.Linguist.Acoustic.HMMPosition,System.Boolean)">
            <summary>
            Given a unit, returns the HMM that best matches the given unit. If exactMatch is false and an exact match is not
            found, then different word positions are used. If any of the contexts are non-silence filler units. a silence
            filler unit is tried instead.
            </summary>
            <param name="unit">The unit of interest.</param>
            <param name="position">The position of the unit of interest.</param>
            <param name="exactMatch">if true, only an exact match is acceptable..</param>
            <returns>The HMM that best matches, or null if no match could be found.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.AcousticModel.GetHMMIterator">
            <summary>
            Gets the HMM iterator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.AcousticModel.GetContextIndependentUnitIterator">
            <summary>
            Gets the Enumerator that can be used to iterate through all the CI units in the acoustic model
            </summary>
            <returns>An Enumerator that can be used to iterate through all CI units. The Enumerator returns objects of type <code>Unit</code></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.AcousticModel.GetLeftContextSize">
            <summary>
            Gets the size of the left context for context dependent units.
            </summary>
            <returns>The left context size.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.AcousticModel.GetRightContextSize">
            <summary>
            Gets the size of the right context for context dependent units.
            </summary>
            <returns>The left context size.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.AcousticModel.GetProperties">
            <summary>
            Gets the properties of this acoustic model.
            </summary>
            <returns>The properties of this acoustic model.</returns>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.AcousticModel.Name">
            <summary>
            Gets the name of this AcousticModel, or null if it has no name.
            </summary>
            <value>
            The name of this AcousticModel, or null if it has no name.
            </value>
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.LeftRightContext">
            <summary>
            Represents  the context for a unit 
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.LeftRightContext.#ctor(Syn.Speech.Linguist.Acoustic.Unit[],Syn.Speech.Linguist.Acoustic.Unit[])">
                    /// Creates a LeftRightContext
                     *
                    /// @param leftContext  the left context or null if no left context
                    /// @param rightContext the right context or null if no right context
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.LeftRightContext.ToString">
            Provides a string representation of a context 
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.LeftRightContext.Get(Syn.Speech.Linguist.Acoustic.Unit[],Syn.Speech.Linguist.Acoustic.Unit[])">
                    /// Factory method for creating a left/right context
                     *
                    /// @param leftContext  the left context or null if no left context
                    /// @param rightContext the right context or null if no right context
                    /// @return a left right context
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.LeftRightContext.GetContextName(Syn.Speech.Linguist.Acoustic.Unit[])">
                    /// Gets the context name for a particular array of units
                     *
                    /// @param context the context
                    /// @return the context name
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.LeftRightContext.IsPartialMatch(Syn.Speech.Linguist.Acoustic.Context)">
                    /// Checks to see if there is a partial match with the given context. If both contexts are LeftRightContexts then  a
                    /// left or right context that is null is considered a wild card and matches anything, othewise the contexts must
                    /// match exactly. Anything matches the Context.EMPTY_CONTEXT
                     *
                    /// @param context the context to check
                    /// @return true if there is a partial match
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.LeftRightContext.LeftContext">
                    /// Retrieves the left context for this unit
                     *
                    /// @return the left context
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.LeftRightContext.RightContext">
                    /// Retrieves the right context for this unit
                     *
                    /// @return the right context
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.Tiedstate.CompositeSenone">
             <summary>
             Represents a composite senone. A composite senone consists of a set of all possible {@link Senone senones} for a
             given state. CompositeSenones are used when the exact context of a senone is not known. The CompositeSenone
             represents all the possible senones.
            
             This class currently only needs to be public for testing purposes.
             
             Note that all scores are maintained in LogMath log base
             </summary>
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.Tiedstate.ScoreCachingSenone">
             <summary>
             Implements a Senone that contains a cache of the last scored data.
            
             Subclasses should implement the abstract {@link #calculateScore} method,
             which is called by the {@link #getScore} method to calculate the score
             for each cache miss.
            
             Note: this implementation is thread-safe and can be safely used
             across different threads without external synchronization.
            
             @author Yaniv Kunda
             </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.ScoreCachingSenone.GetScore(Syn.Speech.FrontEnds.IData)">
            <summary>
            Gets the cached score for this senone based upon the given feature.
            If the score was not cached, it is calculated using {@link #calculateScore},
            cached, and then returned.  
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.ScoreCachingSenone.CalculateScore(Syn.Speech.FrontEnds.IData)">
            <summary>
            Calculates the score for this senone based upon the given feature.
            </summary>
            <param name="feature">The feature vector to score this senone against.</param>
            <returns>The score for this senone in LogMath log base.</returns>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.ScoreCachingSenone.MixtureComponents">
            <summary>
            Returns the mixture components associated with this Gaussian
            </summary>
            <value>The array of mixture components.</value>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.CompositeSenone.Create(System.Collections.Generic.ICollection{Syn.Speech.Linguist.Acoustic.Tiedstate.ISenone},System.Single)">
            <summary>
            A factory method that creates a CompositeSenone from a list of senones.
            </summary>
            <param name="senoneCollection">The Collection of senones.</param>
            <param name="weight">The weight.</param>
            <returns>a composite senone</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.CompositeSenone.#ctor(Syn.Speech.Linguist.Acoustic.Tiedstate.ISenone[],System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Linguist.Acoustic.Tiedstate.CompositeSenone"/> class given the set of constituent senones
            </summary>
            <param name="senones">The set of constituent senones.</param>
            <param name="weight">The weight.</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.CompositeSenone.Dump(System.String)">
            <summary>
            Dumps this senone
            </summary>
            <param name="msg">Annotation for the dump.</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.CompositeSenone.CalculateScore(Syn.Speech.FrontEnds.IData)">
            <summary>
            Calculates the composite senone score. Typically this is the best score for all of the constituent senones
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.CompositeSenone.CalculateComponentScore(Syn.Speech.FrontEnds.IData)">
            <summary>
            Calculate scores for each component in the senone's distribution. Not yet implemented.
            </summary>
            <param name="feature">The current feature.</param>
            <returns>The score for the feature in LogMath.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.CompositeSenone.Equals(System.Object)">
            <summary>
            Determines if two objects are equal
            </summary>
            <param name="o">The object to compare to this.</param>
            <returns>true if the objects are equal</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.CompositeSenone.GetHashCode">
            <summary>
            Returns the hashcode for this object
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.CompositeSenone.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.CompositeSenone.Senones">
            <summary>
            Returns the set of senones that compose this composite senone. This method is only needed for unit testing.
            </summary>
            <value>
            The array of senones.
            </value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.CompositeSenone.ID">
            <summary>
            Gets the ID for this senone.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.GaussianMixture.#ctor(Syn.Speech.Linguist.Acoustic.Tiedstate.GaussianWeights,Syn.Speech.Linguist.Acoustic.Tiedstate.MixtureComponent[],System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Linguist.Acoustic.Tiedstate.GaussianMixture"/> class.
            </summary>
            <param name="mixtureWeights">The mixture weights for this senone in LogMath log base.</param>
            <param name="mixtureComponents">The mixture components for this senone.</param>
            <param name="id">The identifier.</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.GaussianMixture.Dump(System.String)">
            <summary>
            Dumps a senone
            </summary>
            <param name="msg">Annotation message.</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.GaussianMixture.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/>, is equal to this instance.
            </summary>
            <param name="o">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.GaussianMixture.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.GaussianMixture.ToString">
            <summary>
            Retrieves a string form of this object.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.GaussianMixture.CalculateComponentScore(Syn.Speech.FrontEnds.IData)">
            <summary>
            Calculates the scores for each component in the senone.
            </summary>
            <param name="feature">The feature to score.</param>
            <returns>The LogMath log scores for the feature, one for each component.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.GaussianMixture.GetDimension">
            <summary>
            Gets the dimension of the modeled feature space
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.GaussianMixture.GetComponentWeights">
            <summary>
            Gets the (linearly scaled) mixture weights of the component densities
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.GaussianMixture.GetLogComponentWeight(System.Int32)">
            <summary>
            the (log-scaled) mixture weight of the component density<code>index</code>.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.GaussianMixture.NumComponents">
            <summary>
            Numbers the number of component densities of this <code>GaussianMixture</code>.
            </summary>
            <value></value>
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.Tiedstate.GaussianWeights">
            <summary>
            Structure to store weights for all gaussians in AM. 
             Supposed to provide faster access in case of large models
            </summary>
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.Tiedstate.HMMManager">
            <summary>
            Manages HMMs. This HMMManager groups {@link Linguist.Acoustic.HMM HMMs} together by their {@link
            Linguist.Acoustic.HMMPosition position} with the word.
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.Tiedstate.HMMManager._hmmsPerPositionx">
            HMMPosition.class
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.HMMManager.Put(Syn.Speech.Linguist.Acoustic.IHMM)">
            <summary>
            Put an HMM into this manager
            </summary>
            <param name="hmm">The hmm to manage.</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.HMMManager.Get(Syn.Speech.Linguist.Acoustic.HMMPosition,Syn.Speech.Linguist.Acoustic.Unit)">
            <summary>
            Retrieves an HMM by position and unit.
            </summary>
            <param name="position">The position of the HMM.</param>
            <param name="unit">The unit that this HMM represents.</param>
            <returns>The HMM for the unit at the given position or null if no HMM at the position could be found.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.HMMManager.GetEnumerator">
             <summary>
             Gets an iterator that iterates through all HMMs
             </summary>
             <returns>
            an iterator that iterates through all HMMs
             </returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.HMMManager.GetNumHMMs">
            <summary>
            Returns the number of HMMS in this manager
            </summary>
            <returns>The number of HMMs.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.HMMManager.LogInfo">
            <summary>
            Log information about this manager
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.KaldiLoader.#ctor">
                    /// Constructs empty object.
                     *
                    /// Does nothing but is required for instantiation from the context object.
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.KaldiLoader.Load">
                    /// Loads the acoustic model.
                     *
                    /// @throws IOException if an error occurs while loading the model
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.KaldiLoader.LogInfo">
                    /// Logs information about this loader
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.KaldiLoader.SenonePool">
                    /// Gets the senone pool for this loader.
                     *
                    /// @return the pool
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.KaldiLoader.HMMManager">
                    /// Returns the HMM Manager for this loader.
                     *
                    /// @return the HMM Manager
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.KaldiLoader.ContextIndependentUnits">
                    /// Returns the map of context indepent units.
                     *
                    /// The map can be accessed by unit name.
                     *
                    /// @return the map of context independent units
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.KaldiLoader.LeftContextSize">
                    /// Returns the size of the left context for context dependent units.
                     *
                    /// @return the left context size
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.KaldiLoader.RightContextSize">
                    /// Returns the size of the right context for context dependent units.
                     *
                    /// @return the right context size
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.KaldiLoader.Properties">
                    /// Returns the model properties
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.KaldiLoader.MeansPool">
                    /// Not implemented.
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.KaldiLoader.MeansTransformationMatrixPool">
                    /// Not implemented.
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.KaldiLoader.MeansTransformationVectorPool">
                    /// Not implemented.
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.KaldiLoader.VariancePool">
                    /// Not implemented.
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.KaldiLoader.VarianceTransformationMatrixPool">
                    /// Not implemented.
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.KaldiLoader.VarianceTransformationVectorPool">
                    /// Not implemented.
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.KaldiLoader.MixtureWeightsPool">
                    /// Not implemented.
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.KaldiLoader.TransitionMatrixPool">
                    /// Not implemented.
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.KaldiLoader.TransformMatrix">
                    /// Not implemented.
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.Tiedstate.MixtureComponent">
            <summary>
            Defines the set of shared elements for a GaussianMixture. Since these elements are potentially
            shared by a number of {@link GaussianMixture GaussianMixtures}, these elements should not be
            written to. The GaussianMixture defines a single probability density function along with a set of
            adaptation parameters.
            
            Note that all scores and weights are in LogMath log base
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.Tiedstate.MixtureComponent.MeanTransformed">
            <summary>
            Mean after transformed by the adaptation parameters.
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.Tiedstate.MixtureComponent.PrecisionTransformed">
            <summary>
            Precision is the inverse of the variance. This includes adaptation.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.MixtureComponent.#ctor(System.Single[],System.Single[])">
                    /// Create a MixtureComponent with the given sub components.
                     *
                    /// @param mean     the mean vector for this PDF
                    /// @param variance the variance for this PDF
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.MixtureComponent.#ctor(System.Single[],System.Single[][],System.Single[],System.Single[],System.Single[][],System.Single[])">
                    /// Create a MixtureComponent with the given sub components.
                     *
                    /// @param mean                         the mean vector for this PDF
                    /// @param meanTransformationMatrix     transformation matrix for this pdf
                    /// @param meanTransformationVector     transform vector for this PDF
                    /// @param variance                     the variance for this PDF
                    /// @param varianceTransformationMatrix var. transform matrix for this PDF
                    /// @param varianceTransformationVector var. transform vector for this PDF
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.MixtureComponent.#ctor(System.Single[],System.Single[][],System.Single[],System.Single[],System.Single[][],System.Single[],System.Single,System.Single)">
                    /// Create a MixtureComponent with the given sub components.
                     *
                    /// @param mean                         the mean vector for this PDF
                    /// @param meanTransformationMatrix     transformation matrix for this pdf
                    /// @param meanTransformationVector     transform vector for this PDF
                    /// @param variance                     the variance for this PDF
                    /// @param varianceTransformationMatrix var. transform matrix for this PDF
                    /// @param varianceTransformationVector var. transform vector for this PDF
                    /// @param distFloor                    the lowest score value (in linear domain)
                    /// @param varianceFloor                the lowest value for the variance
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.MixtureComponent.GetScore(Syn.Speech.FrontEnds.FloatData)">
                    /// Calculate the score for this mixture against the given feature.
                    /// <p/>
                    /// Note: The support of <code>DoubleData</code>-features would require an array conversion to
                    /// float[]. Because getScore might be invoked with very high frequency, features are restricted
                    /// to be <code>FloatData</code>s.
                     *
                    /// @param feature the feature to score
                    /// @return the score, in log, for the given feature
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.MixtureComponent.GetScore(System.Single[])">
                    /// Calculate the score for this mixture against the given feature. We model the output
                    /// distributions using a mixture of Gaussians, therefore the current implementation is simply
                    /// the computation of a multi-dimensional Gaussian. <p/> <p><b>Normal(x) = exp{-0.5/// (x-m)' *
                    /// inv(Var)/// (x-m)} / {sqrt((2/// PI) ^ N)/// det(Var))}</b></p>
                    /// <p/>
                    /// where <b>x</b> and <b>m</b> are the incoming cepstra and mean vector respectively,
                    /// <b>Var</b> is the Covariance matrix, <b>det()</b> is the determinant of a matrix,
                    /// <b>inv()</b> is its inverse, <b>exp</b> is the exponential operator, <b>x'</b> is the
                    /// transposed vector of <b>x</b> and <b>N</b> is the dimension of the vectors <b>x</b> and
                    /// <b>m</b>.
                     *
                    /// @param feature the feature to score
                    /// @return the score, in log, for the given feature
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.MixtureComponent.PrecomputeDistance">
                    /// Pre-compute factors for the Mahalanobis distance. Some of the Mahalanobis distance
                    /// computation can be carried out in advance. Specifically, the factor containing only variance
                    /// in the Gaussian can be computed in advance, keeping in mind that the the determinant of the
                    /// covariance matrix, for the degenerate case of a mixture with independent components - only
                    /// the diagonal elements are non-zero - is simply the product of the diagonal elements. <p/>
                    /// We're computing the expression: <p/> <p><b>{sqrt((2/// PI) ^ N)/// det(Var))}</b></p>
                     *
                    /// @return the precomputed distance
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.MixtureComponent.TransformStats">
            Applies transformations to means and variances. 
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.MixtureComponent.Mean">
                    /// Returns the mean for this component.
                     *
                    /// @return the mean
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.MixtureComponent.Variance">
                    /// Returns the variance for this component.
                     *
                    /// @return the variance
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMM">
            <summary>
            Represents a hidden-markov-model. An HMM consists of a unit (context dependent or independent), a transition matrix
            from state to state, and a sequence of senones associated with each state. This representation of an HMM is a
            specialized left-to-right markov model. No backward transitions are allowed.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMM.#ctor(Syn.Speech.Linguist.Acoustic.Unit,Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneSequence,System.Single[][],Syn.Speech.Linguist.Acoustic.HMMPosition)">
                    /// Constructs an HMM
                     *
                    /// @param unit             the unit for this HMM
                    /// @param senoneSequence   the sequence of senones for this HMM
                    /// @param transitionMatrix the state transition matrix
                    /// @param position         the position associated with this HMM
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMM.GetState(System.Int32)">
            <summary>
            Retrieves the hmm state
            </summary>
            <param name="which"></param>
            <returns>
            which the state of interest
            </returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMM.IsComposite">
                    /// Determines if this HMM is a composite HMM
                     *
                    /// @return true if this is a composite hmm
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMM.GetTransitionProbability(System.Int32,System.Int32)">
                    /// Returns the transition probability between two states.
                     *
                    /// @param stateFrom the index of the state this transition goes from
                    /// @param stateTo   the index of the state this transition goes to
                    /// @return the transition probability (in log domain)
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMM.IsContextDependent">
                    /// Determines if this HMM corresponds to a context dependent unit
                     *
                    /// @return true if the HMM is context dependent
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMM.GetInitialState">
                    /// Gets the initial states (with probabilities) for this HMM
                     *
                    /// @return the set of arcs that transition to the initial states for this HMM
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMM.ToString">
                    /// Returns the string representation of this object
                     *
                    /// @return the string representation
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMM.Unit">
            <summary>
            Gets the  unit associated with this HMM
            </summary>
            <value>
            the unit associated with this HMM
            </value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMM.BaseUnit">
            <summary>
            Gets the  base unit associated with this HMM
            </summary>
            <value>
            the unit associated with this HMM
            </value>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMM.Order" -->
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMM.SenoneSequence">
                    /// Returns the SenoneSequence associated with this HMM
                     *
                    /// @return the sequence of senones associated with this HMM. The length of the sequence is N, where N is the order
                    ///         of the HMM. Note that senone sequences may be shared among HMMs.
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMM.TransitionMatrix">
                    /// Returns the transition matrix that determines the state transition probabilities for the matrix. Each entry in
                    /// the transition matrix defines the probability of transitioning from one state to the next. For example, the
                    /// probability of transitioning from state 1 to state 2 can be determined by accessing transition matrix
                    /// element[1][2].
                     *
                    /// @return the transition matrix (in log domain) of size NxN where N is the order of the HMM
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMM.Position">
                    /// Retrieves the position of this HMM. Possible
                     *
                    /// @return the position for this HMM
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMM.IsFiller">
                    /// Determines if this HMM represents a filler unit. A filler unit is speech that is not meaningful such as a cough,
                    /// 'um' , 'er', or silence.
                     *
                    /// @return true if the HMM  represents a filler unit
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMMState">
            <summary>
            Represents a single state in an HMM
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMMState.#ctor(Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMM,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMMState"/> class.
            </summary>
            <param name="hmm">The HMM for this state.</param>
            <param name="which">The index for this particular state.</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMMState.GetScore(Syn.Speech.FrontEnds.IData)">
            <summary>
            Gets the score for this HMM state
            </summary>
            <param name="feature">The feature to be scored.</param>
            <returns>The acoustic score for this state.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMMState.CalculateComponentScore(Syn.Speech.FrontEnds.IData)">
            <summary>
            Gets the scores for each mixture component in this HMM state
            </summary>
            <param name="feature">The feature to be scored.</param>
            <returns>The acoustic scores for the components of this state.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMMState.Equals(System.Object)">
            <summary>
            Determines if two HMMStates are equal
            </summary>
            <param name="other">The state to compare this one to.</param>
            <returns>true if the states are equal.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMMState.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMMState.GetSuccessors">
            <summary>
            Retrieves the state of successor states for this state.
            </summary>
            <returns>
            The set of successor state arcs.
            </returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMMState.IsExitState">
            <summary>
            Determines if this state is an exit state of the HMM.
            </summary>
            <returns>
            true if the state is an exit state.
            </returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMMState.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMMState.HMM">
            <summary>
            Gets the HMM associated with this state
            </summary>
            <value>
            the HMM
            </value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMMState.State">
            <summary>
            Gets the state
            </summary>
            <value>
            the state
            </value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMMState.Senone">
            <summary>
            Gets the senone for this HMM state
            </summary>
            <value>
            The senone for this state.
            </value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneHMMState.IsEmitting">
            <summary>
            Determines if this HMMState is an emitting state
            </summary>
            <value>
            true if the state is an emitting state
            </value>
            TODO: We may have non-emitting entry states as well.
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneSequence">
            <summary>
            Contains an ordered list of senones.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneSequence.Create(System.Collections.Generic.List{Syn.Speech.Linguist.Acoustic.Tiedstate.CompositeSenone})">
                    /// a factory method that creates a SeononeSequence from a list of senones.
                     *
                    /// @param senoneList the list of senones
                    /// @return a composite senone
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneSequence.#ctor(Syn.Speech.Linguist.Acoustic.Tiedstate.ISenone[])">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneSequence"/> class.
            </summary>
            <param name="sequence">The ordered set of senones for this sequence.</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneSequence.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneSequence.Equals(System.Object)">
            <summary>
            Returns true if the objects are equal.
            </summary>
            <param name="o">The o.</param>
            <returns>true  if the objects are equal.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneSequence.Dump(System.String)">
            <summary>
            Dumps this senone sequence
            </summary>
            <param name="msg">The string annotation.</param>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.SenoneSequence.Senones">
            <summary>
            Gets the ordered set of senones for this sequence.
            </summary>
            <value>
            The ordered set of senones for this sequence.
            </value>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader" -->
        <member name="F:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.PropUnitManager">
                   /// The unit manager
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.PropLocation">
                    /// The root location of the model directory structure
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.PropModel">
                    /// The name of the model definition file (contains the HMM data)
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.PropDataLocation">
                    /// Subfolder where the acoustic model can be found
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.PropUseCdUnits">
                    /// The property specifying whether context-dependent units should be used.
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.PropMcFloor">
                    /// Mixture component score floor.
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.PropVarianceFloor">
                    /// Variance floor.
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.PropMwFloor">
                    /// Mixture weight floor.
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.PropTopn">
            Number of top Gaussians to use in scoring
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.ModelVersion">
            <summary>
            Supports this version of the acoustic model
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.LoadModelFiles(System.String)">
            <summary>
             Loads the AcousticModel from a directory in the file system.
            </summary>
            <param name="modelDef">the name of the acoustic modelDef; if null we just load from the default location</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.CreateSenonePool(System.Single,System.Single)">
                    /// Creates the senone pool from the rest of the pools.
                    /// 
                    /// @param distFloor
                    ///            the lowest allowed score
                    /// @param varianceFloor
                    ///            the lowest allowed variance
                    /// @return the senone pool
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.LoadDensityFile(System.String,System.Single)">
                    /// Loads the sphinx3 density file, a set of density arrays are created and
                    /// placed in the given pool.
                    /// 
                    /// @param path
                    ///            the name of the data
                    /// @param floor
                    ///            the minimum density allowed
                    /// @return a pool of loaded densities
                    /// @throws FileNotFoundException
                    ///             if a file cannot be found
                    /// @throws IOException
                    ///             if an error occurs while loading the data
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.ReadS3BinaryHeader(System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
                    /// Reads the S3 binary header from the given location + path. Adds header
                    /// information to the given set of properties.
                    /// 
                    /// @param path
                    ///            the name of the file
                    /// @param props
                    ///            the properties
                    /// @return the input stream positioned after the header
                    /// @throws IOException
                    ///             on error
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.ReadWord(System.IO.Stream)">
                    /// Reads the next word (text separated by whitespace) from the given stream.
                    /// 
                    /// @param dis
                    ///            the input stream
                    /// @return the next word
                    /// @throws IOException
                    ///             on error
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.ReadChar(System.IO.Stream)">
                    /// Reads a single char from the stream.
                    /// 
                    /// @param dis
                    ///            the stream to read
                    /// @return the next character on the stream
                    /// @throws IOException
                    ///             if an error occurs
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.ResetChecksum">
                    /// Resets the checksum before loading a new chunk of data
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.ValidateChecksum(System.IO.Stream,System.Boolean)">
                    /// Validates checksum in the stream
                    /// 
                    /// @param dis
                    ///            input stream
                    /// @param doCheckSum
                    ///            validates
                    /// @throws IOException
                    ///             on error
                     *
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.readInt(System.IO.Stream)">
                    /// Read an integer from the input stream, byte-swapping as necessary.
                    /// 
                    /// @param dis
                    ///            the input stream
                    /// @return an integer value
                    /// @throws IOException
                    ///             on error
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.ReadFloat(System.IO.Stream)">
                    /// Read a float from the input stream, byte-swapping as necessary.
                    /// 
                    /// @param dis
                    ///            the input stream
                    /// @return a floating pint value
                    /// @throws IOException
                    ///             on error
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.ReadFloatArray(System.IO.Stream,System.Int32)">
                    /// Reads the given number of floats from the stream and returns them in an
                    /// array of floats.
                    /// 
                    /// @param dis
                    ///            the stream to read data from
                    /// @param size
                    ///            the number of floats to read
                    /// @return an array of size float elements
                    /// @throws IOException
                    ///             if an exception occurs
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.LoadHMMPool(System.Boolean,System.IO.Stream,System.String)">
                    /// Loads the sphinx3 density file, a set of density arrays are created and
                    /// placed in the given pool.
                    /// 
                    /// @param useCDUnits
                    ///            if true, loads also the context dependent units
                    /// @param inputStream
                    ///            the open input stream to use
                    /// @param path
                    ///            the path to a density file
                    /// @throws FileNotFoundException
                    ///             if a file cannot be found
                    /// @throws IOException
                    ///             if an error occurs while loading the data
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.SameSenoneSequence(System.Int32[],System.Int32[])">
                    /// Returns true if the given senone sequence IDs are the same.
                    /// 
                    /// @return true if the given senone sequence IDs are the same, false
                    ///         otherwise
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.GetSenoneSequence(System.Int32[])">
                    /// Gets the senone sequence representing the given senones.
                    /// 
                    /// @param stateid
                    ///            is the array of senone state ids
                    /// @return the senone sequence associated with the states
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.LoadMixtureWeights(System.String,System.Single)">
                    /// Loads the mixture weights (Binary).
                    /// 
                    /// @param path
                    ///            the path to the mixture weight file
                    /// @param floor
                    ///            the minimum mixture weight allowed
                    /// @return a pool of mixture weights
                    /// @throws FileNotFoundException
                    ///             if a file cannot be found
                    /// @throws IOException
                    ///             if an error occurs while loading the data
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.LoadTransitionMatrices(System.String)">
                    /// Loads the transition matrices (Binary).
                    /// 
                    /// @param path
                    ///            the path to the transitions matrices
                    /// @return a pool of transition matrices
                    /// @throws FileNotFoundException
                    ///             if a file cannot be found
                    /// @throws IOException
                    ///             if an error occurs while loading the data
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.LoadTransformMatrix(System.String)">
                    /// Loads the transform matrices (Binary).
                    /// 
                    /// @param path
                    ///            the path to the transform matrix
                    /// @return a transform matrix
                    /// @throws java.io.FileNotFoundException
                    ///             if a file cannot be found
                    /// @throws java.io.IOException
                    ///             if an error occurs while loading the data
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.HmmManager">
                    /// Return the HmmManager.
                    /// 
                    /// @return the hmmManager
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.MatrixPool">
                    /// Return the MatrixPool.
                    /// 
                    /// @return the matrixPool
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.Sphinx3Loader.MixtureWeightsPool">
                    /// Return the MixtureWeightsPool.
                    /// 
                    /// @return the mixtureWeightsPool
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.Tiedstate.Tiedmixture.MixtureComponentSet">
            <summary>
            MixtureComponentsSet - phonetically tied set of gaussians
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Tiedmixture.MixtureComponentSet.ClearStoredScores">
            <summary>
            Should be called on each new utterance to scores for old frames.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Tiedmixture.MixtureComponentSet.SetScoreQueueLength(System.Int32)">
            How long scores for previous frames should be stored.
            For fast match this value is lookahead_window_length + 1)
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.Tiedstate.Tiedmixture.MixtureComponentSetScores">
            Class to keep scores of mixture components for certain frame.
            Is use useful in case of fast match to avoid scoring gaussians twice
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.Tiedmixture.SetBasedGaussianMixture.CalculateComponentScore(Syn.Speech.FrontEnds.IData)">
             Calculates the scores for each component in the senone.
            
             @param feature the feature to score
             @return the LogMath log scores for the feature, one for each component
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.Tiedmixture.SetBasedGaussianMixture.NumComponents">
            @return the number of component densities of this <code>GaussianMixture</code>. 
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel">
            <summary>
            
            Loads a tied-state acoustic model generated by the Sphinx-3 trainer.
            <p/>
            <p/>
            It is not the goal of this documentation to provide an explanation about the concept of HMMs. The explanation below
            is superficial, and provided only in a way that the files in the acoustic model package make sense.
            <p/>
            An HMM models a process using a sequence of states. Associated with each state, there is a probability density
            function. A popular choice for this function is a Gaussian mixture, that is, a summation of Gaussians. As you may
            recall, a single Gaussian is defined by a mean and a variance, or, in the case of a multidimensional Gaussian, by a
            mean vector and a covariance matrix, or, under some simplifying assumptions, a variance vector. The "means" and
            "variances" files in the "continuous" directory contain exactly this: a table in which each line contains a mean
            vector or a variance vector respectively. The dimension of these vectors is the same as the incoming data, the
            encoded speech signal. The Gaussian mixture is a summation of Gaussians, with different weights for different
            Gaussians. The "mixture_weights" file contains this: each line contains the weights for a combination of Gaussians.
            <p/>
            The HMM is a model with a set of states. The transitions between states have an associated probability. These
            probabilities make up the transition matrices stored in the "transition_matrices" file.
            <p/>
            The files in the "continuous" directory are, therefore, tables, or pools, of means, variances, mixture weights, and
            transition probabilities.
            <p/>
            The dictionary is a file that maps words to their phonetic transcriptions, that is, it maps words to sequences of
            phonemes.
            <p/>
            The language model contains information about probabilities of words in a language. These probabilities could be for
            individual words or for sequences of two or three words.
            <p/>
            The model definition file in a way ties everything together. If the recognition system models phonemes, there is an
            HMM for each phoneme. The model definition file has one line for each phoneme. The phoneme could be in a context
            dependent or independent. Each line, therefore, identifies a unique HMM. This line has the phoneme identification,
            the non-required left or right context, the index of a transition matrix, and, for each state, the index of a mean
            vector, a variance vector, and a set of mixture weights.
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.PropLoader">
            The property that defines the component used to load the acoustic model 
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.PropUnitManager">
            The property that defines the unit manager 
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.PropUseComposites">
            Controls whether we generate composites or CI units when no context is given during a lookup. 
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.Allocate">
                    /// initialize this acoustic model with the given name and context.
                     *
                    /// @throws IOException if the model could not be loaded
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.GetCompositeHMM(Syn.Speech.Linguist.Acoustic.Unit,Syn.Speech.Linguist.Acoustic.HMMPosition)">
                    /// Gets a composite HMM for the given unit and context
                     *
                    /// @param unit     the unit for the hmm
                    /// @param position the position of the unit within the word
                    /// @return a composite HMM
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.LookupNearestHMM(Syn.Speech.Linguist.Acoustic.Unit,Syn.Speech.Linguist.Acoustic.HMMPosition,System.Boolean)">
                    /// Given a unit, returns the HMM that best matches the given unit. If exactMatch is false and an exact match is not
                    /// found, then different word positions are used. If any of the contexts are non-silence filler units. a silence
                    /// filler unit is tried instead.
                     *
                    /// @param unit       the unit of interest
                    /// @param position   the position of the unit of interest
                    /// @param exactMatch if true, only an exact match is acceptable.
                    /// @return the HMM that best matches, or null if no match could be found.
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.IsComposite(Syn.Speech.Linguist.Acoustic.Unit)">
                    /// Determines if a unit is a composite unit
                     *
                    /// @param unit the unit to test
                    /// @return true if the unit is missing a right context
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.lookupUnit(System.String)">
                    /// Looks up the context independent unit given the name
                     *
                    /// @param name the name of the unit
                    /// @return the unit or null if the unit was not found
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.GetHMMIterator">
                    /// Returns an iterator that can be used to iterate through all the HMMs of the acoustic model
                     *
                    /// @return an iterator that can be used to iterate through all HMMs in the model. The iterator returns objects of
                    ///         type <code>HMM</code>.
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.GetContextIndependentUnitIterator">
                    /// Returns an iterator that can be used to iterate through all the CI units in the acoustic model
                     *
                    /// @return an iterator that can be used to iterate through all CI units. The iterator returns objects of type
                    ///         <code>Unit</code>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.GetCompositeSenoneSequence(Syn.Speech.Linguist.Acoustic.Unit,Syn.Speech.Linguist.Acoustic.HMMPosition)">
                    /// Get a composite senone sequence given the unit.
                     *
                    /// The unit should have a LeftRightContext, where one or two of 'left' or
                    /// 'right' may be null to indicate that the match should succeed on any
                    /// context.
                     *
                    /// @param unit the unit
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.GetLeftContextSize">
                    /// Returns the size of the left context for context dependent units
                     *
                    /// @return the left context size
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.GetRightContextSize">
                    /// Returns the size of the right context for context dependent units
                     *
                    /// @return the left context size
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.lookupHMM(Syn.Speech.Linguist.Acoustic.Unit,Syn.Speech.Linguist.Acoustic.HMMPosition)">
                    /// Given a unit, returns the HMM that exactly matches the given unit.
                     *
                    /// @param unit     the unit of interest
                    /// @param position the position of the unit of interest
                    /// @return the HMM that exactly matches, or null if no match could be found.
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.LogInfo">
            Dumps information about this model to the logger 
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.GetHMMAtAnyPosition(Syn.Speech.Linguist.Acoustic.Unit)">
                    /// Searches an hmm at any position
                     *
                    /// @param unit the unit to search for
                    /// @return hmm the hmm or null if it was not found
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.GetHMMInSilenceContext(Syn.Speech.Linguist.Acoustic.Unit,Syn.Speech.Linguist.Acoustic.HMMPosition)">
                    /// Given a unit, search for the HMM associated with this unit by replacing all non-silence filler contexts with the
                    /// silence filler context
                     *
                    /// @param unit the unit of interest
                    /// @return the associated hmm or null
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.HasNonSilenceFiller(Syn.Speech.Linguist.Acoustic.Unit[])">
                    /// Returns true if the array of units contains a non-silence filler
                     *
                    /// @param units the units to check
                    /// @return true if the array contains a filler that is not the silence filler
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.ReplaceNonSilenceFillerWithSilence(Syn.Speech.Linguist.Acoustic.Unit[])">
                    /// Returns a unit array with all non-silence filler units replaced with the silence filler a non-silence filler
                     *
                    /// @param context the context to check
                    /// @return true if the array contains a filler that is not the silence filler
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.GetProperties">
                    /// Returns the properties of this acoustic model.
                     *
                    /// @return the properties of this acoustic model
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Tiedstate.TiedStateAcousticModel.Name">
                    /// Returns the name of this AcousticModel, or null if it has no name.
                     *
                    /// @return the name of this AcousticModel, or null if it has no name
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.Unit">
            <summary>
            Represents a unit of speech. Units may represent phones, words or any other suitable unit
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Unit.#ctor(System.String,System.Boolean,System.Int32)">
            <summary>
            Constructs a context independent unit. Constructors are package private, use the UnitManager to create and access
            units.
            </summary>
            <param name="name">the name of the unit</param>
            <param name="filler"><code>true</code> if the unit is a filler unit</param>
            <param name="id">the base id for the unit</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Unit.#ctor(Syn.Speech.Linguist.Acoustic.Unit,System.Boolean,Syn.Speech.Linguist.Acoustic.Context)">
            <summary>
            Constructs a context independent unit. Constructors are package private, use the UnitManager to create and access
            units.
            </summary>
            <param name="baseUnit">the base id for the unit</param>
            <param name="filler"><code>true</code> if the unit is a filler unit</param>
            <param name="context"></param>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Unit.IsContextDependent">
            <summary>
            Determines if this unit is context dependent
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Unit.GetKey">
            <summary>
            gets the key for this unit
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Unit.Equals(System.Object)">
            <summary>
            Checks to see of an object is equal to this unit
            </summary>
            <param name="o">the object to check</param>
            <returns>true if the objects are equal</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Unit.GetHashCode">
            <summary>
            calculates a hashCode for this unit. Since we defined an equals for Unit, we must define a hashCode as well
            </summary>
            <returns>the hashcode for this object</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Unit.ToString">
            <summary>
            Converts to a string
            </summary>
            <returns>string version</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Unit.IsPartialMatch(System.String,Syn.Speech.Linguist.Acoustic.Context)">
            <summary>
            Checks to see if the given unit with associated contexts is a partial match for this unit.   Zero, One or both
            contexts can be null. A null context matches any context
            </summary>
            <param name="name">the name of the unit</param>
            <param name="context">the  context to match against</param>
            <returns>true if this unit matches the name and non-null context</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Unit.GetEmptyContext(System.Int32)">
            <summary>
            Creates and returns an empty context with the given size. The context is padded with SIL filler
            </summary>
            <param name="size">the size of the context</param>
            <returns>the context</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.Unit.IsContextMatch(Syn.Speech.Linguist.Acoustic.Unit[],Syn.Speech.Linguist.Acoustic.Unit[])">
            <summary>
            Checks to see that there is 100% overlap in the given contexts
            </summary>
            <param name="a">context to check for a match</param>
            <param name="b">context to check for a match</param>
            <returns><code>true</code> if the contexts match</returns>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Unit.Name">
            <summary>
            Gets the name for this unit
            </summary>
            <value>the name for this unit</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Unit.IsFiller">
            <summary>
            Determines if this unit is a filler unit
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Unit.IsSilence">
            <summary>
            Determines if this unit is the silence unit
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Unit.BaseID">
            <summary>
            Gets the  base unit id associated with this HMM
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Unit.BaseUnit">
            <summary>
            Gets the  base unit associated with this HMM
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Linguist.Acoustic.Unit.Context">
            <summary>
            Returns the context for this unit
            </summary>
            <value></value>
        </member>
        <member name="T:Syn.Speech.Linguist.Acoustic.UnitManager">
            <summary>
            Manages the set of units for a recognizer
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.UnitManager.SilenceName">
            <summary>
            The name for the silence unit
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Acoustic.UnitManager.Silence">
            The silence unit
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.UnitManager.GetUnit(System.String,System.Boolean,Syn.Speech.Linguist.Acoustic.Context)">
            <summary>
             Gets or creates a unit from the unit pool
            </summary>
            <param name="name">the name of the unit</param>
            <param name="filler"><code>true</code> if the unit is a filler unit</param>
            <param name="context"> the context for this unit</param>
            <returns>the unit</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.UnitManager.GetUnit(System.String,System.Boolean)">
            <summary>
            Gets or creates a unit from the unit pool
            </summary>
            <param name="name"></param>
            <param name="filler"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Acoustic.UnitManager.GetUnit(System.String)">
            <summary>
            Gets or creates a unit from the unit pool
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Linguist.Linguist" -->
        <member name="F:Syn.Speech.Linguist.Linguist.PropWordInsertionProbability">
            <summary>
             Word insertion probability property 
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Linguist.PropUnitInsertionProbability">
            <summary>
             Unit insertion probability property 
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Linguist.PropSilenceInsertionProbability">
            <summary>
            Silence insertion probability property
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Linguist.PropFillerInsertionProbability">
            <summary>
            Filler insertion probability property
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Linguist.PropLanguageWeight">
            <summary>
            The property that defines the language weight for the search
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Linguist.StartRecognition">
                    /// Called before a recognition. This method gives a linguist the opportunity to prepare itself before a recognition
                    /// begins.
                    /// <p/>
                    /// <p/>
                    /// Implementor's Note - Some linguists (or underlying lanaguge or acoustic models) may keep caches or pools that
                    /// need to be initialzed before a recognition. A linguist may implement this method to perform such initialization.
                    /// Note however, that an ideal linguist will, once allocated, be state-less. This will allow the linguist to be
                    /// shared by multiple simulataneous searches. Reliance on a 'startRecognition' may prevent a linguist from being
                    /// used in a multi-threaded search.
        </member>
        <member name="M:Syn.Speech.Linguist.Linguist.StopRecognition">
                    /// Called after a recognition. This method gives a linguist the opportunity to clean up after a recognition has been
                    /// completed.
                    /// <p/>
                    /// <p/>
                    /// Implementor's Note - Some linguists (or underlying lanaguge or acoustic models) may keep caches or pools that
                    /// need to be flushed after a recognition. A linguist may implement this method to perform such flushing. Note
                    /// however, that an ideal linguist will once allocated, be state-less. This will allow the linguist to be shared by
                    /// multiple simulataneous searches. Reliance on a 'stopRecognition' may prevent a linguist from being used in a
                    /// multi-threaded search.
        </member>
        <member name="M:Syn.Speech.Linguist.Linguist.Allocate">
                    /// Allocates the linguist. Resources allocated by the linguist are allocated here. This method may take many seconds
                    /// to complete depending upon the linguist.
                    /// <p/>
                    /// <p/>
                    /// Implementor's Note - A well written linguist will allow allocate to be called multiple times without harm. This
                    /// will allow a linguist to be shared by multiple search managers.
                     *
                    /// @throws IOException if an IO error occurs
        </member>
        <member name="M:Syn.Speech.Linguist.Linguist.Deallocate">
                    /// Deallocates the linguist. Any resources allocated by this linguist are released.
                    /// <p/>
                    /// <p/>
                    /// Implementor's Note - if the linguist is being shared by multiple searches, the deallocate should only actually
                    /// deallocate things when the last call to deallocate is made. Two approaches for dealing with this:
                    /// <p/>
                    /// (1) Keep an allocation counter that is incremented during allocate and decremented during deallocate. Only when
                    /// the counter reaches zero should the actually deallocation be performed.
                    /// <p/>
                    /// (2) Do nothing in dellocate - just the the GC take care of things
        </member>
        <member name="P:Syn.Speech.Linguist.Linguist.SearchGraph">
                    /// Retrieves search graph.  The search graph represents the search space to be used to guide the search.
                    /// <p/>
                    /// <p/>
                    /// Implementor's note: This method is typically called at the beginning of each recognition and therefore should be
                     *
                    /// @return the search graph
        </member>
        <member name="F:Syn.Speech.Linguist.Allphone.AllphoneLinguist.PropAcousticModel">
            <summary>
            The property that defines the acoustic model to use when building the search graph.
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Allphone.AllphoneLinguist.PropPip">
            <summary>
            The property that controls phone insertion probability.
            Default value for context independent phoneme decoding is 0.05,
            while for context dependent - 0.01.
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Allphone.AllphoneLinguist.PropCD">
            <summary>
            The property that controls whether to use context dependent phones.
            Changing it for true, don't forget to tune phone insertion probability.
            </summary>
        </member>
        <member name="T:Syn.Speech.Linguist.ISearchGraph">
            <summary>
            Represents a search graph
            </summary>
        </member>
        <member name="P:Syn.Speech.Linguist.ISearchGraph.InitialState">
            <summary>
            Retrieves initial search state
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Linguist.ISearchGraph.NumStateOrder">
            <summary>
            Returns the number of different state types maintained in the search graph
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Linguist.ISearchGraph.WordTokenFirst">
            <summary>
            Returns order of words and data tokens
            </summary>
            <value></value>
        </member>
        <member name="T:Syn.Speech.Linguist.ISearchState">
            <summary>
            Represents a single state in a language search space
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.ISearchState.GetSuccessors">
            <summary>
            Gets a successor to this search state
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.ISearchState.ToPrettyString">
            <summary>
            Returns a pretty version of the string representation for this object.
            </summary>
            <returns>A pretty string</returns>
        </member>
        <member name="P:Syn.Speech.Linguist.ISearchState.IsEmitting">
            <summary>
            Gets a value indicating whether this is an emitting state
            </summary>
            <value>
            <c>true</c> if this instance is emitting; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Syn.Speech.Linguist.ISearchState.IsFinal">
            <summary>
            Determines if this is a final state
            </summary>
            <value>
            <c>true</c> if the state is a final state; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Syn.Speech.Linguist.ISearchState.Signature">
            <summary>
            Returns a unique signature for this state
            </summary>
            <value>
            The signature for the state.
            </value>
        </member>
        <member name="P:Syn.Speech.Linguist.ISearchState.WordHistory">
            <summary>
            Gets the word history for this state.
            </summary>
            <value>
            The word history.
            </value>
        </member>
        <member name="P:Syn.Speech.Linguist.ISearchState.LexState">
            <summary>
            Gets the lex tree state.
            </summary>
            <value>
            The lex tree state.
            </value>
        </member>
        <member name="P:Syn.Speech.Linguist.ISearchState.Order">
            <summary>
             Returns the order of this particular state.
            </summary>
            <value>
            The state order for this state.
            </value>
        </member>
        <member name="T:Syn.Speech.Linguist.ISearchStateArc">
            Represents a single state in a language search space 
        </member>
        <member name="M:Syn.Speech.Linguist.ISearchStateArc.GetProbability">
             Gets the composite probability of entering this state
            
             @return the log probability
        </member>
        <member name="P:Syn.Speech.Linguist.ISearchStateArc.State">
             Gets a successor to this search state
            
             @return the successor state
        </member>
        <member name="P:Syn.Speech.Linguist.ISearchStateArc.LanguageProbability">
             Gets the language probability of entering this state
            
             @return the log probability
        </member>
        <member name="P:Syn.Speech.Linguist.ISearchStateArc.InsertionProbability">
             Gets the insertion probability of entering this state
            
             @return the log probability
        </member>
        <member name="M:Syn.Speech.Linguist.Allphone.PhoneHmmSearchState.GetSuccessors">
            <summary>
            If we are final, transfer to all possible phones, otherwise return all successors of this hmm state.
            </summary>
        </member>
        <member name="T:Syn.Speech.Linguist.IWordSearchState">
            <summary>
            Represents a single word state in a language search space
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.IWordSearchState.IsWordStart">
            <summary>
            Returns true if this WordSearchState indicates the start of a word. Returns false if this WordSearchState
            indicates the end of a word.
            </summary>
            <returns>true if this WordSearchState indicates the start of a word, false if this WordSearchState indicates the
                    end of a word</returns>
        </member>
        <member name="P:Syn.Speech.Linguist.IWordSearchState.Pronunciation">
            <summary>
            Gets the word (as a pronunciation)
            </summary>
            <value></value>
        </member>
        <member name="T:Syn.Speech.Linguist.Dictionary.IDictionary">
            <summary>
            Provides a generic interface to a dictionary. The dictionary is responsible for determining how a word is
            pronounced.
            </summary>
            
        </member>
        <member name="F:Syn.Speech.Linguist.Dictionary.IDictionary.SentenceStartSpelling">
            <summary>
             Spelling of the sentence start word. 
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Dictionary.IDictionary.SentenceEndSpelling">
            <summary>
            Spelling of the sentence end word. 
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Dictionary.IDictionary.SilenceSpelling">
            <summary>
            Spelling of the 'word' that marks a silence 
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Dictionary.IDictionary.PropDictionary">
            <summary>
            The property for the dictionary file path. 
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Dictionary.IDictionary.PropG2PModelPath">
            <summary>
            The property for the g2p model file path. 
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Dictionary.IDictionary.PropG2PMaxPronunciations">
            <summary>
            The property for the g2p model file path. 
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Dictionary.IDictionary.PropFillerDictionary">
            <summary>
            The property for the filler dictionary file path. 
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Dictionary.IDictionary.PropAddSilEndingPronunciation">
            <summary>
            The property that specifies whether to add a duplicate SIL-ending pronunciation. 
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Dictionary.IDictionary.PropWordReplacement">
            <summary>
            The property that specifies the word to substitute when a lookup fails to find the word in the
            dictionary. If this is not set, no substitute is performed.
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Dictionary.IDictionary.PropAllowMissingWords">
            <summary>
            The property that specifies whether the dictionary should return null if a word is not found in
            the dictionary, or whether it should throw an error. If true, a null is returned for words that are not found in
            the dictionary (and the 'PROP_WORD_REPLACEMENT' property is not set).
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Dictionary.IDictionary.PropCreateMissingWords">
                    /// The property that specifies whether the Dictionary.getWord() method should return a Word object even if the
                    /// word does not exist in the dictionary. If this property is true, and property allowMissingWords is also true, the
                    /// method will return a Word, but the Word will have null Pronunciations. Otherwise, the method will return null.
                    /// This property is usually only used for testing purposes.
        </member>
        <member name="F:Syn.Speech.Linguist.Dictionary.IDictionary.PropUnitManager">
            The property that defines the name of the unit manager that is used to convert strings to Unit objects 
        </member>
        <member name="F:Syn.Speech.Linguist.Dictionary.IDictionary.PropAddenda">
                    /// The property for the custom dictionary file paths. This addenda property points to a possibly
                    /// empty list of URLs to dictionary addenda.  Each addendum should contain word pronunciations in the same Sphinx-3
                    /// dictionary format as the main dictionary.  Words in the addendum are added after the words in the main dictionary
                    /// and will override previously specified pronunciations.  If you wish to extend the set of pronunciations for a
                    /// particular word, add a new pronunciation by number.  For example, in the following addendum, given that the
                    /// aforementioned main dictionary is specified, the pronunciation for 'EIGHT' will be overridden by the addenda,
                    /// while the pronunciation for 'SIX' and 'ZERO' will be augmented and a new pronunciation for 'ELEVEN' will be
                    /// added.
                    /// <pre>
                    ///          EIGHT   OW T
                    ///          SIX(2)  Z IH K S
                    ///          ZERO(3)  Z IY Rl AH
                    ///          ELEVEN   EH L EH V AH N
                    /// </pre>
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.IDictionary.GetWord(System.String)">
            <summary>
            Returns a Word object based on the spelling and its classification. The behavior of this method is also affected
            by the properties wordReplacement, allowMissingWords, and createMissingWords.
            </summary>
            <param name="text">the spelling of the word of interest.</param>
            <returns>a Word object</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.IDictionary.GetSentenceStartWord">
            <summary>
            Returns the sentence start word.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.IDictionary.GetSentenceEndWord">
            <summary>
            Returns the sentence end word.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.IDictionary.GetSilenceWord">
            <summary>
            Returns the silence word.
            </summary>
            <returns>the silence word</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.IDictionary.GetFillerWords">
            <summary>
            Gets the set of all filler words in the dictionary
            </summary>
            <returns>an array (possibly empty) of all filler words</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.IDictionary.Allocate">
            <summary>
            Allocates the dictionary
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.IDictionary.Deallocate">
            <summary>
            Deallocates the dictionary
            </summary>
        </member>
        <member name="T:Syn.Speech.Linguist.Dictionary.MappingDictionary">
            <summary>
            Maps the phones from one phoneset to another to use dictionary from the one
            acoustic mode with another one. The mapping file is specified with a mapList
            property. The contents should look like
            <para>
            AX AH
            IX IH
            </para>
            </summary>
        </member>
        <member name="T:Syn.Speech.Linguist.Dictionary.TextDictionary">
            Creates a dictionary by quickly reading in an ASCII-based Sphinx-3 format
            dictionary. When loaded the dictionary just loads each line of the dictionary
            into the hash table, assuming that most words are not going to be used. Only
            when a word is actually used is its pronunciations massaged into an array of
            pronunciations.
            <p/>
            The format of the ASCII dictionary is the word, followed by spaces or tab,
            followed by the pronunciation(s). For example, a digits dictionary will look
            like:
            <p/>
            
            <pre>
             ONE HH W AH N
             ONE(2) W AH N
             TWO T UW
             THREE TH R IY
             FOUR F AO R
             FIVE F AY V
             SIX S IH K S
             SEVEN S EH V AH N
             EIGHT EY T
             NINE N AY N
             ZERO Z IH R OW
             ZERO(2) Z IY R OW
             OH OW
            </pre>
            <p/>
            <p/>
            In the above example, the words "one" and "zero" have two pronunciations
            each.
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.TextDictionary.GetWordDictionaryFile">
            Get the word dictionary file
            
            @return the URL of the word dictionary file
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.TextDictionary.GetFillerDictionaryFile">
            Get the filler dictionary file
            
            @return the URL of the filler dictionary file
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.TextDictionary.LoadDictionary(System.IO.Stream,System.Boolean)">
            Loads the given simple dictionary from the given InputStream. The
            InputStream is assumed to contain ASCII data.
            
            @param inputStream
                       the InputStream of the dictionary
            @param isFillerDict
                       true if this is a filler dictionary, false otherwise
            @throws java.io.IOException
                        if there is an error reading the dictionary
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.TextDictionary.GetCIUnit(System.String,System.Boolean)">
            Gets a context independent unit. There should only be one instance of any
            CI unit
            
            @param name
                       the name of the unit
            @param isFiller
                       if true, the unit is a filler unit
            @return the unit
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.TextDictionary.GetSentenceStartWord">
            Returns the sentence start word.
            
            @return the sentence start word
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.TextDictionary.GetSentenceEndWord">
            Returns the sentence end word.
            
            @return the sentence end word
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.TextDictionary.GetSilenceWord">
            Returns the silence word.
            
            @return the silence word
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.TextDictionary.GetWord(System.String)">
            Returns a Word object based on the spelling and its classification. The
            behavior of this method is also affected by the properties
            wordReplacement and g2pModel
            
            @param text
                       the spelling of the word of interest.
            @return a Word object
            @see edu.cmu.sphinx.linguist.dictionary.Word
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.TextDictionary.CreateWord(System.String,Syn.Speech.Linguist.Dictionary.Pronunciation[],System.Boolean)">
            Create a Word object with the given spelling and pronunciations, and
            insert it into the dictionary.
            
            @param text
                       the spelling of the word
            @param pronunciation
                       the pronunciation of the word
            @param isFiller
                       if <code>true</code> this is a filler word
            @return the word
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.TextDictionary.ProcessEntry(System.String)">
            Processes a dictionary entry. When loaded the dictionary just loads each
            line of the dictionary into the hash table, assuming that most words are
            not going to be used. Only when a word is actually used is its
            pronunciations massaged into an array of pronunciations.
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.TextDictionary.ToString">
            Returns a string representation of this TextDictionary in alphabetical
            order.
            
            @return a string representation of this dictionary
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.TextDictionary.GetFillerWords">
            Gets the set of all filler words in the dictionary
            
            @return an array (possibly empty) of all filler words
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.TextDictionary.Dump">
            Dumps this FastDictionary to System.out.
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.TextDictionary.LoadCustomDictionaries(System.Collections.Generic.List{Syn.Speech.Helper.URL})">
            Loads the dictionary with a list of URLs to custom dictionary resources
            
            @param addenda
                       the list of custom dictionary URLs to be loaded
            @throws IOException
                        if there is an error reading the resource URL
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.MappingDictionary.GetCIUnit(System.String,System.Boolean)">
            <summary>
            Gets a context independent unit. There should only be one instance of any CI unit.
            </summary>
            <param name="name">The name of the unit.</param>
            <param name="isFiller">if true, the unit is a filler unit</param>
            <returns>The unit.</returns>
        </member>
        <member name="T:Syn.Speech.Linguist.Dictionary.Pronunciation">
            <summary>
            Provides pronunciation information for a word.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.Pronunciation.#ctor(Syn.Speech.Linguist.Acoustic.Unit[],System.String,Syn.Speech.Linguist.Dictionary.WordClassification,System.Single)">
            <summary>
            Creates a pronunciation
            </summary>
            <param name="units">represents the pronunciation</param>
            <param name="tag">a grammar specific tag</param>
            <param name="wordClassification">the classification for this word</param>
            <param name="probability">the probability of this pronunciation occurring</param> 
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.Pronunciation.#ctor(System.Collections.Generic.List{Syn.Speech.Linguist.Acoustic.Unit},System.String,Syn.Speech.Linguist.Dictionary.WordClassification,System.Single)">
            <summary>
            Creates a pronunciation
            </summary>
            <param name="units">represents the pronunciation</param>
            <param name="tag">a grammar specific tag</param>
            <param name="wordClassification">the classification for this word</param>
            <param name="probability">the probability of this pronunciation occurring</param> 
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.Pronunciation.#ctor(System.Collections.Generic.List{Syn.Speech.Linguist.Acoustic.Unit})">
            <summary>
            Creates a pronunciation with defaults
            </summary>
            <param name="units">represents the pronunciation</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.Pronunciation.SetWord(Syn.Speech.Linguist.Dictionary.Word)">
            <summary>
            Sets the word this pronunciation represents.
            </summary>
            <param name="word">the Word this Pronunciation represents</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.Pronunciation.Dump">
            <summary>
            Dumps a pronunciation
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.Pronunciation.ToString">
            <summary>
            Returns a string representation of this Pronunication. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.Pronunciation.ToDetailedString">
            <summary>
            Returns a detailed string representation of this Pronunication.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Syn.Speech.Linguist.Dictionary.Pronunciation.Word">
            <summary>
            Retrieves the word that this Pronunciation object represents.
            </summary>
            <value>the word</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Dictionary.Pronunciation.WordClassification">
            <summary>
            Retrieves the word classification for this pronunciation
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Linguist.Dictionary.Pronunciation.Units">
            <summary>
            Retrieves the units for this pronunciation
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Linguist.Dictionary.Pronunciation.Probability">
            <summary>
            Retrieves the probability for the pronunciation. A word may have multiple pronunciations that are not all equally
            probable. All probabilities for particular word sum to 1.0.
            </summary>
            <value>the probability of this pronunciation as a value between 0 and 1.0.</value>
        </member>
        <member name="T:Syn.Speech.Linguist.Dictionary.Word">
            <summary>
            Represents a word, its spelling and its pronunciation.
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Dictionary.Word.Unknown">
            <summary>
            The Word representing the unknown word. 
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Dictionary.Word._pronunciations">
            <summary>
            pronunciations of this word
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.Word.#ctor(System.String,Syn.Speech.Linguist.Dictionary.Pronunciation[],System.Boolean)">
            <summary>
            Creates a Word
            </summary>
            <param name="spelling">the spelling of this word</param>
            <param name="pronunciations">the pronunciations of this word</param>
            <param name="isFiller">true if the word is a filler word</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.Word.GetPronunciations(Syn.Speech.Linguist.Dictionary.WordClassification)">
            <summary>
            Retrieves the pronunciations of this word
            </summary>
            <param name="wordClassification">the classification of the word (typically part
                   of speech classification) or null if all word classifications are
                   acceptable. The word classification must be one of the set
                   returned by
                   <code>Dictionary.getPossibleWordClassifications</code></param>
            <returns>the pronunciations of this word</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.Word.GetPronunciations">
            <summary>
            Retrieves the pronunciations of this word
            </summary>
            <returns>the pronunciations of this word</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.Word.GetMostLikelyPronunciation">
            <summary>
            Get the highest probability pronunciation for a word
            </summary>
            <returns>the highest probability pronunciation</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.Word.ToString">
            <summary>
            Returns a string representation of this word, which is the spelling
            </summary>
            <returns>the spelling of this word</returns>
        </member>
        <member name="P:Syn.Speech.Linguist.Dictionary.Word.Spelling">
            <summary>
            Returns the spelling of the word.
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Linguist.Dictionary.Word.IsFiller">
            <summary>
            Determines if this is a filler word
            </summary>
            <value>&lt;code&gt;true&lt;/code&gt; if this word is a filler word, otherwise it returns &lt;code&gt;false&lt;/code&gt;</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Dictionary.Word.IsSentenceEndWord">
            <summary>
            Returns true if this word is an end of sentence word
            </summary>
            <value>true if the word matches Dictionary.SENTENCE_END_SPELLING</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Dictionary.Word.IsSentenceStartWord">
            <summary>
            Returns true if this word is a start of sentence word
            </summary>
            <value>true if the word matches Dictionary.SENTENCE_START_SPELLING</value>
        </member>
        <member name="T:Syn.Speech.Linguist.Dictionary.WordClassification">
            <summary>
            Provides a classification of words
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Dictionary.WordClassification.#ctor(System.String)">
            <summary>
            Unconstructable...
            </summary>
            <param name="classificationName"></param>
        </member>
        <member name="T:Syn.Speech.Linguist.Flat.AlternativeState">
            <summary>
            Represents a set of alternatives in an SentenceHMMS
            </summary>
        </member>
        <member name="T:Syn.Speech.Linguist.Flat.SentenceHMMState">
            <summary>
            Represents a single state in an SentenceHMM
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.#ctor(System.String,Syn.Speech.Linguist.Flat.SentenceHMMState,System.Int32)">
                    /// Creates a SentenceHMMState
                     *
                    /// @param name   the name of the current SentenceHMMState
                    /// @param parent the parent of the current instance
                    /// @param which  the index of the current instance
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.#ctor">
            Empty contructor 
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.IsWordStart">
                    /// Determines if this state marks the beginning of a word
                     *
                    /// @return true if the state marks the beginning of a word
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.SetWordStart(System.Boolean)">
                    /// Sets the 'wordStart' flag
                     *
                    /// @param wordStart <code>true</code> if this state marks the beginning of a word.
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.IsSharedState">
                    /// Determines if this state is a shard state
                     *
                    /// @return true if the state marks the beginning of a word
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.SetSharedState(System.Boolean)">
                    /// Sets the shared state flag
                     *
                    /// @param shared <code>true</code> if this state is shared
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.GetAssociatedWord">
                    /// Returns the word associated with the particular unit
                     *
                    /// @return the word associated with this state, or null if there is no word associated with this state.
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.IsFanIn">
                    /// Determines if this state is a fan-in state. The search may need to adjust the pruning for states that fan in
                    /// since they are shared by multiple paths
                     *
                    /// @return <code>true</code> if the state is a fan in state
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.SetFanIn(System.Boolean)">
                    /// Sets the fan in state
                     *
                    /// @param fanIn if true its a fan in state
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.SetProcessed(System.Boolean)">
                    /// Sets the processed flag for this state
                     *
                    /// @param processed the new setting for the processed flag
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.IsProcessed">
                    /// Determines if this state has been 'processed'. The meaning of 'processed' is not defined here, but is up to the
                    /// higher levels
                     *
                    /// @return true if the state has been processed.
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.ResetAllProcessed">
            Reset process flags for this state and all successor states 
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.GetSuccessors">
            <summary>
            Gets a successor to this search state
            </summary>
            <returns>the set of successors</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.GetLexState">
                    /// Returns the lextree state
                     *
                    /// @return the lex tree state
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.DeleteSuccessor(Syn.Speech.Linguist.Flat.SentenceHMMStateArc)">
                    /// remove the given arc from the set of succors
                     *
                    /// @param arc the arc to remove
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.Connect(Syn.Speech.Linguist.Flat.SentenceHMMStateArc)">
                    /// Connects the arc to this sentence hmm.  If the node at the end of the arc is already pointing to some other node
                    /// as its predecessor, don't change that relationship, since its probably a result of the nodes being reused'
                     *
                    /// @param arc the path to the next state
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.RawConnect(Syn.Speech.Linguist.Flat.SentenceHMMStateArc)">
                    /// Connects the arc to this sentence hmm, but don't affect the predecessor relation ship
                     *
                    /// @param arc the arc to the next state
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.SetFinalState(System.Boolean)">
                    /// Sets this is to be final state
                     *
                    /// @param state true if this is a final state
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.IsUnit">
                    /// Determines if this state is a unit state
                     *
                    /// @return <code>true</code> if the state is a unit state.
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.DumpAll">
            Dumps this SentenceHMMState and all its successors. Just for debugging. 
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.Dump">
            Dumps this state 
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.ValidateAll">
            Validates this SentenceHMMState and all successors 
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.ToString">
            Returns the string representation of this object 
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.GetFullName">
                    /// Gets the fullName for this state
                     *
                    /// @return the full name for this state
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.GetTitle">
                    /// gets the title (fullname + stateNumber) for this state
                     *
                    /// @return the title
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.GetWhich">
                    /// Retrieves the index for this state words
                     *
                    /// @return the index
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.SetWhich(System.Int32)">
                    /// Sets the index for this state
                     *
                    /// @param which the index for this state
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.GetParent">
                    /// Retrieves the parent sate
                     *
                    /// @return the parent state (or null if this state does not have a parent state).
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.FindArc(Syn.Speech.Linguist.Flat.SentenceHMMState)">
                    /// Searches the set of arcs for an arc that points to a state with an identical value
                     *
                    /// @param state the state to search for
                    /// @return the arc or null if none could be found.
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.GetValueSignature">
                    /// Returns the value signature of this unit
                     *
                    /// @return the value signature
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.VisitStates(Syn.Speech.Linguist.Flat.ISentenceHMMStateVisitor,Syn.Speech.Linguist.Flat.SentenceHMMState,System.Boolean)">
                    /// Visit all of the states starting at start with the given vistor
                     *
                    /// @param visitor the state visitor
                    /// @param start   the place to start the search
                    /// @param sorted  if true, states are sorted before visited
                    /// @return true if the visiting was terminated before all nodes were visited
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.SetColor(Syn.Speech.Linguist.Flat.SentenceHMMState.Color)">
                    /// Sets the color for this node
                     *
                    /// @param color the color of this node
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.GetColor">
                    /// Gets the color for this node
                     *
                    /// @return the color of this node
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMState.CollectStates(Syn.Speech.Linguist.Flat.SentenceHMMState)">
            <summary>
            Collect all states starting from the given start state 
            </summary>
            <param name="start">the state to start the search from</param>
            <returns>set of collected state</returns>
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.SentenceHMMState.TypeLabel">
                    /// Retrieves a short label describing the type of this state. Typically, subclasses of SentenceHMMState will
                    /// implement this method and return a short (5 chars or less) label
                     *
                    /// @return the short label.
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.SentenceHMMState.WordHistory">
                    /// Gets the word history for this state.
                     *
                    /// @return the word history.
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.SentenceHMMState.NumSuccessors">
                    /// Gets the number of successors
                     *
                    /// @return the number of successors
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.SentenceHMMState.IsEmitting">
                    /// Determines if this state is an emitting state
                     *
                    /// @return true if the state is an emitting state
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.SentenceHMMState.IsFinal">
                    /// Determines if this is a final state
                     *
                    /// @return true if this is a final state
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.SentenceHMMState.Annotation">
                    /// Returns any annotation for this state
                     *
                    /// @return the annotation
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.SentenceHMMState.Name">
                    /// Gets the name for this state
                     *
                    /// @return the name
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.SentenceHMMState.PrettyName">
                    /// Returns a pretty name for this HMM
                     *
                    /// @return a pretty name
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.SentenceHMMState.Signature">
                    /// Gets the signature for this state
                     *
                    /// @return the signature
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.SentenceHMMState.StateNumber">
                    /// Gets the state number for this state
                     *
                    /// @return the state number
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.SentenceHMMState.Order">
                    /// Returns the order of this particular state
                     *
                    /// @return the state order for this state
        </member>
        <member name="T:Syn.Speech.Linguist.Flat.SentenceHMMState.Color">
            A Color is used to tag SentenceHMM nodes 
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.AlternativeState.GetAlternative">
                    /// Gets the word associated with this state
                     *
                    /// @return the word
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.AlternativeState.TypeLabel">
                    /// Retrieves a short label describing the type of this state. Typically, subclasses of SentenceHMMState will
                    /// implement this method and return a short (5 chars or less) label
                     *
                    /// @return the short label.
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.AlternativeState.Order">
                    /// Returns the state order for this state type
                     *
                    /// @return the state order
        </member>
        <member name="T:Syn.Speech.Linguist.Flat.BranchState">
            <summary>
             Represents a branching node in a grammar
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.BranchState.#ctor(System.String,System.String,System.Int32)">
                    /// Creates a branch state
                     *
                    /// @param nodeID the grammar node id
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.BranchState.TypeLabel">
                    /// Retrieves a short label describing the type of this state. Typically, subclasses of SentenceHMMState will
                    /// implement this method and return a short (5 chars or less) label
                     *
                    /// @return the short label.
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.BranchState.Order">
                    /// Returns the state order for this state type
                     *
                    /// @return the state order
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Linguist.Flat.CIPhoneLoop" -->
        <member name="M:Syn.Speech.Linguist.Flat.CIPhoneLoop.#ctor(Syn.Speech.Linguist.Acoustic.AcousticModel,System.Single)">
                    /// Creates the CIPhoneLoop with the given acoustic model and phone insertion probability
                     *
                    /// @param model                        the acoustic model
                    /// @param logPhoneInsertionProbability the insertion probability
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.CIPhoneLoop.GetSearchGraph">
                    /// Creates a new loop of all the context-independent phones.
                     *
                    /// @return the phone loop search graph
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.UnknownWordState.IsWordStart">
                    /// Returns true if this UnknownWordState indicates the start of a word. Returns false if this UnknownWordState
                    /// indicates the end of a word.
                     *
                    /// @return true if this UnknownWordState indicates the start of a word, false if this UnknownWordState indicates the
                    ///         end of a word
        </member>
        <member name="T:Syn.Speech.Linguist.Flat.ContextPair">
            <summary>
            A context pair hold a left and starting context. It is used as a hash into the set of starting points for a
            particular gstate
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.ContextPair.#ctor(Syn.Speech.Linguist.Flat.UnitContext,Syn.Speech.Linguist.Flat.UnitContext)">
                       /// Creates a UnitContext for the given context. This constructor is not directly accessible, use the factory method
                       /// instead.
                        *
                       /// @param left  the left context
                       /// @param right the right context
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.ContextPair.Get(Syn.Speech.Linguist.Flat.UnitContext,Syn.Speech.Linguist.Flat.UnitContext)">
                       /// Gets the ContextPair for the given set of contexts. This is a factory method. If the ContextPair already exists,
                       /// return that one, otherwise, create it and store it so it can be reused.
                        *
                       /// @param left  the left context
                       /// @param right the right context
                       /// @return the unit context.
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.ContextPair.Equals(System.Object)">
                       /// Determines if the given object is equal to this UnitContext
                        *
                       /// @param o the object to compare to
                       /// @return <code>true</code> if the objects are equal return;
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.ContextPair.GetHashCode">
                       /// Returns a hashcode for this object
                        *
                       /// @return the hashCode
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.ContextPair.ToString">
                       /// Returns a string representation of the object
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.ContextPair.LeftContext">
                       /// Gets the left unit context
                        *
                       /// @return the left unit context
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.ContextPair.RightContext">
                       /// Gets the right unit context
                        *
                       /// @return the right unit context
        </member>
        <member name="T:Syn.Speech.Linguist.Flat.ExtendedUnitState">
            <summary>
            
            A unit state that modifies how the unit state is cached.  Caching keys are generated from the full name for the
            sentence hmm. The default behavior for the unit (and all sentence hmms) is to generate the full name by combining the
            name for this unit with the name of the parent.  For the simple linguist, this is undesirable, because there are many
            different names for the parent pronunciations (differing contexts).  We want to be able to combine units that have
            identical names and context and are in the same position in the same pronunciation.  By defining getFullName to
            combine the name and the pronunciation index we allow units with identical contexts in the same position in a
            pronunciation to be combined.
            </summary>
        </member>
        <member name="T:Syn.Speech.Linguist.Flat.UnitState">
            <summary>
            Represents a unit in an SentenceHMMS
            </summary>
        </member>
        <member name="T:Syn.Speech.Linguist.IUnitSearchState">
            <summary>
            Represents a unit state in a search space
            </summary>
        </member>
        <member name="P:Syn.Speech.Linguist.IUnitSearchState.Unit">
            <summary>
            Gets the unit
            </summary>
            <value>the unit</value>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.UnitState.#ctor(Syn.Speech.Linguist.Flat.PronunciationState,System.Int32,Syn.Speech.Linguist.Acoustic.Unit)">
                    /// Creates a UnitState. Gets the left and right contexts from the unit itself.
                     *
                    /// @param parent the parent state
                    /// @param which  the index of the given state
                    /// @param unit   the unit associated with this state
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.UnitState.#ctor(Syn.Speech.Linguist.Acoustic.Unit,Syn.Speech.Linguist.Acoustic.HMMPosition)">
                    /// Creates a UnitState with the given unit and HMM position.
                     *
                    /// @param unit     the unit associated with this state
                    /// @param position the HMM position of this unit
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.UnitState.IsLast">
                    /// Returns true if this unit is the last unit of the pronunciation
                     *
                    /// @return <code>true</code> if the unit is the last unit
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.UnitState.GetValueSignature">
                    /// Returns the value signature of this unit
                     *
                    /// @return the value signature
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.UnitState.GetPosition">
                    /// Gets the position for this unit
                     *
                    /// @return the position for this unit
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.UnitState.Unit">
                    /// Gets the unit associated with this state
                     *
                    /// @return the unit
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.UnitState.Name">
                    /// Gets the name for this state
                     *
                    /// @return the name for this state
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.UnitState.PrettyName">
                    /// Gets the pretty name for this unit sate
                     *
                    /// @return the pretty name
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.UnitState.TypeLabel">
                    /// Retrieves a short label describing the type of this state. Typically, subclasses of SentenceHMMState will
                    /// implement this method and return a short (5 chars or less) label
                     *
                    /// @return the short label.
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.UnitState.Order">
            <summary>
            Returns the state order for this state type
            </summary>
            <value></value>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.ExtendedUnitState.#ctor(Syn.Speech.Linguist.Flat.PronunciationState,System.Int32,Syn.Speech.Linguist.Acoustic.Unit)">
                    /// Creates a UnitState. Gets the left and right contexts from the unit itself.
                     *
                    /// @param parent the parent state
                    /// @param which  the index of the given state
                    /// @param unit   the unit associated with this state
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.ExtendedUnitState.GetFullName">
                    /// Gets the fullName for this state
                     *
                    /// @return the full name for this state
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Linguist.Flat.FlatLinguist" -->
        <member name="F:Syn.Speech.Linguist.Flat.FlatLinguist.PropGrammar">
                   /// The property used to define the grammar to use when building the search graph
        </member>
        <member name="F:Syn.Speech.Linguist.Flat.FlatLinguist.PropUnitManager">
                    /// The property used to define the unit manager to use when building the search graph
        </member>
        <member name="F:Syn.Speech.Linguist.Flat.FlatLinguist.PropAcousticModel">
                    /// The property used to define the acoustic model to use when building the search graph
        </member>
        <member name="F:Syn.Speech.Linguist.Flat.FlatLinguist.PropDumpGstates">
                    /// The property used to determine whether or not the gstates are dumped.
        </member>
        <member name="F:Syn.Speech.Linguist.Flat.FlatLinguist.PropAddOutOfGrammarBranch">
                    /// The property that specifies whether to add a branch for detecting out-of-grammar utterances.
        </member>
        <member name="F:Syn.Speech.Linguist.Flat.FlatLinguist.PropOutOfGrammarProbability">
                    /// The property for the probability of entering the out-of-grammar branch.
        </member>
        <member name="F:Syn.Speech.Linguist.Flat.FlatLinguist.PropPhoneLoopAcousticModel">
                    /// The property for the acoustic model used for the CI phone loop.
        </member>
        <member name="F:Syn.Speech.Linguist.Flat.FlatLinguist.PropPhoneInsertionProbability">
                    /// The property for the probability of inserting a CI phone in the out-of-grammar ci phone loop
        </member>
        <member name="F:Syn.Speech.Linguist.Flat.FlatLinguist.PropShowCompilationProgress">
                    /// Property to control whether compilation progress is displayed on standard output. 
                    /// If this property is true, a 'dot' is  displayed for every 1000 search states added
                    ///  to the search space
        </member>
        <member name="F:Syn.Speech.Linguist.Flat.FlatLinguist.PropSpreadWordProbabilitiesAcrossPronunciations">
                    /// Property that controls whether word probabilities are spread across all pronunciations.
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.AllocateAcousticModel">
                    /// Allocates the acoustic model.
                    /// @throws java.io.IOException
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.StartRecognition">
                    /// Called before a recognition
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.StopRecognition">
                    /// Called after a recognition
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.CompileGrammar">
            <summary>
            Compiles the grammar into a sentence HMM. A GrammarJob is created for the
            initial grammar node and added to the GrammarJob queue. While there are
            jobs left on the grammar job queue, a job is removed from the queue and
            the associated grammar node is expanded and attached to the tails.
            GrammarJobs for the successors are added to the grammar job queue.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.CreateGState(Syn.Speech.Linguist.Language.Grammar.GrammarNode)">
            <summary>
            Returns a new GState for the given GrammarNode.
            </summary>
            <param name="grammarNode"></param>
            <returns>a new GState for the given GrammarNode</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.AddStartingPath">
            <summary>
            Ensures that there is a starting path by adding an empty left context to the starting gstate
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.AddStartingPath(Syn.Speech.Linguist.Language.Grammar.GrammarNode)">
            <summary>
            Start the search at the indicated node
            </summary>
            <param name="initialNode"></param>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GrammarHasChanged">
                    /// Determines if the underlying grammar has changed since we last compiled the search graph
                     *
                    /// @return true if the grammar has changed
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.FindStartingState">
            <summary>
            Finds the starting state
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GetArc(Syn.Speech.Linguist.Flat.SentenceHMMState,System.Single,System.Single)">
                    /// Gets a SentenceHMMStateArc. The arc is drawn from a pool of arcs.
                     *
                    /// @param nextState               the next state
                    /// @param logLanguageProbability  the log language probability
                    /// @param logInsertionProbability the log insertion probability
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GetGState(Syn.Speech.Linguist.Language.Grammar.GrammarNode)">
                    /// Given a grammar node, retrieve the grammar state
                     *
                    /// @param node the grammar node
                    /// @return the grammar state associated with the node
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.T(System.String)">
                    /// Quick and dirty tracing. Traces the string if 'tracing' is true
                     *
                    /// @param s the string to trace.
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.FlatLinguist.SearchGraph">
                    /// Returns the search graph
                     *
                    /// @return the search graph
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.FlatLinguist.LogSilenceInsertionProbability">
                    /// Returns the log silence insertion probability.
                     *
                    /// @return the log silence insertion probability.
        </member>
        <member name="T:Syn.Speech.Linguist.Flat.FlatLinguist.FlatSearchGraph">
            <summary>
            The search graph that is produced by the flat linguist.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.FlatSearchGraph.#ctor(Syn.Speech.Linguist.ISearchState)">
                        /// Constructs a flast search graph with the given initial state
                         *
                        /// @param initialState the initial state
        </member>
        <member name="T:Syn.Speech.Linguist.Flat.FlatLinguist.GState">
             <summary>
             
             This is a nested class that is used to manage the construction of the states in a grammar node. There is one
             GState created for each grammar node. The GState is used to collect the entry and exit points for the grammar
             node and for connecting up the grammar nodes to each other.
            
             </summary>
             
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.#ctor(Syn.Speech.Linguist.Language.Grammar.GrammarNode,Syn.Speech.Linguist.Flat.FlatLinguist)">
            <summary>
            Creates a GState for a grammar node
            </summary>
            <param name="node">the grammar node</param>
            <param name="parent"></param>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.GetStartingContexts">
            <summary>
            Retrieves the set of starting contexts for this node. The starting contexts are the set of Unit[] with a size
            equal to the maximum right context size.
            </summary>
            <returns>the set of starting contexts across nodes.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.GetStartingContext(Syn.Speech.Linguist.Dictionary.Pronunciation)">
                           /// Retrieves the starting UnitContext for the given pronunciation
                            *
                           /// @param pronunciation the pronunciation
                           /// @return a UnitContext representing the starting context of the pronunciation
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.GetEndingContexts">
            <summary>
            Retrieves the set of trailing contexts for this node. the trailing contexts are the set of Unit[] with a size
            equal to the maximum left context size that align with the end of the node
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.PullRightContexts">
            <summary>
            Visit all of the successor states, and gather their starting contexts into this gstates right context
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.GetSuccessors">
            <summary>
            Returns the set of succesor arcs for this grammar node. If a successor grammar node has no words we'll
            substitute the successors for that node (avoiding loops of course)
            </summary>
            <returns>an array of successors for this GState</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.PushLeftContexts">
            <summary>
            Visit all of the successor states, and push our ending context into the successors left context
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.PushLeftContexts(System.Collections.Generic.HashSet{Syn.Speech.Linguist.Language.Grammar.GrammarNode},System.Collections.Generic.List{Syn.Speech.Linguist.Flat.UnitContext})">
            <summary>
            Pushes the given left context into the successor states. If a successor state is empty, continue to push into
            this empty states successors
            </summary>
            <param name="visitedSet"></param>
            <param name="leftContext">leftContext the context to push</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.AddLeftContext(System.Collections.Generic.List{Syn.Speech.Linguist.Flat.UnitContext})">
                           /// Add the given left contexts to the set of left contexts for this state
                            *
                           /// @param context the set of contexts to add
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.AddLeftContext(Syn.Speech.Linguist.Flat.UnitContext)">
                           /// Adds the given context to the set of left contexts for this state
                            *
                           /// @param context the context to add
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.GetEntryPoints(Syn.Speech.Linguist.Flat.ContextPair)">
            <summary>
            Returns the entry points for a given context pair
            </summary>
            <param name="contextPair"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.GetEntryPoint">
            <summary>
            Gets the context-free entry point to this state
            </summary>
            <returns>the entry point to the state</returns>
            TODO: ideally we'll look for entry points with no left
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.CollectContexts">
            <summary>
            Collects the right contexts for this node and pushes this nodes ending context into the next next set of
            nodes.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.Expand">
            <summary>
            Expands each GState into the sentence HMM States
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.AddEmptyEntryPoints">
                           /// Adds the set of empty entry points. The list of entry points are tagged with a context pair. The context pair
                           /// represent the left context for the state and the starting context for the state, this allows states to be
                           /// hooked up properly. However, we may be transitioning from states that have no right hand context (CI units
                           /// such as SIL fall into this category). In this case we'd normally have no place to transition to since we add
                           /// entry points for each starting context. To make sure that there are entry points for empty contexts if
                           /// necessary, we go through the list of entry points and find all left contexts that have a right hand context
                           /// size of zero. These entry points will need an entry point with an empty starting context. These entries are
                           /// synthesized and added to the the list of entry points.
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.NeedsEmptyVersion(Syn.Speech.Linguist.Flat.ContextPair)">
                           /// Determines if the context pair needs an empty version. A context pair needs an empty version if the left
                           /// context has a max size of zero.
                            *
                           /// @param cp the contex pair to check
                           /// @return <code>true</code> if the pair needs an empt version
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.GetNode">
                           /// Returns the grammar node of the gstate
                            *
                           /// @return the grammar node
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.ExpandWord(Syn.Speech.Linguist.Flat.UnitContext)">
                           /// Expand the the word given the left context
                            *
                           /// @param leftContext the left context
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.ExpandPronunciation(Syn.Speech.Linguist.Flat.UnitContext,Syn.Speech.Linguist.Dictionary.Pronunciation,System.Int32)">
                           /// Expand the pronunciation given the left context
                            *
                           /// @param leftContext   the left context
                           /// @param pronunciation the pronunciation to expand
                           /// @param which         unique ID for this pronunciation
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.AttachUnit(Syn.Speech.Linguist.Flat.PronunciationState,Syn.Speech.Linguist.Flat.SentenceHMMState,Syn.Speech.Linguist.Acoustic.Unit[],System.Int32,Syn.Speech.Linguist.Flat.UnitContext,Syn.Speech.Linguist.Flat.UnitContext)">
                           /// Attaches the given unit to the given tail, expanding the unit if necessary. If an identical unit is already
                           /// attached, then this path is folded into the existing path.
                            *
                           /// @param parent       the parent state
                           /// @param tail         the place to attach the unit to
                           /// @param units        the set of units
                           /// @param which        the index into the set of units
                           /// @param leftContext  the left context for the unit
                           /// @param rightContext the right context for the unit
                           /// @return the tail of the added unit (or null if the path was folded onto an already expanded path.
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.AddExitPoint(Syn.Speech.Linguist.Flat.ContextPair,Syn.Speech.Linguist.Flat.SentenceHMMState)">
            <summary>
            Adds an exit point to this gstate
            </summary>
            <param name="cp">the context tag for the state</param>
            <param name="state">the state associated with the tag</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.GetLC(Syn.Speech.Linguist.Flat.UnitContext,Syn.Speech.Linguist.Acoustic.Unit[],System.Int32)">
                           /// Get the left context for a unit based upon the left context size, the entry left context and the current
                           /// unit.
                            *
                           /// @param left  the entry left context
                           /// @param units the set of units
                           /// @param index the index of the current unit
            
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.GetRC(Syn.Speech.Linguist.Acoustic.Unit[],System.Int32,Syn.Speech.Linguist.Flat.UnitContext)">
                           /// Get the right context for a unit based upon the right context size, the exit right context and the current
                           /// unit.
                            *
                           /// @param units the set of units
                           /// @param index the index of the current unit
                           /// @param right the exiting right context
            
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.GetLeftContextSize(Syn.Speech.Linguist.Acoustic.Unit)">
                           /// Gets the maximum context size for the given unit
                            *
                           /// @param unit the unit of interest
                           /// @return the maximum left context size for the unit
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.GetRightContextSize(Syn.Speech.Linguist.Acoustic.Unit)">
                           /// Gets the maximum context size for the given unit
                            *
                           /// @param unit the unit of interest
                           /// @return the maximum right context size for the unit
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.GetLeftContextSize">
                           /// Returns the size of the left context.
                            *
                           /// @return the size of the left context
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.GetRightContextSize">
            <summary>
            Returns the size of the right context.
            </summary>
            <returns>the size of the right context</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.GenerateNextLeftContext(Syn.Speech.Linguist.Flat.UnitContext,Syn.Speech.Linguist.Acoustic.Unit)">
            <summary>
            Generates the next left context based upon a previous context and a unit
            </summary>
            <param name="prevLeftContext">the previous left context</param>
            <param name="unit">the current unit</param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.ExpandUnit(Syn.Speech.Linguist.Flat.UnitState)">
                           /// Expands the unit into a set of HMMStates. If the unit is a silence unit add an optional loopback to the
                           /// tail.
                            *
                           /// @param unit the unit to expand
                           /// @return the head of the hmm tree
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.GetHMMStates(Syn.Speech.Linguist.Flat.UnitState)">
                           /// Given a unit state, return the set of sentence hmm states associated with the unit
                            *
                           /// @param unitState the unit state of intereset
                           /// @return the hmm tree for the unit
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.ExpandHMMTree(Syn.Speech.Linguist.Flat.UnitState,Syn.Speech.Linguist.Flat.HMMStateState)">
                           /// Expands the given hmm state tree
                            *
                           /// @param parent the parent of the tree
                           /// @param tree   the tree to expand
                           /// @return the final state in the tree
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.Connect">
            <summary>
            Connect up all of the GStates. Each state now has a table of exit points. These exit points represent tail
            states for the node. Each of these tail states is tagged with a ContextPair, that indicates what the left
            context is (the exiting context) and the right context (the entering context) for the transition. To connect
            up a state, the connect does the following: 
            1) Iterate through all of the grammar successors for this state
            2) Get the 'entry points' for the successor that match the exit points. 
            3) Hook them up.
            
            Note that for a task with 1000 words this will involve checking on the order of 35,000,000 connections and
            making about 2,000,000 connections
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.Connect(System.Collections.Generic.List{Syn.Speech.Linguist.ISearchState},System.Collections.Generic.List{Syn.Speech.Linguist.ISearchState},System.Single)">
            <summary>
            connect all the states in the source list to the states in the destination list
            </summary>
            <param name="sourceList">the set of source states</param>
            <param name="destList">the set of destination states.</param>
            <param name="logLangProb"></param>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.AttachState(Syn.Speech.Linguist.Flat.SentenceHMMState,Syn.Speech.Linguist.Flat.SentenceHMMState,System.Single,System.Single)">
                           /// Attaches one SentenceHMMState as a child to another, the transition has the given probability
                            *
                           /// @param prevState              the parent state
                           /// @param nextState              the child state
                           /// @param logLanguageProbablity  the language probability of transition in the LogMath log domain
                           /// @param logInsertionProbablity insertion probability of transition in the LogMath log domain
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.GetStates">
                           /// Returns all of the states maintained by this gstate
                            *
                           /// @return the set of all states
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.GetExistingState(Syn.Speech.Linguist.Flat.SentenceHMMState)">
                           /// Checks to see if a state that matches the given state already exists
                            *
                           /// @param state the state to check
                           /// @return true if a state with an identical signature already exists.
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.AddStateToCache(Syn.Speech.Linguist.Flat.SentenceHMMState)">
                           /// Adds the given state to the cache of states
                            *
                           /// @param state the state to add
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.DumpInfo">
                           /// Prints info about this GState
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.DumpDetails">
                           /// Dumps the details for a gstate
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.DumpNextNodes">
                           /// Dumps out the names of the next set of grammar nodes
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.DumpExitPoints(System.Collections.Generic.IEnumerable{System.Collections.Generic.List{Syn.Speech.Linguist.ISearchState}})">
                           /// Dumps the exit points and their destination states
                            *
                           /// @param eps the collection of exit points
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.DumpCollection(System.String,System.Collections.Generic.IEnumerable{System.Object})">
                           /// Dumps the given collection
                            *
                           /// @param name       the name of the collection
                           /// @param collection the collection to dump
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.FlatLinguist.GState.ToString">
                           /// Returns the string representation of the object
                            *
                           /// @return the string representation of the object
        </member>
        <member name="T:Syn.Speech.Linguist.Flat.GrammarState">
            <summary>
            Represents a non-emitting sentence hmm state
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.GrammarState.#ctor(Syn.Speech.Linguist.Language.Grammar.GrammarNode)">
                    /// Creates a GrammarState
                     *
                    /// @param node the GrammarNode associated with this state
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.GrammarState.GrammarNode">
                    /// Gets the grammar node associated with this state
                     *
                    /// @return the grammar node
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.GrammarState.TypeLabel">
                    /// Retrieves a short label describing the type of this state. Typically, subclasses of SentenceHMMState will
                    /// implement this method and return a short (5 chars or less) label
                     *
                    /// @return the short label.
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.GrammarState.Order">
                    /// Returns the state order for this state type
                     *
                    /// @return the state order
        </member>
        <member name="T:Syn.Speech.Linguist.Flat.HMMStateState">
            <summary>
            Represents a hmmState in an SentenceHMMS
            IScoreProvider -  is implemented without using interface derivation
            </summary>
        </member>
        <member name="T:Syn.Speech.Linguist.IHMMSearchState">
            <summary>
            Represents a single HMM state in a language search space
            </summary>
        </member>
        <member name="P:Syn.Speech.Linguist.IHMMSearchState.HmmState">
            <summary>
            Gets the hmm state
            </summary>
            <value></value>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.HMMStateState.#ctor(Syn.Speech.Linguist.Flat.SentenceHMMState,Syn.Speech.Linguist.Acoustic.IHMMState)">
                    /// Creates a HMMStateState
                     *
                    /// @param parent   the parent of this state
                    /// @param hmmState the hmmState associated with this state
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.HMMStateState.GetScore(Syn.Speech.FrontEnds.IData)">
                    /// Calculate the acoustic score for this state
                     *
                    /// @return the acoustic score for this state
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.HMMStateState.HmmState">
                    /// Gets the hmmState associated with this state
                     *
                    /// @return the hmmState
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.HMMStateState.IsEmitting">
                    /// Determines if this state is an emitting state
                     *
                    /// @return true if the state is an emitting state
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.HMMStateState.TypeLabel">
                    /// Retrieves a short label describing the type of this state. Typically, subclasses of SentenceHMMState will
                    /// implement this method and return a short (5 chars or less) label
                     *
                    /// @return the short label.
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.HMMStateState.Order">
                    /// Returns the state order for this state type
                     *
                    /// @return the state order
        </member>
        <member name="T:Syn.Speech.Linguist.Flat.ISentenceHMMStateVisitor">
            <summary>
            a visitor interface
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.ISentenceHMMStateVisitor.Visit(Syn.Speech.Linguist.Flat.SentenceHMMState)">
                    /// Method called when a state is visited by the vistor
                     *
                    /// @param state the state that is being visited
                    /// @return true if the visiting should be terminated
        </member>
        <member name="T:Syn.Speech.Linguist.Flat.NonEmittingHMMState">
            <summary>
            Represents a hmmState in an SentenceHMMS
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.NonEmittingHMMState.#ctor(Syn.Speech.Linguist.Flat.SentenceHMMState,Syn.Speech.Linguist.Acoustic.IHMMState)">
                    /// Creates a NonEmittingHMMState
                     *
                    /// @param parent   the parent of this state
                    /// @param hmmState the hmmState associated with this state
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.PhoneLoopSearchGraph.#ctor(Syn.Speech.Linguist.Flat.CIPhoneLoop)">
            Constructs a phone loop search graph. 
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.PhoneLoopSearchGraph.GetExistingState(Syn.Speech.Linguist.Flat.SentenceHMMState)">
                    /// Checks to see if a state that matches the given state already exists
                     *
                    /// @param state the state to check
                    /// @return true if a state with an identical signature already exists.
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.PhoneLoopSearchGraph.AddStateToCache(Syn.Speech.Linguist.Flat.SentenceHMMState)">
                    /// Adds the given state to the cache of states
                     *
                    /// @param state the state to add
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.PhoneLoopSearchGraph.ExpandHMMTree(Syn.Speech.Linguist.Flat.UnitState,Syn.Speech.Linguist.Flat.HMMStateState)">
                    /// Expands the given hmm state tree
                     *
                    /// @param parent the parent of the tree
                    /// @param tree   the tree to expand
                    /// @return the final state in the tree
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.PhoneLoopSearchGraph.InitialState">
                    /// Retrieves initial search state
                     *
                    /// @return the set of initial search state
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.PhoneLoopSearchGraph.NumStateOrder">
                    /// Returns the number of different state types maintained in the search graph
                     *
                    /// @return the number of different state types
        </member>
        <member name="T:Syn.Speech.Linguist.Flat.PronunciationState">
            <summary>
            Represents a pronunciation in an SentenceHMMS
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.PronunciationState.#ctor(Syn.Speech.Linguist.Flat.WordState,System.Int32)">
                    /// Creates a PronunciationState
                     *
                    /// @param parent the parent word of the current pronunciation
                    /// @param which  the pronunciation of interest
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.PronunciationState.#ctor(System.String,Syn.Speech.Linguist.Dictionary.Pronunciation,System.Int32)">
                    /// Creates a PronunciationState
                     *
                    /// @param name  the name of the pronunciation associated with this state
                    /// @param p     the pronunciation
                    /// @param which the index for the pronunciation
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.PronunciationState.IsWordStart">
                    /// Returns true if this PronunciationState indicates the start of a word. Returns false if this PronunciationState
                    /// indicates the end of a word.
                     *
                    /// @return true if this PronunciationState indicates the start of a word, false if this PronunciationState indicates
                    ///         the end of a word
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.PronunciationState.Pronunciation">
                    /// Gets the pronunciation associated with this state
                     *
                    /// @return the pronunciation
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.PronunciationState.TypeLabel">
                    /// Retrieves a short label describing the type of this state. Typically, subclasses of SentenceHMMState will
                    /// implement this method and return a short (5 chars or less) label
                     *
                    /// @return the short label.
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.PronunciationState.Order">
                    /// Returns the state order for this state type
                     *
                    /// @return the state order
        </member>
        <member name="T:Syn.Speech.Linguist.Flat.SentenceHMMStateArc">
            <summary>
            Represents a transition in a sentence HMM. Each transition is described by the next state and the associated acoustic
            and language probability for the transition.
            
            All probabilities are in the LogMath log domain
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMStateArc.#ctor(Syn.Speech.Linguist.Flat.SentenceHMMState,System.Single,System.Single)">
                    /// Creates a SentenceHMMStateArc
                     *
                    /// @param nextState               the next state
                    /// @param logLanguageProbability  the log language probability
                    /// @param logInsertionProbability the log insertion probability
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMStateArc.Equals(System.Object)">
                    /// Determines if the given object is equal to this object
                     *
                    /// @param o the object to compare to
                    /// @return <code>true</code> if the objects are equal
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMStateArc.GetHashCode">
                    /// Returns a hashCode for this object
                     *
                    /// @return the hashCode
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMStateArc.GetNextState">
                    /// For backwards compatibility
                    /// <p/>
                    /// Returns the next state as a SentenceHMSMtate
                     *
                    /// @return the next state
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.SentenceHMMStateArc.GetProbability">
                    /// Gets the composite probability of entering this state
                     *
                    /// @return the log probability
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.SentenceHMMStateArc.State">
                    /// Retrieves the next state
                     *
                    /// @return the next state
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.SentenceHMMStateArc.LanguageProbability">
                    /// Retrieves the language transition probability for this transition
                     *
                    /// @return the language  transition probability in the logmath log domain
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.SentenceHMMStateArc.InsertionProbability">
                    /// Retrieves the insertion probability for this transition
                     *
                    /// @return the insertion probability  in the logmath log domain
        </member>
        <member name="T:Syn.Speech.Linguist.Flat.UnitContext">
            <summary>
            A class that represents a set of units used as a context
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.UnitContext.#ctor(Syn.Speech.Linguist.Acoustic.Unit[])">
            <summary>
            Creates a UnitContext for the given context. This constructor is not directly accessible, use the factory method
            instead.
            </summary>
            <param name="context">context the context to wrap with this UnitContext</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.UnitContext.Get(Syn.Speech.Linguist.Acoustic.Unit[])">
            <summary>
            Gets the unit context for the given units. There is a single unit context for each unit combination.
            </summary>
            <param name="units">the units of interest</param>
            <returns>the unit context.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.UnitContext.Equals(System.Object)">
            <summary>
            Determines if the given object is equal to this UnitContext
            </summary>
            <param name="o">the object to compare to</param>
            <returns><code>true</code> if the objects are equal</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.UnitContext.GetHashCode">
            <summary>
            Returns a hashcode for this object
            </summary>
            <returns>the hashCode</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.UnitContext.DumpInfo">
            <summary>
            Dumps information about the total number of UnitContext objects
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.UnitContext.ToString">
            <summary>
            Returns a string representation of this object
            </summary>
            <returns>string representation</returns>
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.UnitContext.Units">
            <summary>
            Retrieves the units for this context
            </summary>
            <value>the units associated with this context</value>
        </member>
        <member name="T:Syn.Speech.Linguist.Flat.WordState">
            <summary>
            Represents a word in an SentenceHMMS
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.WordState.#ctor(Syn.Speech.Linguist.Flat.AlternativeState,System.Int32)">
            Creates a WordState
                    /// @param which
        </member>
        <member name="M:Syn.Speech.Linguist.Flat.WordState.GetWord">
                    /// Gets the word associated with this state
                     *
                    /// @return the word
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.WordState.PrettyName">
                    /// Returns a pretty name for this state
                     *
                    /// @return a pretty name for this state
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.WordState.TypeLabel">
                    /// Retrieves a short label describing the type of this state. Typically, subclasses of SentenceHMMState will
                    /// implement this method and return a short (5 chars or less) label
                     *
                    /// @return the short label.
        </member>
        <member name="P:Syn.Speech.Linguist.Flat.WordState.Order">
                    /// Returns the state order for this state type
                     *
                    /// @return the state order
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Linguist.G2p.G2PConverter" -->
        <member name="M:Syn.Speech.Linguist.G2p.G2PConverter.#ctor(Syn.Speech.Helper.URL)">
                    /// Create a decoder by loading the serialized model from a specified URL
                    /// 
                    /// @param g2pModelUrl
                    ///            the URL of the serialized model
                    /// @throws IOException
                    /// @throws ClassNotFoundException 
        </member>
        <member name="M:Syn.Speech.Linguist.G2p.G2PConverter.Init">
                    /// Initialize the decoder
        </member>
        <member name="M:Syn.Speech.Linguist.G2p.G2PConverter.Phoneticize(System.Collections.Generic.List{System.String},System.Int32)">
                    /// Phoneticize a word
                    /// 
                    /// @param entry
                    ///            the word to phoneticize transformed to an ArrayList of Strings
                    ///            (each element hold a single character)
                    /// @param nbest
                    ///            the number of distinct pronunciations to return
                    /// @return the pronunciation(s) of the input word
        </member>
        <member name="M:Syn.Speech.Linguist.G2p.G2PConverter.Phoneticize(System.String,System.Int32)">
                    /// Phoneticize a word
                    /// 
                    /// @param entry
                    ///            the word to phoneticize
                    /// @param nbest
                    ///            the number of distinct pronunciations to return
                    /// @return the pronunciation(s) of the input word
        </member>
        <member name="M:Syn.Speech.Linguist.G2p.G2PConverter.EntryToFsa(System.Collections.Generic.List{System.String})">
                    /// Transforms an input spelling/pronunciation into an equivalent FSA, adding
                    /// extra arcs as needed to accommodate clusters.
                    /// 
                    /// @param entry
                    ///            the input vector
                    /// @return the created fst
        </member>
        <member name="M:Syn.Speech.Linguist.G2p.G2PConverter.FindAllPaths(Syn.Speech.Fsts.Fst,System.Int32,System.Collections.Generic.HashSet{System.String},System.String)">
                    /// Finds nbest paths in an Fst returned by NShortestPaths operation
                    /// 
                    /// @param fst
                    ///            the input fst
                    /// @param nbest
                    ///            the number of paths to return
                    /// @param skipSeqs
                    ///            the sequences to ignore
                    /// @param tie
                    ///            the separator symbol
                    /// @return the paths
        </member>
        <member name="M:Syn.Speech.Linguist.G2p.G2PConverter.LoadClusters(System.String[])">
                    /// Initialize clusters
        </member>
        <member name="T:Syn.Speech.Linguist.G2p.Path">
            <summary>
            @author John Salatas "jsalatas@users.sourceforge.net"
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.G2p.Path.#ctor(System.Collections.Generic.List{System.String},Syn.Speech.Fsts.Semirings.Semiring)">
                    /// Create a Path instance with specified path and semiring elements
        </member>
        <member name="M:Syn.Speech.Linguist.G2p.Path.#ctor(Syn.Speech.Fsts.Semirings.Semiring)">
                    /// Create a Path instance with specified semiring element
        </member>
        <member name="M:Syn.Speech.Linguist.G2p.Path.GetPath">
                    /// Get the path
        </member>
        <member name="M:Syn.Speech.Linguist.G2p.Path.SetPath(System.Collections.Generic.List{System.String})">
                    /// Get the paths
        </member>
        <member name="P:Syn.Speech.Linguist.G2p.Path.Cost">
                    /// Get the paths' cost
        </member>
        <member name="T:Syn.Speech.Linguist.G2p.PathComparator">
            <summary>
            Comparator for {@link edu.cmu.sphinx.linguist.g2p.Path} object based on its cost
            @author John Salatas "jsalatas@users.sourceforge.net"
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.AlignerGrammar.SetText(System.String)">
            <summary>
            Reads Text and converts it into a list of tokens
            </summary>
            <param name="text">The text.</param>
        </member>
        <member name="T:Syn.Speech.Linguist.Language.Grammar.BatchForcedAlignerGrammar">
            <summary>
            @author Peter Wolf
            </summary>
        </member>
        <member name="T:Syn.Speech.Linguist.Language.Grammar.ForcedAlignerGrammar">
            <summary>
            Creates a grammar from a reference sentence. It is a constrained grammar that represents the sentence only.
            Note that all grammar probabilities are maintained in the LogMath log base.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.ForcedAlignerGrammar.CreateGrammar">
            <summary>
            Create class from reference text (not implemented).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.ForcedAlignerGrammar.CreateGrammar(System.String)">
            <summary>
            Creates the grammar.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.ForcedAlignerGrammar.CreateForcedAlignerGrammar(Syn.Speech.Linguist.Language.Grammar.GrammarNode,Syn.Speech.Linguist.Language.Grammar.GrammarNode,System.String)">
            <summary>
            Create a branch of the grammar that corresponds to a transcript.  
            For each word create a node, and link the nodes with arcs. 
            The branch is connected to the initial node iNode, and the final node fNode.
            </summary>
            <returns>The first node of this branch.</returns>
        </member>
        <member name="F:Syn.Speech.Linguist.Language.Grammar.BatchForcedAlignerGrammar.PropRefFile">
            <summary>
            Property that defines the reference file containing the transcripts used to create the froced align grammar.
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Language.Grammar.FSTGrammar.PropPath">
            <summary>
            The property for the location of the FST n-gram file.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.FSTGrammar.CreateGrammar(System.String)">
            <summary>
             Create class from reference text (not implemented).
            <param name="bogusText">dummy variable</param>
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.FSTGrammar.CreateGrammar">
            <summary>
            Creates the grammar.
            </summary>
            <returns>The initial node for the grammar.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.FSTGrammar.ConvertProbability(System.Single)">
             Converts the probability from -ln to logmath
            
             @param lnProb the probability to convert. Probabilities in the arpa format in negative natural log format. We
                           convert them to logmath.
             @return the converted probability in logMath log base
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.FSTGrammar.Get(System.Int32)">
             Given an id returns the associated grammar node
            
             @param id the id of interest
             @return the grammar node or null if none could be found with the proper id
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.FSTGrammar.CreateNodes(System.String)">
             Reads the FST file in the given path, and creates the nodes in the FST file.
            
             @param path the path of the FST file to read
             @return the highest ID of all nodes
             @throws java.io.IOException
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.FSTGrammar.ExpandWordNodes(System.Int32)">
             Expand each of the word nodes into a pair of nodes, as well as adding an optional silence node between the
             grammar node and its end node.
            
             @param maxNodeID the node ID to start with for the new nodes
             @return the last (or maximum) node ID
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.FSTGrammar.HasWord(Syn.Speech.Linguist.Language.Grammar.GrammarNode)">
             Determines if the node has a word
            
             @param node the grammar node of interest
             @return true if the node has a word
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.FSTGrammar.GetWord(Syn.Speech.Linguist.Language.Grammar.GrammarNode)">
             Gets the word from the given grammar ndoe
            
             @param node the node of interest
             @return the word (or null if the node has no word)
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.FSTGrammar.HasEndNode(Syn.Speech.Linguist.Language.Grammar.GrammarNode)">
             Determines if the given node has an end node associated with it.
            
             @param node the node of interest
             @return <code>true</code> if the given node has an end node.
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.FSTGrammar.GetEndNode(Syn.Speech.Linguist.Language.Grammar.GrammarNode)">
             Retrieves the end node associated with the given node
            
             @param node the node of interest
             @return the ending node or null if no end node is available
        </member>
        <member name="T:Syn.Speech.Linguist.Language.Grammar.GrammarArc">
             <summary>
             Represents a single transition out of a grammar node. The grammar represented is a stochastic grammar, each
             transition has a probability associated with it. The probabilities are relative and are not necessarily constrained
             to total 1.0.
            
             Note that all probabilities are maintained in the LogMath log base
             </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarArc.#ctor(Syn.Speech.Linguist.Language.Grammar.GrammarNode,System.Single)">
                    /// Create a grammar arc
                     *
                    /// @param grammarNode    the node that this arc points to
                    /// @param logProbability the log probability of following this arc
        </member>
        <member name="P:Syn.Speech.Linguist.Language.Grammar.GrammarArc.GrammarNode">
                   /// Retrieves the destination node for this transition
                    *
                   /// @return the destination node
        </member>
        <member name="P:Syn.Speech.Linguist.Language.Grammar.GrammarArc.Probability">
                   /// Retrieves the probability for this transition
                    *
                   /// @return the log probability for this transition
        </member>
        <member name="T:Syn.Speech.Linguist.Language.Grammar.GrammarNode">
             <summary>
             Represents a grammar node in a grammar. A {@link Grammar grammar} is represented as a graph of grammar nodes and
             {@link GrammarArc arcs}. A grammar node usually represents a word or words, but it can also be a transition point or
             simply silence.
            
             Note that all probabilities are maintained in the LogMath log base
             </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.#ctor(System.Int32,Syn.Speech.Linguist.Dictionary.Word[][])">
                    /// Creates a GrammarNode with the given ID, Words. A GrammarNode with words is, by default, neither a silence nor a
                    /// final node.
                     *
                    /// @param id           the identity of this GrammarNode
                    /// @param alternatives the set of Words in this GrammarNode. This is a two dimensional array, the first index
                    ///                     corresponds to the set of alternative choices, the second index corresponds to a particular
                    ///                     word for the alternative
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates a GrammarNode with the given ID and silence or final attributes. A silence or final node does not have
            any words by default.
            </summary>
            <param name="id">the identity of this GrammarNode</param>
            <param name="isFinal">if true this is a final node</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.Optimize">
            Optimize this grammar node. 
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.OptimizeArc(Syn.Speech.Linguist.Language.Grammar.GrammarArc)">
                    /// Optimize the given arc. If an arc branches to an empty node that has only one exit, the node can be bypassed by
                    /// making a new arc that skips the nodes. This can happen multiple times.
                     *
                    /// @param arc the arc to optimize
                    /// @return the optimized arc
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.GetWords(System.Int32)">
                    /// Retrieves the words associated with a specific alternative
                     *
                    /// @param alternative the index of the alternative
                    /// @return the words associated with this grammar node
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.GetWord">
                    /// Retrieve the single word associated with this grammar
                     *
                    /// @return the word associated with this grammar node
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.GetNumAlternatives">
                    /// Gets the number of alternatives
                     *
                    /// @return the number of alternatives
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.GetSuccessors">
                    /// Retrieves the set of transitions out of this node
                     *
                    /// @return the transitions to the successors for this node.
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.SetFinalNode(System.Boolean)">
                    /// Sets the 'final' state of the grammar node.  A 'final' state grammar marks the end of a grammar
                     *
                    /// @param isFinal if <code>true</code> the grammar node is a final node.
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.Add(Syn.Speech.Linguist.Language.Grammar.GrammarNode,System.Single)">
                    /// Adds an arc to the given node
                     *
                    /// @param node           the node that this new arc goes to
                    /// @param logProbability the log probability of the transition occuring
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.ToString">
            Returns the string representation of this object 
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.Traverse(System.Int32,System.Collections.Generic.HashSet{Syn.Speech.Linguist.Language.Grammar.GrammarNode},System.Single)">
                    /// Dumps this GrammarNode as a String.
                     *
                    /// @param level        the indent level
                    /// @param visitedNodes the set of visited nodes
                    /// @param logProb      the probability of the transition (in logMath log domain)
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.TraverseGDL(System.Collections.Generic.HashSet{Syn.Speech.Linguist.Language.Grammar.GrammarNode})">
                    /// Traverse the grammar and dump out the nodes and arcs in GDL
                     *
                    /// @param out          print the gdl to this file
                    /// @param visitedNodes the set of visited nodes
                    /// @throws IOException if an error occurs while writing the file
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.GetGDLID(Syn.Speech.Linguist.Language.Grammar.GrammarNode)">
                    /// Gvien a node, return a GDL ID for the node
                     *
                    /// @param node the node
                    /// @return the GDL id
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.GetGDLLabel(Syn.Speech.Linguist.Language.Grammar.GrammarNode)">
                    /// Given a node, returns a GDL Label for the node
                     *
                    /// @param node the node
                    /// @return a gdl label for the node
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.GetGDLShape(Syn.Speech.Linguist.Language.Grammar.GrammarNode)">
                    /// Given a node, returns a GDL shape for the node
                     *
                    /// @param node the node
                    /// @return a gdl shape for the node
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.GetGDLColor(Syn.Speech.Linguist.Language.Grammar.GrammarNode)">
                    /// Gets the color for the grammar node
                     *
                    /// @param node the node of interest
                    /// @return the gdl label for the color
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.DumpGDL(System.String)">
                    /// Dumps the grammar in GDL form
                     *
                    /// @param path the path to write the gdl file to
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.Dump">
            Dumps the grammar 
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.GrammarNode.SplitNode(System.Int32)">
            <summary>
            Splits this node into a pair of nodes. The first node in the pair retains the word info, and a single branch to
            the new second node. The second node retains all of the original successor branches.
            </summary>
            <param name="id">the id of the new node</param>
            <returns>the newly created second node.</returns>
        </member>
        <member name="P:Syn.Speech.Linguist.Language.Grammar.GrammarNode.ID">
                    /// Returns the ID of this GrammarNode.
                     *
                    /// @return the ID of this GrammarNode
        </member>
        <member name="P:Syn.Speech.Linguist.Language.Grammar.GrammarNode.Alternatives">
                    /// Retrieves the words associated with this grammar node
                     *
                    /// @return the words associated with this grammar node
        </member>
        <member name="P:Syn.Speech.Linguist.Language.Grammar.GrammarNode.IsEmpty">
                    /// Determines if this grammar node is empty (that is, has no words).
                     *
                    /// @return <code>true</code> if the node is empty, otherwise <code>false</code>.
        </member>
        <member name="P:Syn.Speech.Linguist.Language.Grammar.GrammarNode.IsFinalNode">
                    /// Determines if this grammar node is a final node in the grammar
                     *
                    /// @return true if the node is a final node in the grammar
        </member>
        <member name="T:Syn.Speech.Linguist.Language.Grammar.SimpleWordListGrammar">
            <summary>
                /// Defines a grammar based upon a list of words in a file. The format of the file is just one word per line. For
                /// example, for an isolated digits grammar the file will simply look like:
                /// <pre>
                /// zero
                /// one
                /// two
                /// three
                /// four
                /// five
                /// six
                /// seven
                /// eight
                /// nine
                /// </pre>
                /// The path to the file is defined by the {@link #PROP_PATH PROP_PATH} property. If the {@link #PROP_LOOP PROP_LOOP}
                /// property is true, the grammar created will be a looping grammar. Using the above digits grammar example, setting
                /// PROP_LOOP to true will make it a connected-digits grammar.
                /// <p/>
                /// All probabilities are maintained in LogMath log base.
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Language.Grammar.SimpleWordListGrammar.PropPath">
            <summary>
            The property that defines the location of the word list grammar.
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Language.Grammar.SimpleWordListGrammar.PropLoop">
            <summary>
            The property that if true, indicates that this is a looping grammar.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.SimpleWordListGrammar.CreateGrammar(System.String)">
                    /// Create class from reference text (not implemented).
                     *
                    /// @param bogusText dummy variable
        </member>
        <member name="M:Syn.Speech.Linguist.Language.Grammar.SimpleWordListGrammar.CreateGrammar">
            Creates the grammar. 
        </member>
        <member name="T:Syn.Speech.Linguist.Language.NGram.LanguageModel">
            Represents the generic interface to an N-Gram language model.
            <p/>
            Note that all probabilities are in LogMath log base, except as otherwise
            noted.
        </member>
        <member name="F:Syn.Speech.Linguist.Language.NGram.LanguageModel.PropLocation">
            The property specifying the location of the language model. 
        </member>
        <member name="F:Syn.Speech.Linguist.Language.NGram.LanguageModel.PropUnigramWeight">
            The property specifying the unigram weight 
        </member>
        <member name="F:Syn.Speech.Linguist.Language.NGram.LanguageModel.PropMaxDepth">
            The property specifying the maximum depth reported by the language model
            (from a getMaxDepth()) call. If this property is set to (-1) (the
            default) the language model reports the implicit depth of the model.
            This property allows a deeper language model to be used. For instance, a
            trigram language model could be used as a bigram model by setting this
            property to 2. Note if this property is set to a value greater than the
            implicit depth, the implicit depth is used. Legal values for this
            property are 1..N and -1.
        </member>
        <member name="F:Syn.Speech.Linguist.Language.NGram.LanguageModel.PropDictionary">
            The property specifying the dictionary to use 
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.LanguageModel.Allocate">
             Create the language model
            
             @throws java.io.IOException
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.LanguageModel.Deallocate">
             Deallocate resources allocated to this language model
            
             @throws IOException
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.LanguageModel.GetProbability(Syn.Speech.Linguist.WordSequence)">
             Gets the n-gram probability of the word sequence represented by the word
             list
            
             @param wordSequence the wordSequence
             @return the probability of the word sequence in LogMath log base
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.LanguageModel.GetSmear(Syn.Speech.Linguist.WordSequence)">
             Gets the smear term for the given wordSequence. Used in
             {@link LexTreeLinguist}. See
             {@link LexTreeLinguist#PROP_WANT_UNIGRAM_SMEAR} for details.
            
             @param wordSequence the word sequence
             @return the smear term associated with this word sequence
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.LanguageModel.Vocabulary">
             Returns the set of words in the language model. The set is unmodifiable.
            
             @return the unmodifiable set of words
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.LanguageModel.MaxDepth">
             Returns the maximum depth of the language model
            
             @return the maximum depth of the language model
        </member>
        <member name="T:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader">
             <summary>
             Reads a binary NGram language model file ("DMP file") generated by the SphinxBase sphinx_lm_convert.
            
             Note that all probabilities in the grammar are stored in LogMath log base format. Language 
             Probabilities in the language model file are stored in log 10 base. They are converted to 
             the LogMath base.
             </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.#ctor(System.IO.FileInfo,System.String,System.Boolean,System.Single,System.Double,System.Single)">
             Initializes the binary loader
            
             @param location                  location of the model
             @param format                    file format
             @param applyLanguageWeightAndWip if true apply language weight and word insertion penalty
             @param languageWeight            language weight
             @param wip                       word insertion probability
             @param unigramWeight             unigram weight
             @throws IOException if an I/O error occurs
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.#ctor(System.String,System.Boolean,System.Single,System.Double,System.Single)">
             Initializes the binary loader
            
             @param format                    file format
             @param applyLanguageWeightAndWip if true apply language weight and word insertion penalty
             @param languageWeight            language weight
             @param wip                       word insertion probability
             @param unigramWeight             unigram weight
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.GetNumberUnigrams">
             Returns the number of unigrams
            
             @return the number of unigrams
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.GetNumberBigrams">
             Returns the number of bigrams
            
             @return the number of bigrams
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.GetNumberTrigrams">
             Returns the number of trigrams
            
             @return the number of trigrams
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.GetNumberNGrams(System.Int32)">
             Returns the number of NGrams at
             a specified N order.
            
             @param n			the desired order
             @return the number of NGrams
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.GetBigramProbabilities">
             Returns all the bigram probabilities.
            
             @return all the bigram probabilities
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.GetTrigramProbabilities">
             Returns all the trigram probabilities.
            
             @return all the trigram probabilities
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.GetTrigramBackoffWeights">
             Returns all the trigram backoff weights
            
             @return all the trigram backoff weights
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.GetTrigramSegments">
             Returns the trigram segment table.
            
             @return the trigram segment table
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.GetNGramProbabilities(System.Int32)">
             Returns all the NGram probabilities at
             a specified N order.
            
             @param n			the desired order
             @return all the NGram probabilities
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.GetNGramBackoffWeights(System.Int32)">
             Returns all the NGram backoff weights at
             a specified N order.
            
             @param n			the desired order
             @return all the NGram backoff weights
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.GetNGramSegments(System.Int32)">
             Returns the NGram segment table at
             a specified order.
            
             @param n			the desired order
             @return the NGram segment table
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.GetLogNGramSegmentSize">
             Returns the log of the NGram segment size
            
             @return the log of the NGram segment size
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.GetBigramOffset">
             Returns the location (or offset) into the file where bigrams start.
            
             @return the location of the bigrams
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.GetTrigramOffset">
             Returns the location (or offset) into the file where trigrams start.
            
             @return the location of the trigrams
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.GetNGramOffset(System.Int32)">
             Returns the location (or offset) into the file where NGrams start
             at a specified N order.
            
             @param n			the desired order
             @return the location of the bigrams
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.GetBigEndian">
             Returns true if the loaded file is in big-endian.
            
             @return true if the loaded file is big-endian
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.LoadBuffer(System.Int64,System.Int32)">
             Loads the contents of the memory-mapped file starting at the given position and for the given size, into a byte
             buffer. This method is implemented because MappedByteBuffer.load() does not work properly.
            
             @param position the starting position in the file
             @param size     the number of bytes to load
             @return the loaded ByteBuffer
             @throws java.io.IOException
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.LoadModelLayout(System.IO.Stream)">
             Loads the language model from the given file.
            
             @param inputStream stream to read the language model data
             @throws java.io.IOException
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.ReadHeader(System.IO.Stream)">
             Reads the LM file header
            
             @param stream the data stream of the LM file
             @throws java.io.IOException
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.SkipNGrams(System.IO.Stream)">
            Skips the NGrams of the LM.
            
            @param stream
                       the source of data
            @throws java.io.IOException
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.SkipStreamBytes(System.IO.Stream,System.Int64)">
            Reliable skip
            
            @param stream stream
            @param bytes number of bytes
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.ApplyUnigramWeight">
            <summary>
            Apply the unigram weight to the set of unigrams
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.ApplyLanguageWeight(System.Single[]@,System.Single)">
            Apply the language weight to the given array of probabilities.
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.ApplyWip(System.Single[]@,System.Double)">
            Apply the WIP to the given array of probabilities.
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.ReadFloatTable(System.IO.Stream,System.Boolean)">
             Reads the probability table from the given DataInputStream.
            
             @param stream    the DataInputStream from which to read the table
             @param bigEndian true if the given stream is bigEndian, false otherwise
             @throws java.io.IOException
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.ReadIntTable(System.IO.Stream,System.Boolean,System.Int32)">
             Reads a table of integers from the given DataInputStream.
            
             @param stream    the DataInputStream from which to read the table
             @param bigEndian true if the given stream is bigEndian, false otherwise
             @param tableSize the size of the NGram segment table
             @return the NGram segment table, which is an array of integers
             @throws java.io.IOException
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.ReadUnigrams(System.IO.Stream,System.Int32,System.Boolean)">
             Read in the unigrams in the given DataInputStream.
            
             @param stream         the DataInputStream to read from
             @param numberUnigrams the number of unigrams to read
             @param bigEndian      true if the DataInputStream is big-endian, false otherwise
             @return an array of UnigramProbability index by the unigram ID
             @throws java.io.IOException
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.ReadInt(System.IO.Stream,System.Boolean)">
             Reads an integer from the given DataInputStream.
            
             @param stream    the DataInputStream to read from
             @param bigEndian true if the DataInputStream is in bigEndian, false otherwise
             @return the integer read
             @throws java.io.IOException
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.ReadFloat(System.IO.Stream,System.Boolean)">
             Reads a float from the given DataInputStream.
            
             @param stream    the DataInputStream to read from
             @param bigEndian true if the DataInputStream is in bigEndian, false otherwise
             @return the float read
             @throws java.io.IOException
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.ReadString(System.IO.Stream,System.Int32)">
             Reads a string of the given length from the given DataInputStream. It is assumed that the DataInputStream
             contains 8-bit chars.
            
             @param stream the DataInputStream to read from
             @param length the number of characters in the returned string
             @return a string of the given length from the given DataInputStream
             @throws java.io.IOException
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.ReadWords(System.IO.Stream,System.Int32,System.Int32)">
             Reads a series of consecutive Strings from the given stream.
            
             @param stream         the DataInputStream to read from
             @param length         the total length in bytes of all the Strings
             @param numberUnigrams the number of string to read
             @return an array of the Strings read
             @throws java.io.IOException
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.Unigrams">
             Returns all the unigrams
            
             @return all the unigrams
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.LogBigramSegmentSize">
             Returns the log of the bigram segment size
            
             @return the log of the bigram segment size
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.Words">
             Returns all the words.
            
             @return all the words
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.MaxDepth">
             Returns the maximum depth of the language model
            
             @return the maximum depth of the language model
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.BinaryLoader.BytesPerField">
             Returns the multiplier for the size of a NGram
             (1 for 16 bits, 2 for 32 bits).
            
             @return the multiplier for the size of a NGram
        </member>
        <member name="T:Syn.Speech.Linguist.Language.NGram.Large.BinaryStreamLoader">
            <summary>
            Language model that reads whole model into memory. Useful
            for loading language models from resources or external locations.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.BinaryStreamLoader.LoadModelData(System.IO.Stream)">
                    /// Reads whole data into memory
                    /// 
                    /// @param stream  the stream to load model from
                    /// @throws IOException 
        </member>
        <member name="T:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel">
            <summary>
            Language model that uses a binary NGram language model file ("DMP file")
            generated by the SphinxBase sphinx_lm_convert.
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.PropQueryLogFile">
            The property for the name of the file that logs all the queried N-grams.
            If this property is set to null, it means that the queried N-grams are
            not logged.
        </member>
        <member name="F:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.PropNgramCacheSize">
            The property that defines that maximum number of ngrams to be cached 
        </member>
        <member name="F:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.PropClearCachesAfterUtterance">
            The property that controls whether the ngram caches are cleared after
            every utterance
        </member>
        <member name="F:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.PropLanguageWeight">
            The property that defines the language weight for the search 
        </member>
        <member name="F:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.PropApplyLanguageWeightAndWip">
            The property that controls whether or not the language model will apply
            the language weight and word insertion probability
        </member>
        <member name="F:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.PropWordInsertionProbability">
            Word insertion probability property 
        </member>
        <member name="F:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.PropFullSmear">
            If true, use full bigram information to determine smear 
        </member>
        <member name="F:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.BytesPerNgram">
            The number of bytes per N-gram in the LM file generated by the
            CMU-Cambridge Statistical Language Modeling Toolkit.
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.BuildUnigramIDMap(Syn.Speech.Linguist.Dictionary.IDictionary)">
             Builds the map from unigram to unigramID. Also finds the startWordID and
             endWordID.
            
             @param dictionary
             
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.Stop">
            Called after a recognition 
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.ClearCache">
            Clears the various N-gram caches. 
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.GetProbability(Syn.Speech.Linguist.WordSequence)">
             Returns predicted probability and depth. Uses caching for high order
             ngrams.
            
             @param wordSequence sequence to get the probability
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.FindNGram(Syn.Speech.Linguist.WordSequence)">
             Finds or loads the NGram probability of the given NGram.
            
             @param wordSequence the NGram to load
             @return a NGramProbability of the given NGram
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.Is32Bits">
             Tells if the model is 16 or 32 bits.
            
             @return true if 32 bits, false otherwise
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.LoadNGramBuffer(Syn.Speech.Linguist.WordSequence)">
             Loads into a buffer all the NGram followers of the given N-1Gram.
            
             @param ws the N-1Gram to find followers
            
             @return a NGramBuffer of all the NGram followers of the given sequence
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.GetNGramBuffer(Syn.Speech.Linguist.WordSequence)">
             Returns the NGrams of the given word sequence
            
             @param wordSequence the word sequence from which to get the buffer
             @return the NGramBuffer of the word sequence
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.GetFirstNGramEntry(Syn.Speech.Linguist.Language.NGram.Large.NGramProbability,System.Int32,System.Int32)">
             Returns the index of the first NGram entry of the given N-1Gram
            
             @param nMinus1Gram the N-1Gram which first NGram entry we're looking for
             @param firstNMinus1GramEntry the index of the first N-1Gram entry of the
                    N-1Gram in question
             @param n the order of the NGram
             @return the index of the first NGram entry of the given N-1Gram
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.GetUnigramProbability(Syn.Speech.Linguist.WordSequence)">
             Returns the unigram probability of the given unigram.
            
             @param wordSequence the unigram word sequence
             @return the unigram probability
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.GetUnigram(Syn.Speech.Linguist.Dictionary.Word)">
             Returns its UnigramProbability if this language model has the given
             unigram.
            
             @param unigram the unigram to find
             @return the UnigramProbability, or null if this language model does not
                     have the unigram
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.HasUnigram(Syn.Speech.Linguist.Dictionary.Word)">
             Returns true if this language model has the given unigram.
            
             @param unigram the unigram to find
             @return true if this LM has this unigram, false otherwise
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.GetWordID(Syn.Speech.Linguist.Dictionary.Word)">
             Returns the ID of the given word.
            
             @param word the word to find the ID
             @return the ID of the word
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.HasWord(Syn.Speech.Linguist.Dictionary.Word)">
             Returns true if the language model contains the given word
            
             @param w
             @return
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.GetSmearOld(Syn.Speech.Linguist.WordSequence)">
             Gets the smear term for the given wordSequence
            
             @param wordSequence the word sequence
             @return the smear term associated with this word sequence
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.GetNumberBigramFollowers(System.Int32)">
             Returns the number of bigram followers of a word.
            
             @param wordID the ID of the word
             @return the number of bigram followers
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.GetBigramBuffer(System.Int32)">
             Returns the bigrams of the given word
            
             @param firstWordID the ID of the word
            
             @return the bigrams of the word
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.LoadTrigramBuffer(System.Int32,System.Int32)">
             Loads into a buffer all the trigram followers of the given bigram.
            
             @param firstWordID the ID of the first word
             @param secondWordID the ID of the second word
            
             @return a TrigramBuffer of all the trigram followers of the given two
                     words
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.WriteSmearInfo(System.String)">
             Writes the smear info to the given file
            
             @param filename the file to write the smear info to
             @throws IOException if an error occurs on write
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.ReadSmearInfo(System.String)">
             Reads the smear info from the given file
            
             @param filename where to read the smear info from
             @throws IOException if an inconsistent file is found or on any general
                     I/O error
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.PutSmearTerm(System.Int32,System.Int32,System.Single)">
             Puts the smear term for the two words
            
             @param word1 the first word
             @param word2 the second word
             @param smearTerm the smear term
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.GetSmearTerm(System.Int32,System.Int32)">
             Retrieves the smear term for the two words
            
             @param word1 the first word
             @param word2 the second word
             @return the smear term
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.GetBigramProb(System.Int32,System.Int32)">
             Retrieves the bigram probability for the two given words
            
             @param word1 the first word of the bigram
             @param word2 the second word of the bigram
             @return the log probability
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.MaxDepth">
             Returns the maximum depth of the language model
            
             @return the maximum depth of the language model
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.Vocabulary">
             Returns the set of words in the language model. The set is unmodifiable.
            
             @return the unmodifiable set of words
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.NGramMisses">
             Returns the number of times when a NGram is queried, but there is no
             such NGram in the LM (in which case it uses the backoff probabilities).
            
             @return the number of NGram misses
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.LargeNGramModel.NGramHits">
             Returns the number of NGram hits.
            
             @return the number of NGram hits
        </member>
        <member name="T:Syn.Speech.Linguist.Language.NGram.Large.LargeTrigramModel">
            <summary>
            A wrapper for LargeNGramModel base on the old LargeTrigramModel class. 
            @author Anthony Rousseau, LIUM
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.Language.NGram.Large.LargeTrigramModel.PropTrigramCacheSize">
            <summary>
            The property that defines that maximum number of trigrams to be cached.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.LargeTrigramModel.#ctor(System.String,Syn.Speech.Helper.URL,System.String,System.Int32,System.Int32,System.Boolean,System.Int32,Syn.Speech.Linguist.Dictionary.IDictionary,System.Boolean,System.Single,System.Double,System.Single,System.Boolean)">
                    /// @param format
                    /// @param urlLocation
                    /// @param ngramLogFile
                    /// @param maxTrigramCacheSize
                    /// @param maxBigramCacheSize
                    /// @param clearCacheAfterUtterance
                    /// @param maxDepth
                    /// @param dictionary
                    /// @param applyLanguageWeightAndWip
                    /// @param languageWeight
                    /// @param wip
                    /// @param unigramWeight
                    /// @param fullSmear
        </member>
        <member name="T:Syn.Speech.Linguist.Language.NGram.Large.NGramBuffer">
            <summary>
            Implements a buffer that contains NGrams. It assumes that the first two bytes of each n-gram entry is the ID of the
            n-gram.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.NGramBuffer.#ctor(System.SByte[],System.Int32,System.Boolean,System.Boolean,System.Int32,System.Int32)">
                    /// Constructs a NGramBuffer object with the given byte[].
                     *
                    /// @param buffer       the byte[] with NGrams
                    /// @param numberNGrams the number of N-gram
                    /// @param bigEndian	   the buffer's endianness
                    /// @param is32bits     whether the buffer is 16 or 32 bits
                    /// @param n	           the buffer's order
                    /// @param firstNGramEntry  the first NGram Entry
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.NGramBuffer.GetWordID(System.Int32)">
                    /// Returns the word ID of the nth follower, assuming that the ID is the first two bytes of the NGram entry.
                     *
                    /// @param nthFollower starts from 0 to (numberFollowers - 1).
                    /// @return the word ID
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.NGramBuffer.ReadBytesAsInt">
                    /// Reads the next two bytes from the buffer's current position as an integer.
                     *
                    /// @return the next two bytes as an integer
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.NGramBuffer.FindProbabilityID(System.Int32)">
                    /// Finds the NGram probability ID for the given nth word in a NGram.
                     *
                    /// @param nthWordID the ID of the nth word
                    /// @return the NGram Probability ID of the given nth word
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.NGramBuffer.GetProbabilityID(System.Int32)">
                    /// Returns the NGramProbability of the nth follower.
                     *
                    /// @param nthFollower which follower
                    /// @return the NGramProbability of the nth follower
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.NGramBuffer.FindNGram(System.Int32)">
                    /// Finds the NGram probabilities for the given nth word in a NGram.
                     *
                    /// @param nthWordID the ID of the nth word
                    /// @return the NGramProbability of the given nth word
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.NGramBuffer.FindNGramIndex(System.Int32)">
                    /// Finds the NGram index for the given nth word in a NGram
                    /// 
                    /// @param nthWordID the ID of the nth word
                    /// @return the NGramIndex of the given nth word
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.NGramBuffer.GetNGramProbability(System.Int32)">
                    /// Returns the NGramProbability of the nth follower.
                     *
                    /// @param nthFollower which follower
                    /// @return the NGramProbability of the nth follower
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.NGramBuffer.Buffer">
                    /// Returns the byte[] of n-grams.
                     *
                    /// @return the byte[] of n-grams
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.NGramBuffer.FirstNGramEntry">
                    /// Returns the firstNGramEntry
                    /// @return the firstNGramEntry of the buffer
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.NGramBuffer.Size">
                    /// Returns the size of the buffer in bytes.
                     *
                    /// @return the size of the buffer in bytes
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.NGramBuffer.NumberNGrams">
                    /// Returns the number of n-grams in this buffer.
                     *
                    /// @return the number of n-grams in this buffer
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.NGramBuffer.Position">
                    /// Returns the position of the buffer.
                     *
                    /// @return the position of the buffer
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.NGramBuffer.IsBigEndian">
                    /// Returns true if the NGramBuffer is big-endian.
                     *
                    /// @return true if the NGramBuffer is big-endian, false if little-endian
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.NGramBuffer.Is32Bits">
                    /// Returns true if the NGramBuffer is 32 bits.
                     *
                    /// @return true if the NGramBuffer is 32 bits, false if 16 bits
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.NGramBuffer.Used">
                    /// Returns true if this buffer was used in the last utterance.
                     *
                    /// @return true if this buffer was used in the last utterance
        </member>
        <member name="T:Syn.Speech.Linguist.Language.NGram.Large.NGramProbability">
            <summary>
             Represents a word ID (Nth word of a N-gram), and a N-gram probability ID.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.NGramProbability.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
                    /// Constructs a NGramProbability
                    /// 
                    /// @param which
                    ///            which follower of the first word is this NGram
                    /// @param wordID
                    ///            the ID of the Nth word in a NGram
                    /// @param probabilityID
                    ///            the index into the probability array
                    /// @param backoffID
                    ///            the index into the backoff probability array
                    /// @param firstNPlus1GramEntry
                    ///            the first N+1Gram entry
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.NGramProbability.WhichFollower">
                    /// Returns which follower of the first word is this NGram
                    /// 
                    /// @return which follower of the first word is this NGram
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.NGramProbability.WordID">
                    /// Returns the Nth word ID of this NGram
                    /// 
                    /// @return the Nth word ID
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.NGramProbability.ProbabilityID">
                    /// Returns the NGram probability ID.
                    /// 
                    /// @return the NGram probability ID
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.NGramProbability.BackoffID">
                    /// Returns the backoff weight ID.
                    /// 
                    /// @return the backoff weight ID
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.NGramProbability.FirstNPlus1GramEntry">
                    /// Returns the index of the first N+1Gram entry.
                    /// 
                    /// @return the index of the first N+1Gram entry
        </member>
        <member name="T:Syn.Speech.Linguist.Language.NGram.Large.NMaxGramBuffer">
            <summary>
            Implements a buffer that contains NGrams of model's MAX order. 
            It assumes that the first two bytes of each n-gram entry is the 
            ID of the n-gram.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.NMaxGramBuffer.#ctor(System.SByte[],System.Int32,System.Boolean,System.Boolean,System.Int32,System.Int32)">
                    /// Constructs a NMaxGramBuffer object with the given byte[].
                     *
                    /// @param buffer       the byte[] with NGrams
                    /// @param numberNGrams the number of N-gram
                    /// @param bigEndian	   the buffer's endianness
                    /// @param is32bits     whether the buffer is 16 or 32 bits
                    /// @param n	           the buffer's order
                    /// @param firstCurrentNGramEntry the first Current NGram Entry
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.NMaxGramBuffer.GetProbabilityID(System.Int32)">
                    /// Returns the NGramProbability of the nth follower.
                     *
                    /// @param nthFollower which follower
                    /// @return the NGramProbability of the nth follower
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.NMaxGramBuffer.FindNGram(System.Int32)">
                    /// Finds the NGram probabilities for the given nth word in a NGram.
                     *
                    /// @param nthWordID the ID of the nth word
                    /// @return the NGramProbability of the given nth word
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.NMaxGramBuffer.GetNGramProbability(System.Int32)">
                    /// Returns the NGramProbability of the nth follower.
                     *
                    /// @param nthFollower which follower
                    /// @return the NGramProbability of the nth follower
        </member>
        <member name="T:Syn.Speech.Linguist.Language.NGram.Large.UnigramProbability">
            <summary>
            Represents a probability, a backoff probability, and the location of the first bigram entry. 
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.UnigramProbability.#ctor(System.Int32,System.Single,System.Single,System.Int32)">
                    /// Constructs a UnigramProbability
                     *
                    /// @param wordID           the id of the word
                    /// @param logProbability   the probability
                    /// @param logBackoff       the backoff probability
                    /// @param firstBigramEntry the first bigram entry
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.UnigramProbability.ToString">
                    /// Returns a string representation of this object
                     *
                    /// @return the string form of this object
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Large.UnigramProbability.SetLogBackoff(System.Single)">
                    /// Sets the log backoff weight.
                     *
                    /// @param logBackoff the new log backoff weight
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.UnigramProbability.WordID">
                    /// Returns the word ID of this unigram
                     *
                    /// @return the word ID of this unigram
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.UnigramProbability.LogBackoff">
                    /// Returns the log backoff weight of this unigram
                     *
                    /// @return the log backoff weight of this unigram
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.Large.UnigramProbability.FirstBigramEntry">
                    /// Returns the index of the first bigram entry of this unigram.
                     *
                    /// @return the index of the first bigram entry of this unigram
        </member>
        <member name="T:Syn.Speech.Linguist.Language.NGram.SimpleNGramModel">
            <summary>
            An ASCII ARPA language model loader. This loader makes no attempt to optimize storage, 
            so it can only load very small language models.
            Note that all probabilities in the grammar are stored in LogMath log base format. 
            Language Probabilities in the language model file are stored in log 10 base.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.SimpleNGramModel.GetProbability(Syn.Speech.Linguist.WordSequence)">
            <summary>
            Gets the n-gram probability of the word sequence represented by the word list
            </summary>
            <param name="wordSequence">the wordSequence</param>
            <returns>the probability of the word sequence in LogMath log base</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.SimpleNGramModel.GetSmear(Syn.Speech.Linguist.WordSequence)">
            <summary>
            Gets the smear term for the given wordSequence
            </summary>
            <param name="wordSequence">the word sequence</param>
            <returns>the smear term associated with this word sequence</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.SimpleNGramModel.GetBackoff(Syn.Speech.Linguist.WordSequence)">
            <summary>
            Returns the backoff probability for the give sequence of words.
            </summary>
            <param name="wordSequence">The sequence of words.</param>
            <returns>The backoff probability in LogMath log base.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.SimpleNGramModel.GetProb(Syn.Speech.Linguist.WordSequence)">
            <summary>
            Gets the probability entry for the given word sequence or null if there is no entry.
            </summary>
            <param name="wordSequence">A word sequence.</param>
            <returns>The probability entry for the wordlist or null.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.SimpleNGramModel.ListToString(System.Collections.Generic.List{Syn.Speech.Linguist.Dictionary.Word})">
            <summary>
            Converts a wordList to a string.
            </summary>
            <param name="wordList">The wordlist.</param>
            <returns>the string</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.SimpleNGramModel.Dump">
            <summary>
            Dumps the language model.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.SimpleNGramModel.GetRepresentation(System.Collections.Generic.List{System.String})">
            <summary>
            Retrieves a string representation of the wordlist, suitable for map access
            </summary>
            <param name="wordList">The list of words.</param>
            <returns>a string representation of the word list</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.SimpleNGramModel.Load(Syn.Speech.Helper.URL,System.Single,Syn.Speech.Linguist.Dictionary.IDictionary)">
            <summary>
            Loads the language model from the given location.
            </summary>
            <param name="location">The URL location of the model.</param>
            <param name="unigramWeightValue">The unigram weight.</param>
            <param name="dictionaryValue">The dictionary.</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.SimpleNGramModel.Put(Syn.Speech.Linguist.WordSequence,System.Single,System.Single)">
            <summary>
             Puts the probability into the map.
            </summary>
            <param name="wordSequence">The tag for the prob.</param>
            <param name="logProb">The probability in log math base.</param>
            <param name="logBackoff">The backoff probability in log math base.</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.SimpleNGramModel.GetNGrams">
            <summary>
            Returns a list of all the word sequences in the language model This
            method is used to create Finite State Transducers of the language model.
            </summary>
            <returns>Containing all the word sequences.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.SimpleNGramModel.ReadLine">
            <summary>
            Reads the next line from the LM file. Keeps track of line number.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.SimpleNGramModel.Open(Syn.Speech.Helper.URL)">
            <summary>
            the language model at the given location
            </summary>
            <param name="location">The path to the language model.</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.SimpleNGramModel.ReadUntil(System.String)">
            <summary>
            Reads from the input stream until the input matches the given string.
            </summary>
            <param name="match">The string to match on.</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.SimpleNGramModel.Close">
            <summary>
            Closes the language model file.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.SimpleNGramModel.Corrupt(System.String)">
            <summary>
            Generates a 'corrupt' IO exception.
            </summary>
            <param name="reason">The reason.</param>
            <exception cref="T:System.IO.IOException">Corrupt Language Model  + fileName+  at line  + lineNumber + ':' + reason</exception>
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.SimpleNGramModel.MaxDepth">
            <summary>
            Returns the maximum depth of the language model
            </summary>
            <value>The maximum depth of the language model.</value>
        </member>
        <member name="P:Syn.Speech.Linguist.Language.NGram.SimpleNGramModel.Vocabulary">
            <summary>
            Returns the set of words in the language model. The set is unmodifiable.
            </summary>
            <value>The unmodifiable set of words.</value>
        </member>
        <member name="T:Syn.Speech.Linguist.Language.NGram.Probability">
            <summary>
            Represents a probability and a backoff probability
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Probability.#ctor(System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Linguist.Language.NGram.Probability"/> class.
            </summary>
            <param name="logProbability">The probability.</param>
            <param name="logBackoff">The backoff probability.</param>
        </member>
        <member name="M:Syn.Speech.Linguist.Language.NGram.Probability.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Linguist.LexTree.Node" -->
        <member name="F:Syn.Speech.Linguist.LexTree.Node._successors">
            <summary>
            This can be either Map during tree construction or Array after
            tree freeze. Conversion to array helps to save memory
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.Node.#ctor(System.Single)">
            <summary>
            Creates a node
            </summary>
            <param name="probability">the unigram probability for the node</param>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.Node.GetSuccessor(System.Object)">
            <summary>
            Given an object get the set of successors for this object
            </summary>
            <param name="key">the object key</param>
            <returns>the node containing the successors</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.Node.PutSuccessor(System.Object,Syn.Speech.Linguist.LexTree.Node)">
            <summary>
            Add the child to the set of successors if not exists
            </summary>
            <param name="key">the object key</param>
            <param name="child">the child to add</param>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.Node.GetSuccessorMap">
            <summary>
            Gets the successor map for this node
            </summary>
            <returns>the successor map</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.Node.Freeze">
            <summary>
            Freeze the node. Convert the successor map into an array list
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.Node.AddSuccessor(Syn.Speech.Linguist.Acoustic.IHMM,System.Single)">
            <summary>
            Adds a child node holding an hmm to the successor.  If a node similar to the child has already been added, we use
            the previously added node, otherwise we add this. Also, we record the base unit of the child in the set of right
            context
            </summary>
            <param name="hmm">the hmm to add</param>
            <param name="probability"></param>
            <returns>the node that holds the hmm (new or old)</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.Node.AddSuccessor(Syn.Speech.Linguist.Dictionary.Pronunciation,System.Single,Syn.Speech.Helper.HashMap{Syn.Speech.Linguist.Dictionary.Pronunciation,Syn.Speech.Linguist.LexTree.WordNode})">
            <summary>
            Adds a child node holding a pronunciation to the successor. If a node similar to the child has already been
            added, we use the previously added node, otherwise we add this. Also, we record the base unit of the child in the
            set of right context
            </summary>
            <param name="pronunciation">the pronunciation to add</param>
            <param name="probability"></param>
            <returns>the node that holds the pronunciation (new or old)</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.Node.AddSuccessor(Syn.Speech.Linguist.LexTree.WordNode)">
            <summary>
            add a WordNode succesor
            </summary>
            <param name="wordNode"></param>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.Node.AddSuccessor(Syn.Speech.Linguist.LexTree.EndNode,System.Single)">
            <summary>
            Adds an EndNode to the set of successors for this node If a node similar to the child has already been added, we
            use the previously added node, otherwise we add this.
            </summary>
            <param name="child">the endNode to add</param>
            <param name="probability"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.Node.AddSuccessor(Syn.Speech.Linguist.LexTree.UnitNode)">
            <summary>
            Adds a child node to the successor.  If a node similar to the child has already been added, we use the previously
            added node, otherwise we add this. Also, we record the base unit of the child in the set of right context
            </summary>
            <param name="child">the child to add</param>
            <returns>the node (may be different than child if there was already a node attached holding the hmm held by
                    child)</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.Node.GetSuccessors">
            <summary>
            Returns the successors for this node
            </summary>
            <returns>the set of successor nodes</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.Node.ToString">
            <summary>
            Returns the string representation for this object
            </summary>
            <returns>the string representation of the object</returns>
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.Node.UnigramProbability">
            <summary>
            the unigram probability
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.UnitNode.#ctor(System.Single)">
                    /// Creates the UnitNode
                     *
                    /// @param probablilty the probability for the node
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.UnitNode.BaseUnit">
                    /// Returns the base unit for this hmm node
                     *
                    /// @return the base unit
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.UnitNode.Type">
            <summary>
            Gets and set the unit type (one of SIMPLE_UNIT, WORD_BEGINNING_UNIT, SIMPLE_UNIT or FILLER_UNIT
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.EndNode.#ctor(Syn.Speech.Linguist.Acoustic.Unit,Syn.Speech.Linguist.Acoustic.Unit,System.Single)">
                    /// Creates the node, wrapping the given hmm
                     *
                    /// @param baseUnit    the base unit for this node
                    /// @param lc          the left context
                    /// @param probablilty the probability for the transition to this node
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.EndNode.ToString">
                    /// Returns a string representation for this object
                     *
                    /// @return a string representation
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.EndNode.Freeze">
            Freeze this node. Convert the set into an array to reduce memory overhead 
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.EndNode.BaseUnit">
                    /// Returns the base unit for this hmm node
                     *
                    /// @return the base unit
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.EndNode.LeftContext">
                    /// Returns the base unit for this hmm node
                     *
                    /// @return the base unit
        </member>
        <member name="T:Syn.Speech.Linguist.LexTree.EntryPoint">
            <summary>
            Manages a single entry point.
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.LexTree.EntryPoint._parent">
            <summary>
            the parent tree of this entry point
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.EntryPoint.#ctor(Syn.Speech.Linguist.Acoustic.Unit,Syn.Speech.Linguist.LexTree.HMMTree)">
            <summary>
            Creates an entry point for the given unit
            </summary>
            <param name="baseUnit">the EntryPoint is created for this unit</param>
            <param name="parent"></param>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.EntryPoint.GetEntryPointsFromLeftContext(Syn.Speech.Linguist.Acoustic.Unit)">
            <summary>
            Given a left context get a node that represents a single set of entry points into this unit
            </summary>
            <param name="leftContext">leftContext the left context of interest</param>
            <returns>the node representing the entry point</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.EntryPoint.AddProbability(System.Single)">
            <summary>
            Accumulates the probability for this entry point
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.EntryPoint.Freeze">
            <summary>
            Once we have built the full entry point we can eliminate some fields 
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.EntryPoint.AddSingleUnitWord(Syn.Speech.Linguist.Dictionary.Pronunciation)">
            <summary>
            Adds a one-unit word to this entry point. Such single unit words need to be dealt with specially.
            </summary>
            <param name="p">the pronunciation of the single unit word</param>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.EntryPoint.GetEntryPointRC">
            <summary>
            Gets the set of possible right contexts that we can transition to from this entry point
            </summary>
            <returns>the set of possible transition points.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.EntryPoint.CreateEntryPointMap">
            <summary>
            A version of createEntryPointMap that compresses common hmms across all entry points.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.EntryPoint.ConnectSingleUnitWords(Syn.Speech.Linguist.Acoustic.Unit,Syn.Speech.Linguist.LexTree.Node,System.Collections.Generic.Dictionary{Syn.Speech.Linguist.Acoustic.IHMM,Syn.Speech.Linguist.LexTree.HMMNode})">
            <summary>
            Connects the single unit words associated with this entry point.   The singleUnitWords list contains all
            single unit pronunciations that have as their sole unit, the unit associated with this entry point. Entry
            points for these words are added to the epNode for all possible left (exit) and right (entry) contexts.
            </summary>
            <param name="lc">the left context</param>
            <param name="epNode">the entry point node</param>
            <param name="map"></param>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.EntryPoint.ConnectEntryPointNode(Syn.Speech.Linguist.LexTree.Node,Syn.Speech.Linguist.Acoustic.Unit)">
                    /// Connect the entry points that match the given rc to the given epNode
                     *
                    /// @param epNode add matching successors here
                    /// @param rc     the next unit
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.EntryPoint.Dump">
            Dumps the entry point 
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.EntryPoint.Node">
            <summary>
            the base node for this entry point
            </summary>
        </member>
        <member name="T:Syn.Speech.Linguist.LexTree.EntryPointTable">
            <summary>
            The EntryPoint table is used to manage the set of entry points into the lex tree.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.EntryPointTable.#ctor(System.Collections.Generic.IEnumerable{Syn.Speech.Linguist.Acoustic.Unit},Syn.Speech.Linguist.LexTree.HMMTree)">
                    /// Create the entry point table give the set of all possible entry point units
                     *
                    /// @param entryPointCollection the set of possible entry points
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.EntryPointTable.GetEntryPoint(Syn.Speech.Linguist.Acoustic.Unit)">
                    /// Given a CI unit, return the EntryPoint object that manages the entry point for the unit
                     *
                    /// @param baseUnit the unit of interest (A ci unit)
                    /// @return the object that manages the entry point for the unit
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.EntryPointTable.CreateEntryPointMaps">
            Creates the entry point maps for all entry points. 
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.EntryPointTable.Freeze">
            Freezes the entry point table 
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.EntryPointTable.Dump">
            Dumps the entry point table 
        </member>
        <member name="T:Syn.Speech.Linguist.LexTree.HMMNode">
            <summary>
             A node that represents an HMM in the hmm tree
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMNode.#ctor(Syn.Speech.Linguist.Acoustic.IHMM,System.Single)">
                    /// Creates the node, wrapping the given hmm
                     *
                    /// @param hmm the hmm to hold
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMNode.ToString">
                    /// Returns a string representation for this object
                     *
                    /// @return a string representation
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMNode.AddRC(Syn.Speech.Linguist.Acoustic.Unit)">
                    /// Adds a right context to the set of possible right contexts for this node. This is typically only needed for hmms
                    /// at the ends of words.
                     *
                    /// @param rc the right context.
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMNode.Freeze">
            Freeze this node. Convert the set into an array to reduce memory overhead 
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMNode.GetRCSet">
                    /// Gets the rc as a set. If we've already been frozen it is an error
                     *
                    /// @return the set of right contexts
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMNode.GetRC">
                    /// returns the set of right contexts for this node
                     *
                    /// @return the set of right contexts
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.HMMNode.BaseUnit">
                    /// Returns the base unit for this hmm node
                     *
                    /// @return the base unit
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.HMMNode.HMM">
                    /// Returns the hmm for this node
                     *
                    /// @return the hmm
        </member>
        <member name="T:Syn.Speech.Linguist.LexTree.HMMTree">
            <summary>
            Represents the vocabulary as a lex tree with nodes in the tree representing either words (WordNode) or units
            (HMMNode). HMMNodes may be shared.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMTree.#ctor(Syn.Speech.Linguist.Acoustic.HMMPool,Syn.Speech.Linguist.Dictionary.IDictionary,Syn.Speech.Linguist.Language.NGram.LanguageModel,System.Boolean,System.Single)">
                    /// Creates the HMMTree
                     *
                    /// @param pool           the pool of HMMs and units
                    /// @param dictionary     the dictionary containing the pronunciations
                    /// @param lm             the source of the set of words to add to the lex tree
                    /// @param addFillerWords if <code>false</code> add filler words
                    /// @param languageWeight the languageWeight
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMTree.GetEntryPoint(Syn.Speech.Linguist.Acoustic.Unit,Syn.Speech.Linguist.Acoustic.Unit)">
                    /// Given a base unit and a left context, return the set of entry points into the lex tree
                     *
                    /// @param lc   the left context
                    /// @param base the center unit
                    /// @return the set of entry points
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMTree.GetHMMNodes(Syn.Speech.Linguist.LexTree.EndNode)">
                    /// Gets the  set of hmm nodes associated with the given end node
                     *
                    /// @param endNode the end node
                    /// @return an array of associated hmm nodes
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMTree.Compile">
            Compiles the vocabulary into an HMM Tree 
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMTree.DumpTree">
            Dumps the tree 
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMTree.DumpTree(System.Int32,Syn.Speech.Linguist.LexTree.Node,System.Collections.Generic.Dictionary{Syn.Speech.Linguist.LexTree.Node,Syn.Speech.Linguist.LexTree.Node})">
                    /// Dumps the tree
                     *
                    /// @param level   the level of the dump
                    /// @param node    the root of the tree to dump
                    /// @param dupNode map of visited nodes
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMTree.CollectEntryAndExitUnits">
            <summary>
            Collects all of the entry and exit points for the vocabulary.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMTree.Freeze">
                    /// Called after the lex tree is built. Frees all temporary structures. After this is called, no more words can be
                    /// added to the lex tree.
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMTree.AddWords">
            <summary>
            Adds the given collection of words to the lex tree
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMTree.AddWord(Syn.Speech.Linguist.Dictionary.Word)">
                    /// Adds a single word to the lex tree
                     *
                    /// @param word the word to add
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMTree.AddPronunciation(Syn.Speech.Linguist.Dictionary.Pronunciation,System.Single)">
                    /// Adds the given pronunciation to the lex tree
                     *
                    /// @param pronunciation the pronunciation
                    /// @param probability   the unigram probability
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMTree.GetWordUnigramProbability(Syn.Speech.Linguist.Dictionary.Word)">
                    /// Gets the unigram probability for the given word
                     *
                    /// @param word the word
                    /// @return the unigram probability for the word.
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.HMMTree.GetAllWords">
            <summary>
            Returns the entire set of words, including filler words
            </summary>
            <returns>the set of all words (as Word objects)</returns>
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.HMMTree.SentenceEndWordNode">
                    /// Returns the word node associated with the sentence end word
                     *
                    /// @return the sentence end word node
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.HMMTree.InitialNode">
                    /// Returns the initial node for this lex tree
                     *
                    /// @return the initial lex node
        </member>
        <member name="T:Syn.Speech.Linguist.LexTree.InitialWordNode">
            <summary>
            A class that represents the initial word in the search space. It is treated specially because we need to keep track
            of the context as well. The context is embodied in the parent node
            </summary>
        </member>
        <member name="T:Syn.Speech.Linguist.LexTree.WordNode">
            <summary>
            A node representing a word in the HMM tree
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.WordNode.#ctor(Syn.Speech.Linguist.Dictionary.Pronunciation,System.Single)">
            <summary>
            Creates a word node
            </summary>
            <param name="pronunciation">the pronunciation to wrap in this node</param>
            <param name="probability">the word unigram probability</param>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.WordNode.GetWord">
            <summary>
            Gets the word associated with this node
            </summary>
            <returns>the word</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.WordNode.GetSuccessors">
            <summary>
            Returns the successors for this node 
            throw NotSupportedException
            </summary>
            <returns>set of successor nodes</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.WordNode.ToString">
            <summary>
            Returns a string representation for this object 
            </summary>
            <returns>a string representation</returns>
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.WordNode.IsFinal">
            <summary>
            true if the node is the final one
            </summary>
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.WordNode.Pronunciation">
            <summary>
            Gets the pronunciation associated with this node
            </summary>
            <value>the pronunciation</value>
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.WordNode.LastUnit">
            <summary>
            Gets the last unit for this word
            </summary>
            <value></value>
        </member>
        <member name="F:Syn.Speech.Linguist.LexTree.InitialWordNode._parent">
            <summary>
            the parent node
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.InitialWordNode.#ctor(Syn.Speech.Linguist.Dictionary.Pronunciation,Syn.Speech.Linguist.LexTree.HMMNode)">
            <summary>
            Creates an InitialWordNode
            </summary>
            <param name="pronunciation">the pronunciation</param>
            <param name="parent">the parent node</param>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeState.#ctor(Syn.Speech.Linguist.LexTree.Node,Syn.Speech.Linguist.WordSequence,System.Single,System.Single,Syn.Speech.Linguist.LexTree.LexTreeLinguist)">
                       /// Creates a LexTreeState.
                        *
                       /// @param node         the node associated with this state
                       /// @param wordSequence the history of words up until this point
            
            
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeState.GetHashCode">
                       /// Generate a hashcode for an object
                        *
                       /// @return the hashcode
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeState.Equals(System.Object)">
                       /// Determines if the given object is equal to this object
                        *
                       /// @param o the object to test
                       /// @return <code>true</code> if the object is equal to this
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeState.GetProbability">
                       /// Gets the composite probability of entering this state
                        *
                       /// @return the log probability
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeState.GetNode">
                       /// Gets the hmm tree node representing the unit
                        *
                       /// @return the unit lex node
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeState.GetSuccessors">
                       /// Returns the list of successors to this state
                        *
                       /// @return a list of SearchState objects
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeState.GetSuccessors(Syn.Speech.Linguist.LexTree.Node)">
                       /// Returns the list of successors to this state
                        *
            
                       /// @return a list of SearchState objects
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeState.CreateWordStateArc(Syn.Speech.Linguist.LexTree.WordNode,Syn.Speech.Linguist.LexTree.HMMNode,Syn.Speech.Linguist.LexTree.LexTreeState)">
                       /// Creates a word search state for the given word node
                        *
                       /// @param wordNode the wordNode
            
            
                       /// @return the search state for the wordNode
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeState.CreateUnitStateArc(Syn.Speech.Linguist.LexTree.HMMNode,Syn.Speech.Linguist.LexTree.LexTreeState)">
                       /// Creates a unit search state for the given unit node
                        *
                       /// @param hmmNode the unit node
            
                       /// @return the search state
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeState.CreateEndUnitArc(Syn.Speech.Linguist.LexTree.EndNode,Syn.Speech.Linguist.LexTree.LexTreeState)">
                       /// Creates a unit search state for the given unit node
                        *
                       /// @param endNode  the unit node
                       /// @param previous the previous state
                       /// @return the search state
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeState.ToString">
                       /// Returns the string representation of this object
                        *
                       /// @return the string representation
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeState.ToPrettyString">
                       /// Returns a pretty version of the string representation for this object
                        *
                       /// @return a pretty string
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeState.GetCachedArcs">
                       /// Gets the successor arcs for this state from the cache
                        *
                       /// @return the next set of arcs for this state, or null if none can be found or if caching is disabled.
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeState.PutCachedArcs(Syn.Speech.Linguist.ISearchStateArc[])">
                       /// Puts the set of arcs into the cache
                        *
                       /// @param arcs the arcs to cache.
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeState.Signature">
                       /// Gets the unique signature for this state. The signature building code is slow and should only be used for
                       /// non-time-critical tasks such as plotting states.
                        *
                       /// @return the signature
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeState.State">
                       /// Gets a successor to this search state
                        *
                       /// @return the successor state
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeState.LanguageProbability">
                       /// Gets the language probability of entering this state
                        *
                       /// @return the log probability
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeState.InsertionProbability">
                       /// Gets the insertion probability of entering this state
                        *
                       /// @return the log probability
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeState.IsEmitting">
                       /// Determines if this is an emitting state
                        *
                       /// @return <code>true</code> if this is an emitting state.
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeState.IsFinal">
                       /// Determines if this is a final state
                        *
                       /// @return <code>true</code> if this is an final state.
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeState.WordHistory">
                       /// Returns the word sequence for this state
                        *
                       /// @return the word sequence
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeEndUnitState.#ctor(Syn.Speech.Linguist.LexTree.EndNode,Syn.Speech.Linguist.WordSequence,System.Single,System.Single,System.Single,System.Single,Syn.Speech.Linguist.LexTree.LexTreeLinguist)">
                       /// Constructs a LexTreeUnitState
                        *
            
                       /// @param wordSequence the history of words
            
            
            
            
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeEndUnitState.GetHashCode">
                       /// Generate a hashcode for an object
                        *
                       /// @return the hashcode
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeEndUnitState.Equals(System.Object)">
                       /// Determines if the given object is equal to this object
                        *
                       /// @param o the object to test
                       /// @return <code>true</code> if the object is equal to this
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeEndUnitState.GetEndNode">
                       /// Returns the unit node for this state
                        *
                       /// @return the unit node
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeEndUnitState.GetSuccessors">
                       /// Returns the list of successors to this state
                        *
                       /// @return a list of SearchState objects
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeEndUnitState.Unit">
                       /// Returns the base unit associated with this state
                        *
                       /// @return the base unit
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeEndUnitState.InsertionProbability">
                       /// Gets the acoustic probability of entering this state
                        *
                       /// @return the log probability
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeEndUnitState.LanguageProbability">
                       /// Gets the language probability of entering this state
                        *
                       /// @return the log probability
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeWordState.#ctor(Syn.Speech.Linguist.LexTree.WordNode,Syn.Speech.Linguist.LexTree.HMMNode,Syn.Speech.Linguist.WordSequence,System.Single,System.Single,System.Single,Syn.Speech.Linguist.LexTree.LexTreeLinguist)">
                       /// Constructs a LexTreeWordState
                        *
                       /// @param wordNode       the word node
                       /// @param wordSequence   the sequence of words triphone context
                       /// @param languageProbability the probability of this word
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeWordState.GetHashCode">
                       /// Generate a hashcode for an object
                        *
                       /// @return the hashcode
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeWordState.Equals(System.Object)">
                       /// Determines if the given object is equal to this object
                        *
                       /// @param o the object to test
                       /// @return <code>true</code> if the object is equal to this
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeWordState.GetSuccessors">
                       /// Returns the list of successors to this state
                        *
                       /// @return a list of SearchState objects
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeWordState.IsWordStart">
                       /// Returns true if this LexTreeWordState indicates the start of a word. Returns false if this LexTreeWordState
                       /// indicates the end of a word.
                        *
                       /// @return true if this LexTreeWordState indicates the start of a word, false if this LexTreeWordState indicates
                       ///         the end of a word
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeWordState.Pronunciation">
                       /// Gets the word pronunciation for this state
                        *
                       /// @return the pronunciation for this word
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeWordState.IsFinal">
                       /// Determines if this is a final state
                        *
                       /// @return <code>true</code> if this is an final state.
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeWordState.Signature">
                       /// Gets the unique signature for this state. The signature building code is slow and should only be used for
                       /// non-time-critical tasks such as plotting states.
                        *
                       /// @return the signature
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeWordState.LanguageProbability">
                       /// Gets the language probability of entering this state
                        *
                       /// @return the log probability
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeEndWordState.#ctor(Syn.Speech.Linguist.LexTree.WordNode,Syn.Speech.Linguist.LexTree.HMMNode,Syn.Speech.Linguist.WordSequence,System.Single,System.Single,System.Single,Syn.Speech.Linguist.LexTree.LexTreeLinguist)">
                       /// Constructs a LexTreeWordState
                        *
                       /// @param wordNode       the word node
                       /// @param lastNode       the previous word node
                       /// @param wordSequence   the sequence of words triphone context
            
            
                       /// @param logProbability the probability of this word occurring
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeHmmState.#ctor(Syn.Speech.Linguist.LexTree.HMMNode,Syn.Speech.Linguist.WordSequence,System.Single,System.Single,Syn.Speech.Linguist.Acoustic.IHMMState,System.Single,System.Single,Syn.Speech.Linguist.LexTree.Node,Syn.Speech.Linguist.LexTree.LexTreeLinguist)">
                       /// Constructs a LexTreeHMMState
                        *
                       /// @param hmmNode              the HMM state associated with this unit
                       /// @param wordSequence         the word history
                       /// @param languageProbability  the probability of the transition
                       /// @param insertionProbability the probability of the transition
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeHmmState.GetHashCode">
                       /// Generate a hashcode for an object
                        *
                       /// @return the hashcode
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeHmmState.Equals(System.Object)">
                       /// Determines if the given object is equal to this object
                        *
                       /// @param o the object to test
                       /// @return <code>true</code> if the object is equal to this
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeHmmState.GetSuccessors">
                       /// Retrieves the set of successors for this state
                        *
                       /// @return the list of successor states
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeHmmState.Signature">
                       /// Gets the ID for this state
                        *
                       /// @return the ID
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeHmmState.HmmState">
                       /// returns the HMM state associated with this state
                        *
                       /// @return the HMM state
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeHmmState.LanguageProbability">
                       /// Gets the language probability of entering this state
                        *
                       /// @return the log probability
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeHmmState.InsertionProbability">
                       /// Gets the language probability of entering this state
                        *
                       /// @return the log probability
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeHmmState.IsEmitting">
            Determines if this is an emitting state 
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Linguist.LexTree.LexTreeLinguist" -->
        <member name="F:Syn.Speech.Linguist.LexTree.LexTreeLinguist.PropGrammar">
            The property that defines the grammar to use when building the search graph 
        </member>
        <member name="F:Syn.Speech.Linguist.LexTree.LexTreeLinguist.PropAcousticModel">
            The property that defines the acoustic model to use when building the search graph 
        </member>
        <member name="F:Syn.Speech.Linguist.LexTree.LexTreeLinguist.PropUnitManager">
            The property that defines the unit manager to use when building the search graph 
        </member>
        <member name="F:Syn.Speech.Linguist.LexTree.LexTreeLinguist.PropFullWordHistories">
                    /// The property that determines whether or not full word histories are used to
                    /// determine when two states are equal.
        </member>
        <member name="F:Syn.Speech.Linguist.LexTree.LexTreeLinguist.PropLanguageModel">
            The property for the language model to be used by this grammar 
        </member>
        <member name="F:Syn.Speech.Linguist.LexTree.LexTreeLinguist.PropDictionary">
            The property that defines the dictionary to use for this grammar 
        </member>
        <member name="F:Syn.Speech.Linguist.LexTree.LexTreeLinguist.PropCacheSize">
            The property that defines the size of the arc cache (zero to disable the cache). 
        </member>
        <member name="F:Syn.Speech.Linguist.LexTree.LexTreeLinguist.PropAddFillerWords">
            The property that controls whether filler words are automatically added to the vocabulary 
        </member>
        <member name="F:Syn.Speech.Linguist.LexTree.LexTreeLinguist.PropGenerateUnitStates">
                    /// The property to control whether or not the linguist will generate unit states.   When this property is false the
                    /// linguist may omit UnitSearchState states.  For some search algorithms this will allow for a faster search with
                    /// more compact results.
        </member>
        <!-- Badly formed XML comment ignored for member "F:Syn.Speech.Linguist.LexTree.LexTreeLinguist.PropWantUnigramSmear" -->
        <member name="F:Syn.Speech.Linguist.LexTree.LexTreeLinguist.PropUnigramSmearWeight">
            The property that determines the weight of the smear. See {@link LexTreeLinguist#PROP_WANT_UNIGRAM_SMEAR} 
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeLinguist.StartRecognition">
            Called before a recognition 
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeLinguist.StopRecognition">
            Called after a recognition 
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeLinguist.GetInitialSearchState">
                       /// retrieves the initial language state
                        *
                       /// @return the initial language state
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeLinguist.CompileGrammar">
            Compiles the n-gram into a lex tree that is used during the search 
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeLinguist.CalculateInsertionProbability(Syn.Speech.Linguist.LexTree.UnitNode)">
                       /// Determines the insertion probability for the given unit lex node
                        *
                       /// @param unitNode the unit lex node
                       /// @return the insertion probability
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeLinguist.GetUnigramSmear(Syn.Speech.Linguist.LexTree.Node)">
                       /// Retrieves the unigram smear from the given node
                        *
                       /// @return the unigram smear
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeLinguist.GetSmearTermFromLanguageModel(Syn.Speech.Linguist.WordSequence)">
                       /// Returns the smear term for the given word sequence
                        *
                       /// @param ws the word sequence
                       /// @return the smear term for the word sequence
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeLinguist.GetHMMNodes(Syn.Speech.Linguist.LexTree.EndNode)">
                       /// Gets the set of HMM nodes associated with the given end node
                        *
                       /// @param endNode the end node
                       /// @return an array of associated HMM nodes
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeLinguist.LanguageModel">
                       /// Retrieves the language model for this linguist
                        *
                       /// @return the language model (or null if there is none)
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeNonEmittingHMMState.#ctor(Syn.Speech.Linguist.LexTree.HMMNode,Syn.Speech.Linguist.WordSequence,System.Single,System.Single,Syn.Speech.Linguist.Acoustic.IHMMState,System.Single,Syn.Speech.Linguist.LexTree.Node,Syn.Speech.Linguist.LexTree.LexTreeLinguist)">
                       /// Constructs a NonEmittingLexTreeHMMState
                        *
            
            
                       /// @param hmmState     the hmm state associated with this unit
            
                       /// @param wordSequence the word history
                       /// @param probability  the probability of the transition occurring
            
        </member>
        <member name="F:Syn.Speech.Linguist.LexTree.LexTreeSearchGraph._initialState">
            An array of classes that represents the order in which the states will be returned. 
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeSearchGraph.#ctor(Syn.Speech.Linguist.ISearchState)">
                       /// Constructs a search graph with the given initial state
                        *
                       /// @param initialState the initial state
        </member>
        <member name="F:Syn.Speech.Linguist.LexTree.LexTreeUnitState._parent">
            <summary>
            Nested class interaction
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeUnitState.#ctor(Syn.Speech.Linguist.LexTree.HMMNode,Syn.Speech.Linguist.WordSequence,System.Single,System.Single,System.Single,System.Single,Syn.Speech.Linguist.LexTree.LexTreeLinguist)">
                       /// Constructs a LexTreeUnitState
                        *
                       /// @param wordSequence the history of words
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeUnitState.#ctor(Syn.Speech.Linguist.LexTree.HMMNode,Syn.Speech.Linguist.WordSequence,System.Single,System.Single,System.Single,System.Single,Syn.Speech.Linguist.LexTree.Node,Syn.Speech.Linguist.LexTree.LexTreeLinguist)">
                       /// Constructs a LexTreeUnitState
                        *
                       /// @param wordSequence the history of words
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeUnitState.GetHashCode">
                       /// Generate a hashcode for an object
                        *
                       /// @return the hashcode
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeUnitState.Equals(System.Object)">
                       /// Determines if the given object is equal to this object
                        *
                       /// @param o the object to test
                       /// @return <code>true</code> if the object is equal to this
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeUnitState.GetHMMNode">
                       /// Returns the unit node for this state
                        *
                       /// @return the unit node
        </member>
        <member name="M:Syn.Speech.Linguist.LexTree.LexTreeUnitState.GetSuccessors">
                       /// Returns the list of successors to this state
                        *
                       /// @return a list of SearchState objects
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeUnitState.Unit">
                       /// Returns the base unit associated with this state
                        *
                       /// @return the base unit
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeUnitState.InsertionProbability">
                       /// Gets the acoustic probability of entering this state
                        *
                       /// @return the log probability
        </member>
        <member name="P:Syn.Speech.Linguist.LexTree.LexTreeUnitState.LanguageProbability">
                       /// Gets the language probability of entering this state
                        *
                       /// @return the log probability
        </member>
        <member name="T:Syn.Speech.Linguist.Util.LRUCache`2">
            <summary>
            An LRU cache
            </summary>
            <typeparam name="TK"></typeparam>
            <typeparam name="TV"></typeparam>
        </member>
        <member name="M:Syn.Speech.Linguist.Util.LRUCache`2.#ctor(System.Int32)">
                    /// Creates an LRU cache with the given maximum size
                     *
                    /// @param maxSize the maximum size of the cache
        </member>
        <member name="M:Syn.Speech.Linguist.Util.LRUCache`2.RemoveEldestEntry(System.Collections.Generic.KeyValuePair{`0,`1})">
                    /// Determines if the eldest entry in the map should be removed.
                     *
                    /// @param eldest the eldest entry
                    /// @return true if the eldest entry should be removed
        </member>
        <member name="T:Syn.Speech.Linguist.WordSequence">
            <summary>
            This class can be used to keep track of a word sequence. This class is an
            immutable class. It can never be modified once it is created (except,
            perhaps for transient, cached things such as a precalculated hashcode).
            </summary>
        </member>
        <member name="F:Syn.Speech.Linguist.WordSequence.Empty">
            <summary>
            an empty word sequence, that is, it has no words.
            </summary>
        </member>
        <member name="M:Syn.Speech.Linguist.WordSequence.#ctor(System.Int32)">
            <summary>
            Constructs a word sequence with the given depth. 
            </summary>
            <param name="size">the maximum depth of the word history</param>
        </member>
        <member name="M:Syn.Speech.Linguist.WordSequence.#ctor(Syn.Speech.Linguist.Dictionary.Word[])">
            <summary>
            Constructs a word sequence with the given word IDs
            </summary>
            <param name="words">the word IDs of the word sequence</param>
        </member>
        <member name="M:Syn.Speech.Linguist.WordSequence.#ctor(System.Collections.Generic.IEnumerable{Syn.Speech.Linguist.Dictionary.Word})">
            <summary>
            Constructs a word sequence from the list of words
            </summary>
            <param name="list">the list of words</param>
        </member>
        <member name="M:Syn.Speech.Linguist.WordSequence.AddWord(Syn.Speech.Linguist.Dictionary.Word,System.Int32)">
            <summary>
            Returns a new word sequence with the given word added to the sequence 
            </summary>
            <param name="word">the word to add to the sequence</param>
            <param name="maxSize">the maximum size of the generated sequence</param>
            <returns>a new word sequence with the word added (but trimmed to maxSize)</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.WordSequence.GetOldest">
            <summary>
            Returns the oldest words in the sequence (the newest word is omitted) 
            </summary>
            <returns>the oldest words in the sequence, with the newest word omitted</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.WordSequence.GetNewest">
            <summary>
            Returns the newest words in the sequence (the old word is omitted)
            </summary>
            <returns>the newest words in the sequence with the oldest word omitted</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.WordSequence.Trim(System.Int32)">
            <summary>
            Returns a word sequence that is no longer than the given size, that is
            filled in with the newest words from this sequence 
            </summary>
            <param name="maxSize">the maximum size of the sequence</param>
            <returns>a new word sequence, trimmed to maxSize.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.WordSequence.GetWord(System.Int32)">
            <summary>
            Returns the n-th word in this sequence
            </summary>
            <param name="n">which word to return</param>
            <returns>the n-th word in this sequence</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.WordSequence.ToString">
            <summary>
            Returns a string representation of this word sequence. The format is:
            [ID_0][ID_1][ID_2].
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.WordSequence.GetHashCode">
            <summary>
            Calculates the hashcode for this object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Linguist.WordSequence.Equals(System.Object)">
            <summary>
            compares the given object to see if it is identical to this WordSequence 
            </summary>
            <param name="objectparam">the object to compare this to</param>
            <returns>true if the given object is equal to this object</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.WordSequence.GetSubSequence(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="startIndex"></param>
            <param name="stopIndex"></param>
            <returns>a subsequence with both <code>startIndex</code> and  <code>stopIndex</code> exclusive.</returns>
        </member>
        <member name="M:Syn.Speech.Linguist.WordSequence.GetWords">
            <summary>
            
            </summary>
            <returns>the words of the <code>WordSequence</code>.</returns>
        </member>
        <member name="P:Syn.Speech.Linguist.WordSequence.Size">
            <summary>
            Returns the number of words in this sequence
            </summary>
            <value></value>
        </member>
        <member name="T:Syn.Speech.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Syn.Speech.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Syn.Speech.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Syn.Speech.Properties.Resources.default_config">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
            
            &lt;config&gt;
            
              &lt;property name=&quot;logLevel&quot; value=&quot;INFO&quot;/&gt;
            
              &lt;property name=&quot;absoluteBeamWidth&quot;  value=&quot;20000&quot;/&gt;
              &lt;property name=&quot;relativeBeamWidth&quot;  value=&quot;1e-60&quot;/&gt;
              &lt;property name=&quot;absoluteWordBeamWidth&quot;  value=&quot;200&quot;/&gt;
              &lt;property name=&quot;relativeWordBeamWidth&quot;  value=&quot;1e-40&quot;/&gt;
            
              &lt;property name=&quot;wordInsertionProbability&quot; value=&quot;0.1&quot;/&gt;
              &lt;property name=&quot;silenceInsertionProbability&quot; value=&quot;0.1&quot;/&gt;
              &lt;property name=&quot;fillerInsertionProbability&quot; value=&quot;1e-2&quot;/&gt;
            
              &lt;property na [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Syn.Speech.Properties.Resources.nums_cart">
             <summary>
               Looks up a localized string similar to *** Cart dump created by cart_dump
            *** Flite version: flite-1.1-release December 2001
            *** 
            *** Portions Copyright 2001,2002 Sun Microsystems, Inc.
            *** Portions Copyright 1999-2001 Language Technologies Institute, 
            *** Carnegie Mellon University.
            *** All Rights Reserved.  Use is subject to license terms.
            *** 
            *** See the file &quot;license.terms&quot; for information on usage and
            *** redistribution of this file, and for a DISCLAIMER OF ALL 
            *** WARRANTIES.
            TOTAL 97
            NODE num_digits &lt; Float(3.800000) 56
            NODE p.token_pos [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Syn.Speech.Properties.Resources.prefix_fsm">
             <summary>
               Looks up a localized string similar to *** fsm dump created by fsm_dump
            *** Flite version: flite-1.1-release December 2001
            *** 
            *** Portions Copyright 2001,2002 Sun Microsystems, Inc.
            *** Portions Copyright 1999-2001 Language Technologies Institute, 
            *** Carnegie Mellon University.
            *** All Rights Reserved.  Use is subject to license terms.
            *** 
            *** See the file &quot;license.terms&quot; for information on usage and
            *** redistribution of this file, and for a DISCLAIMER OF ALL 
            *** WARRANTIES.
            *** Dumped on Jan 18 2002
            
            VOCAB_SIZE 128
            NUM_OF_TRANSITIONS 203 [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Syn.Speech.Properties.Resources.speakerid_frontend_config">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
            
            &lt;!--
               Sphinx-4 Configuration file
            --&gt;
            
            &lt;!-- ******************************************************** --&gt;
            &lt;!--  spectrogram config file                                 --&gt;
            &lt;!-- ******************************************************** --&gt;
            
            &lt;config&gt;
            
            
                &lt;!-- ******************************************************** --&gt;
                &lt;!-- The frontend configuration                               --&gt;
                &lt;!-- ********************************************************  [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Syn.Speech.Properties.Resources.suffix_fsm">
             <summary>
               Looks up a localized string similar to *** fsm dump created by fsm_dump
            *** Flite version: flite-1.1-release December 2001
            *** 
            *** Portions Copyright 2001,2002 Sun Microsystems, Inc.
            *** Portions Copyright 1999-2001 Language Technologies Institute, 
            *** Carnegie Mellon University.
            *** All Rights Reserved.  Use is subject to license terms.
            *** 
            *** See the file &quot;license.terms&quot; for information on usage and
            *** redistribution of this file, and for a DISCLAIMER OF ALL 
            *** WARRANTIES.
            *** Dumped on Jan 18 2002
            
            VOCAB_SIZE 128
            NUM_OF_TRANSITIONS 454 [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="F:Syn.Speech.Recognizers.Recognizer.PropDecoder">
            <summary>
            The property for the decoder to be used by this recognizer.
            </summary>
        </member>
        <member name="F:Syn.Speech.Recognizers.Recognizer.PropMonitors">
            <summary>
            The property for the set of monitors for this recognizer 
            </summary>
        </member>
        <member name="M:Syn.Speech.Recognizers.Recognizer.Recognize(System.String)">
            <summary>
            Performs recognition for the given number of input frames, or until a 'final' result is generated. This method
            should only be called when the recognizer is in the <code>allocated</code> state.
            </summary>
            <param name="referenceText">referenceText what was actually spoken</param>
            <returns>a recognition result</returns>
        </member>
        <member name="M:Syn.Speech.Recognizers.Recognizer.Recognize">
            <summary>
            Performs recognition for the given number of input frames, or until a 'final' result is generated. This method
            should only be called when the recognizer is in the <code>allocated</code> state.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Recognizers.Recognizer.CheckState(Syn.Speech.Recognizers.Recognizer.State)">
            <summary>
            Checks to ensure that the recognizer is in the given state.
            </summary>
            <param name="desiredState">desiredState the state that the recognizer should be in</param>
        </member>
        <member name="M:Syn.Speech.Recognizers.Recognizer.SetState(Syn.Speech.Recognizers.Recognizer.State)">
            <summary>
            sets the current state
            </summary>
            <param name="newState"> newState the new state</param>
        </member>
        <member name="M:Syn.Speech.Recognizers.Recognizer.Allocate">
            <summary>
            Allocate the resources needed for the recognizer. Note this method make take some time to complete. This method
            should only be called when the recognizer is in the deallocated state.
            throws IllegalStateException if the recognizer is not in the DEALLOCATED state
            </summary>
        </member>
        <member name="M:Syn.Speech.Recognizers.Recognizer.Deallocate">
            <summary>
            Deallocates the recognizer. This method should only be called if the recognizer is in the allocated
            state.
            throws IllegalStateException if the recognizer is not in the ALLOCATED state
            </summary>
        </member>
        <member name="M:Syn.Speech.Recognizers.Recognizer.GetState">
            <summary>
            Retrieves the recognizer state. This method can be called in any state.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Recognizers.Recognizer.ResetMonitors">
            <summary>
            Resets the monitors monitoring this recognizer
            </summary>
        </member>
        <member name="M:Syn.Speech.Recognizers.Recognizer.AddResultListener(Syn.Speech.Decoders.IResultListener)">
            <summary>
            Adds a result listener to this recognizer. A result listener is called whenever a new result is generated by the
            recognizer. This method can be called in any state.
            </summary>
            <param name="resultListener">resultListener the listener to add</param>
        </member>
        <member name="M:Syn.Speech.Recognizers.Recognizer.AddStateListener(Syn.Speech.Recognizers.IStateListener)">
            <summary>
            Adds a status listener to this recognizer. The status listener is called whenever the status of the recognizer
            changes. This method can be called in any state.
            </summary>
            <param name="stateListener">stateListener the listener to add</param>
        </member>
        <member name="M:Syn.Speech.Recognizers.Recognizer.RemoveResultListener(Syn.Speech.Decoders.IResultListener)">
            <summary>
            Removes a previously added result listener. This method can be called in any state.
            </summary>
            <param name="resultListener">resultListener the listener to remove</param>
        </member>
        <member name="M:Syn.Speech.Recognizers.Recognizer.RemoveStateListener(Syn.Speech.Recognizers.IStateListener)">
            <summary>
            Removes a previously added state listener. This method can be called in any state.
            </summary>
            <param name="stateListener">stateListener the state listener to remove</param>
        </member>
        <member name="T:Syn.Speech.Recognizers.Recognizer.State">
            <summary>
            Defines the possible states of the recognizer.
            </summary>
        </member>
        <member name="T:Syn.Speech.Results.BoundedPriorityQueue`1">
            <summary>
             // TODO: replace with MinMaxPriorityQueue
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Results.IConfidenceScorer" -->
        <member name="M:Syn.Speech.Results.IConfidenceScorer.Score(Syn.Speech.Results.Result)">
            <summary>
            Computes confidences for a Result and returns a ConfidenceResult, 
            a compact representation of all the hypothesis contained in the result together with their per-word and per-path confidences.
            </summary>
            <param name="result">The result to compute confidences for.</param>
            <returns>A confidence result</returns>
        </member>
        <member name="T:Syn.Speech.Results.ConfusionSet">
            <summary>
            A confusion set is a set of words with their associated posteriors. In Java terms it's a SortedMap from posteriors to
            sets of WordResults, but the class is called a set because that's what this beast is known as in the literature.
            @author P. Gorniak
            </summary>
        </member>
        <member name="M:Syn.Speech.Results.ConfusionSet.AddWordHypothesis(Syn.Speech.Results.WordResult)">
            <summary>
            Add a word hypothesis to this confusion set.
            </summary>
            <param name="word">The hypothesis to add.</param>
        </member>
        <member name="M:Syn.Speech.Results.ConfusionSet.GetWordSet(System.Double)">
            <summary>
            Get the word set with this confidence.
            </summary>
            <param name="posterior">The confidence (posterior).</param>
            <returns>A set of hypotheses with this confidence, null if no such hypotheses</returns>
        </member>
        <member name="M:Syn.Speech.Results.ConfusionSet.GetBestHypothesisSet">
            <summary>
            Return the set of best hypothesis. This will usually contain one hypothesis, but might contain more case there
            are some that have exactly equal confidences.
            </summary>
            <returns>A set of best hypotheses</returns>
        </member>
        <member name="M:Syn.Speech.Results.ConfusionSet.GetBestHypothesis">
            <summary>
            Return the single best hypothesis. Breaks ties arbitrarily.
            </summary>
            <returns>The best hypothesis stored in this confusion set (by confidence).</returns>
        </member>
        <member name="M:Syn.Speech.Results.ConfusionSet.GetBestPosterior">
            <summary>
            Get the highest posterior (confidence) stored in this set.
            </summary>
            <returns>The highest posterior.</returns>
        </member>
        <member name="M:Syn.Speech.Results.ConfusionSet.ContainsWord(System.String)">
            <summary>
            Check whether this confusion set contains the given word
            </summary>
            <param name="word">The word to look for.</param>
            <returns>true if word is in this set</returns>
        </member>
        <member name="M:Syn.Speech.Results.ConfusionSet.ContainsFiller">
            <summary>
            Check whether this confusion set contains any fillers.
            </summary>
            <returns>Whether fillers are found.</returns>
        </member>
        <member name="M:Syn.Speech.Results.ConfusionSet.GetWordResult(System.String)">
            <summary>
            Returns the WordResult in this ConfusionSet for the given word.
            </summary>
            <param name="word">The word to look for.</param>
            <returns>The WordResult for the given word, or null if no WordResult for the given word is found.</returns>
        </member>
        <member name="M:Syn.Speech.Results.ConfusionSet.Dump(System.String)">
            <summary>
            Dumps out the contents of this ConfusionSet.
            </summary>
            <param name="name">The name of the confusion set.</param>
        </member>
        <member name="T:Syn.Speech.Results.Edge">
            <summary>
            Edges are part of Lattices.  They connect Nodes, and contain the score associated with that sequence.
            </summary>
        </member>
        <member name="M:Syn.Speech.Results.Edge.#ctor(Syn.Speech.Results.Node,Syn.Speech.Results.Node,System.Double,System.Double)">
                    /// Create an Edge from fromNode to toNode with acoustic and Language Model scores.
                     *
                    /// @param fromNode
                    /// @param toNode
                    /// @param acousticScore
                    /// @param lmScore
        </member>
        <member name="M:Syn.Speech.Results.Edge.Load(Syn.Speech.Results.Lattice,Syn.Speech.Helper.StringTokenizer)">
                    /// Internal routine used when creating a Lattice from a .LAT file
                     *
                    /// @param lattice
                    /// @param tokens
        </member>
        <member name="M:Syn.Speech.Results.Edge.Dump(System.IO.StreamWriter)">
                    /// Internal routine used when dumping a Lattice as a .LAT file
                     *
                    /// @param f
                    /// @throws IOException
        </member>
        <member name="M:Syn.Speech.Results.Edge.DumpAISee(System.IO.StreamWriter)">
                    /// Internal routine used when dumping a Lattice as an AiSee file
                     *
                    /// @param f
                    /// @throws IOException
        </member>
        <member name="M:Syn.Speech.Results.Edge.DumpDot(System.IO.StreamWriter)">
                    /// Internal routine used when dumping a Lattice as an Graphviz file
                     *
                    /// @param f
                    /// @throws IOException
        </member>
        <member name="M:Syn.Speech.Results.Edge.IsEquivalent(Syn.Speech.Results.Edge)">
                    /// Returns true if the given edge is equivalent to this edge. Two edges are equivalent only if they have their
                    /// 'fromNode' and 'toNode' are equivalent, and that their acoustic and language scores are the same.
                     *
                    /// @param other the Edge to compare this Edge against
                    /// @return true if the Edges are equivalent; false otherwise
        </member>
        <member name="P:Syn.Speech.Results.Edge.AcousticScore">
                    /// Get the acoustic score associated with an Edge. This is the acoustic
                    /// score of the word that this edge is transitioning to, that is, the word
                    /// represented by the node returned by the getToNode() method.
                    /// 
                    /// @return the acoustic score of the word this edge is transitioning to
        </member>
        <member name="P:Syn.Speech.Results.Edge.LMScore">
                    /// Get the language model score associated with an Edge
                     *
                    /// @return the score
        </member>
        <member name="P:Syn.Speech.Results.Edge.FromNode">
                    /// Get the "from" Node associated with an Edge
                     *
                    /// @return the Node
        </member>
        <member name="P:Syn.Speech.Results.Edge.ToNode">
                    /// Get the "to" Node associated with an Edge
                     *
                    /// @return the Node
        </member>
        <member name="T:Syn.Speech.Results.FrameStatistics">
            <summary>
            Contains statistics about a frame.
            <p/>
            Note that all scores are maintained in LogMath log base
            </summary>
        </member>
        <member name="M:Syn.Speech.Results.FrameStatistics.GetFrameNumber">
            <summary>
            Gets the frame number
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Results.FrameStatistics.GetData">
            <summary>
            Gets the feature associated with this frame
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Results.FrameStatistics.GetBestScore">
            <summary>
            Gets the best score for this frame
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Results.FrameStatistics.GetBestUnit">
            <summary>
            Gets the unit that had the best score for this frame
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Results.FrameStatistics.GetBestState">
            <summary>
            Gets the best scoring hmm state for this frame
            </summary>
            <returns></returns>
        </member>
        <member name="T:Syn.Speech.Results.IConfidenceResult">
            <summary>
            Shows the confidence information about a Result.
            </summary>
        </member>
        <member name="M:Syn.Speech.Results.IConfidenceResult.GetBestHypothesis">
            <summary>
            Returns the best hypothesis of the result.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Results.IConfidenceResult.Size">
            <summary>
            Get the number of word slots contained in this result
            </summary>
            <returns>Length of the result</returns>
        </member>
        <member name="M:Syn.Speech.Results.IConfidenceResult.GetConfusionSet(System.Int32)">
            <summary>
            Get the nth confusion set in this result
            </summary>
            <param name="i">The index of the confusion set to get.</param>
            <returns>The requested confusion set.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Results.Lattice" -->
        <member name="M:Syn.Speech.Results.Lattice.#ctor">
            Create an empty Lattice. 
        </member>
        <member name="M:Syn.Speech.Results.Lattice.#ctor(Syn.Speech.Results.Result)">
                    /// Create a Lattice from a Result.
                    /// <p/>
                    /// The Lattice is created from the Token tree referenced by the Result. The Lattice is then optimized to all
                    /// collapse equivalent paths.
                     *
                    /// @param result the result to convert into a lattice
        </member>
        <member name="M:Syn.Speech.Results.Lattice.GetNode(Syn.Speech.Decoders.Search.Token)">
                    /// Returns the node corresponding to the given word token.
                     *
                    /// @param token the token which we want a node of
                    /// @return the node of the given token
        </member>
        <member name="M:Syn.Speech.Results.Lattice.CollapseWordToken(Syn.Speech.Decoders.Search.Token)">
                    /// Collapse the given word-ending token. This means collapsing all the unit
                    /// and HMM tokens that correspond to the word represented by this token into
                    /// an edge of the lattice.
                    /// 
                    /// @param token
                    ///            the word-ending token to collapse
        </member>
        <member name="M:Syn.Speech.Results.Lattice.CollapseWordPath(Syn.Speech.Results.Node,Syn.Speech.Decoders.Search.Token,System.Single,System.Single)">
                    /// @param parentWordNode
                    ///            the 'toNode' of the returned edge
                    /// @param token
                    ///            the predecessor token of the token represented by the
                    ///            parentWordNode
                    /// @param acousticScore
                    ///            the acoustic score until and including the parent of token
                    /// @param languageScore
                    ///            the language score until and including the parent of token
        </member>
        <member name="M:Syn.Speech.Results.Lattice.GetNodeId(Syn.Speech.Decoders.Search.Token)">
                    /// Returns an ID for the Node associated with the given token.
                     *
                    /// @param token the token associated with the Node
                    /// @return an ID for the Node
        </member>
        <member name="M:Syn.Speech.Results.Lattice.#ctor(System.String)">
                    /// Create a Lattice from a LAT file.  LAT files are created by the method Lattice.dump()
                     *
                    /// @param fileName
        </member>
        <member name="M:Syn.Speech.Results.Lattice.AddEdge(Syn.Speech.Results.Node,Syn.Speech.Results.Node,System.Double,System.Double)">
                    /// Add an edge from fromNode to toNode.  This method creates the Edge object and does all the connecting
                     *
                    /// @param fromNode
                    /// @param toNode
                    /// @param acousticScore
                    /// @param lmScore
                    /// @return the new Edge
        </member>
        <member name="M:Syn.Speech.Results.Lattice.AddNode(Syn.Speech.Linguist.Dictionary.Word,System.Int32,System.Int32)">
                    /// Add a Node that represents the theory that a given word was spoken over a given period of time.
                     *
                    /// @param word
                    /// @param beginTime
                    /// @param endTime
                    /// @return the new Node
        </member>
        <member name="M:Syn.Speech.Results.Lattice.AddNode(System.String,Syn.Speech.Linguist.Dictionary.Word,System.Int64,System.Int64)">
                    /// Add a Node with a given ID that represents the theory that a given word was spoken over a given period of time.
                    /// This method is used when loading Lattices from .LAT files.
                     *
                    /// @param word
                    /// @param beginTime
                    /// @param endTime
                    /// @return the new Node
        </member>
        <member name="M:Syn.Speech.Results.Lattice.AddNode(System.String,System.String,System.Int64,System.Int64)">
                    /// Add a Node with a given ID that represents the theory that a given word was spoken over a given period of time.
                    /// This method is used when loading Lattices from .LAT files.
                     *
                    /// @param word
                    /// @param beginTime
                    /// @param endTime
                    /// @return the new Node
        </member>
        <member name="M:Syn.Speech.Results.Lattice.AddNode(Syn.Speech.Decoders.Search.Token,System.Int32,System.Int32)">
                    /// Add a Node corresponding to a Token from the result Token tree. Usually, the Token should reference a search
                    /// state that is a WordSearchState, although other Tokens may be used for debugging.
                     *
                    /// @param token
                    /// @return the new Node
        </member>
        <member name="M:Syn.Speech.Results.Lattice.HasEdge(Syn.Speech.Results.Edge)">
                    /// Test to see if the Lattice contains an Edge
                     *
                    /// @param edge
                    /// @return true if yes
        </member>
        <member name="M:Syn.Speech.Results.Lattice.HasNode(Syn.Speech.Results.Node)">
                    /// Test to see if the Lattice contains a Node
                     *
                    /// @param node
                    /// @return true if yes
        </member>
        <member name="M:Syn.Speech.Results.Lattice.HasNode(System.String)">
                    /// Test to see if the Lattice already contains a Node corresponding to a given Token.
                     *
                    /// @param ID the ID of the Node to find
                    /// @return true if yes
        </member>
        <member name="M:Syn.Speech.Results.Lattice.AddNode(Syn.Speech.Results.Node)">
                    /// Add a Node to the set of all Nodes
                     *
                    /// @param n
        </member>
        <member name="M:Syn.Speech.Results.Lattice.RemoveNode(Syn.Speech.Results.Node)">
                    /// Remove a Node from the set of all Nodes
                     *
                    /// @param n
        </member>
        <member name="M:Syn.Speech.Results.Lattice.GetNode(System.String)">
                    /// Get the Node associated with an ID
                     *
                    /// @param id
                    /// @return the Node
        </member>
        <member name="M:Syn.Speech.Results.Lattice.GetCopyOfNodes">
                    /// Get a copy of the Collection of all Nodes. Used by LatticeOptimizer to avoid Concurrent modification of the nodes
                    /// list.
                     *
                    /// @return a copy of the collection of Nodes
        </member>
        <member name="M:Syn.Speech.Results.Lattice.GetNodes">
                    /// Get the Collection of all Nodes.
                     *
                    /// @return the collection of all Nodes
        </member>
        <member name="M:Syn.Speech.Results.Lattice.RemoveEdge(Syn.Speech.Results.Edge)">
                    /// Remove an Edge from the set of all Edges.
                     *
                    /// @param e
        </member>
        <member name="M:Syn.Speech.Results.Lattice.GetEdges">
                    /// Get the set of all Edges.
                     *
                    /// @return the set of all edges
        </member>
        <member name="M:Syn.Speech.Results.Lattice.DumpAISee(System.String,System.String)">
                    /// Dump the Lattice in the form understood by AiSee (a graph visualization tool).  See http://www.AbsInt.com
                     *
                    /// @param fileName
                    /// @param title
        </member>
        <member name="M:Syn.Speech.Results.Lattice.DumpDot(System.String,System.String)">
                    /// Dump the Lattice in the form understood by Graphviz. See http://graphviz.org
                     *
                    /// @param fileName
                    /// @param title
        </member>
        <member name="M:Syn.Speech.Results.Lattice.Dump(System.IO.StreamWriter)">
                    /// Dump the Lattice as a .LAT file
                     *
                    /// @param out
                    /// @throws IOException
        </member>
        <member name="M:Syn.Speech.Results.Lattice.Dump(System.String)">
                    /// Dump the Lattice as a .LAT file.  Used to save Lattices as ASCII files for testing and experimentation.
                     *
                    /// @param file
        </member>
        <member name="M:Syn.Speech.Results.Lattice.RemoveNodeAndEdges(Syn.Speech.Results.Node)">
                    /// Remove a Node and all Edges connected to it.  Also remove those Edges from all connected Nodes.
                     *
                    /// @param n
        </member>
        <member name="M:Syn.Speech.Results.Lattice.RemoveNodeAndCrossConnectEdges(Syn.Speech.Results.Node)">
                    /// Remove a Node and cross connect all Nodes with Edges to it.
                    /// <p/>
                    /// For example given
                    /// <p/>
                    /// Nodes A, B, X, M, N Edges A-->X, B-->X, X-->M, X-->N
                    /// <p/>
                    /// Removing and cross connecting X would result in
                    /// <p/>
                    /// Nodes A, B, M, N Edges A-->M, A-->N, B-->M, B-->N
                     *
                    /// @param n
        </member>
        <member name="M:Syn.Speech.Results.Lattice.DumpAllPaths">
            Dump all paths through this Lattice.  Used for debugging. 
        </member>
        <member name="M:Syn.Speech.Results.Lattice.AllPaths">
                    /// Generate a List of all paths through this Lattice.
                     *
                    /// @return a lists of lists of Nodes
        </member>
        <member name="M:Syn.Speech.Results.Lattice.AllPathsFrom(System.String,Syn.Speech.Results.Node)">
                    /// Internal routine used to generate all paths starting at a given node.
                     *
                    /// @param path
                    /// @param n
                    /// @return a list of lists of Nodes
        </member>
        <member name="M:Syn.Speech.Results.Lattice.SortNodes">
                    /// Topologically sort the nodes in this lattice.
                     *
                    /// @return Topologically sorted list of nodes in this lattice.
        </member>
        <member name="M:Syn.Speech.Results.Lattice.ComputeNodePosteriors(System.Single)">
                    /// Compute the utterance-level posterior for every node in the lattice, i.e. the probability that this node occurs
                    /// on any path through the lattice. Uses a forward-backward algorithm specific to the nature of non-looping
                    /// left-to-right lattice structures.
                    /// <p/>
                    /// Node posteriors can be retrieved by calling getPosterior() on Node objects.
                     *
                    /// @param languageModelWeightAdjustment the weight multiplier that will be applied to language score already scaled by language weight
        </member>
        <member name="M:Syn.Speech.Results.Lattice.ComputeNodePosteriors(System.Single,System.Boolean)">
                    /// Compute the utterance-level posterior for every node in the lattice, i.e. the probability that this node occurs
                    /// on any path through the lattice. Uses a forward-backward algorithm specific to the nature of non-looping
                    /// left-to-right lattice structures.
                    /// <p/>
                    /// Node posteriors can be retrieved by calling getPosterior() on Node objects.
                     *
                    /// @param languageModelWeightAdjustment   the weight multiplier that will be applied to language score already scaled by language weight
                    /// @param useAcousticScoresOnly use only the acoustic scores to compute the posteriors, ignore the language weight
                    ///                              and scores
        </member>
        <member name="M:Syn.Speech.Results.Lattice.GetViterbiPath">
                    /// Retrieves the MAP path from this lattice. Only works once computeNodePosteriors has been called.
                     *
                    /// @return a list of nodes representing the MAP path.
        </member>
        <member name="M:Syn.Speech.Results.Lattice.GetWordResultPath">
            Retrieves the list of WordResult from this lattice. Only works once computeNodePosteriors has been called.
            
            @return list of WordResult
        </member>
        <member name="M:Syn.Speech.Results.Lattice.ComputeEdgeScore(Syn.Speech.Results.Edge,System.Single,System.Boolean)">
                    /// Computes the score of an edge. It multiplies on adjustment since language model
                    /// score is already scaled by language model weight in linguist.
                     *
                    /// @param edge                the edge which score we want to compute
                    /// @param languageModelWeightAdjustment the weight multiplier that will be applied to language score already scaled by language weight
                    /// @return the score of an edge
        </member>
        <member name="M:Syn.Speech.Results.Lattice.IsEquivalent(Syn.Speech.Results.Lattice)">
                    /// Returns true if the given Lattice is equivalent to this Lattice. Two lattices are equivalent if all their nodes
                    /// and edges are equivalent.
                     *
                    /// @param other the Lattice to compare this Lattice against
                    /// @return true if the Lattices are equivalent; false otherwise
        </member>
        <member name="M:Syn.Speech.Results.Lattice.CheckNodesEquivalent(Syn.Speech.Results.Node,Syn.Speech.Results.Node)">
                    /// Returns true if the two lattices starting at the given two nodes are equivalent. It recursively checks all the
                    /// child nodes until these two nodes until there are no more child nodes.
                     *
                    /// @param n1 starting node of the first lattice
                    /// @param n2 starting node of the second lattice
                    /// @return true if the two lattices are equivalent
        </member>
        <!-- Badly formed XML comment ignored for member "P:Syn.Speech.Results.Lattice.InitialNode" -->
        <!-- Badly formed XML comment ignored for member "P:Syn.Speech.Results.Lattice.TerminalNode" -->
        <member name="T:Syn.Speech.Results.LatticeOptimizer">
            <summary>
            Class used to collapse all equivalent paths in a Lattice.  Results in a Lattices that is deterministic (no Node has
            Edges to two or more equivalent Nodes), and minimal (no Node has Edge from two or more equivalent Nodes).
            </summary>
        </member>
        <member name="M:Syn.Speech.Results.LatticeOptimizer.#ctor(Syn.Speech.Results.Lattice)">
                    /// Create a new Lattice optimizer
                     *
                    /// @param lattice
        </member>
        <member name="M:Syn.Speech.Results.LatticeOptimizer.Optimize">
                    /// Code for optimizing Lattices.  An optimal lattice has all the same paths as the original, but with fewer nodes
                    /// and edges
                    /// <p/>
                    /// Note that these methods are all in Lattice so that it is easy to change the definition of "equivalent" nodes and
                    /// edges.  For example, an equivalent node might have the same word, but start or end at a different time.
                    /// <p/>
                    /// To experiment with other definitions of equivalent, just create a superclass of Lattice.
        </member>
        <member name="M:Syn.Speech.Results.LatticeOptimizer.OptimizeForward">
                    /// Make the Lattice deterministic, so that no node has multiple outgoing edges to equivalent nodes.
                    /// <p/>
                    /// Given two edges from the same node to two equivalent nodes, replace with one edge to one node with outgoing edges
                    /// that are a union of the outgoing edges of the old two nodes.
                    /// <p/>
                    /// A --> B --> C \--> B' --> Y
                    /// <p/>
                    /// where B and B' are equivalent.
                    /// <p/>
                    /// is replaced with
                    /// <p/>
                    /// A --> B" --> C \--> Y
                    /// <p/>
                    /// where B" is the merge of B and B'
                    /// <p/>
                    /// Note that equivalent nodes must have the same incomming edges. For example
                    /// <p/>
                    /// A --> B \ \ X --> B'
                    /// <p/>
                    /// B and B' would not be equivalent because the incomming edges are different
        </member>
        <member name="M:Syn.Speech.Results.LatticeOptimizer.OptimizeNodeForward(Syn.Speech.Results.Node)">
                    /// Look for 2 "to" edges to equivalent nodes.  Replace the edges with one edge to one node that is a merge of the
                    /// equivalent nodes
                    /// <p/>
                    /// nodes are equivalent if they have equivalent from edges, and the same label
                    /// <p/>
                    /// merged nodes have a union of "from" and "to" edges
                     *
                    /// @param n
                    /// @return true if Node n required an optimize forward
        </member>
        <member name="M:Syn.Speech.Results.LatticeOptimizer.EquivalentNodesForward(Syn.Speech.Results.Node,Syn.Speech.Results.Node)">
                    /// nodes are equivalent forward if they have "from" edges from the same nodes, and have equivalent labels (Token,
                    /// start/end times)
                     *
                    /// @param n1
                    /// @param n2
                    /// @return true if n1 and n2 are "equivalent forwards"
        </member>
        <member name="M:Syn.Speech.Results.LatticeOptimizer.MergeNodesAndEdgesForward(Syn.Speech.Results.Node,Syn.Speech.Results.Edge,Syn.Speech.Results.Edge)">
                    /// given edges e1 and e2 from node n to nodes n1 and n2
                    /// <p/>
                    /// merge e1 and e2, that is, merge the scores of e1 and e2 create n' that is a merge of n1 and n2 add n' add edge e'
                    /// from n to n'
                    /// <p/>
                    /// remove n1 and n2 and all associated edges
                     *
                    /// @param n
                    /// @param e1
                    /// @param e2
        </member>
        <member name="M:Syn.Speech.Results.LatticeOptimizer.OptimizeBackward">
                    /// Minimize the Lattice deterministic, so that no node has multiple incoming edges from equivalent nodes.
                    /// <p/>
                    /// Given two edges from equivalent nodes to a single nodes, replace with one edge from one node with incoming edges
                    /// that are a union of the incoming edges of the old two nodes.
                    /// <p/>
                    /// A --> B --> C X --> B' --/
                    /// <p/>
                    /// where B and B' are equivalent.
                    /// <p/>
                    /// is replaced with
                    /// <p/>
                    /// A --> B" --> C X --/
                    /// <p/>
                    /// where B" is the merge of B and B'
                    /// <p/>
                    /// Note that equivalent nodes must have the same outgoing edges. For example
                    /// <p/>
                    /// A --> X \ \ \ A' --> B
                    /// <p/>
                    /// A and A' would not be equivalent because the outgoing edges are different
        </member>
        <member name="M:Syn.Speech.Results.LatticeOptimizer.OptimizeNodeBackward(Syn.Speech.Results.Node)">
                    /// Look for 2 entering edges from equivalent nodes.  Replace the edges with one edge to one new node that is a merge
                    /// of the equivalent nodes Nodes are equivalent if they have equivalent to edges, and the same label. Merged nodes
                    /// have a union of entering and leaving edges
                     *
                    /// @param n
                    /// @return true if Node n required optimizing backwards
        </member>
        <member name="M:Syn.Speech.Results.LatticeOptimizer.EquivalentNodesBackward(Syn.Speech.Results.Node,Syn.Speech.Results.Node)">
                    /// nodes are equivalent backward if they have "to" edges to the same nodes, and have equivalent labels (Token,
                    /// start/end times)
                     *
                    /// @param n1
                    /// @param n2
                    /// @return true if n1 and n2 are "equivalent backwards"
        </member>
        <member name="M:Syn.Speech.Results.LatticeOptimizer.EquivalentNodeLabels(Syn.Speech.Results.Node,Syn.Speech.Results.Node)">
                    /// Is the contents of these Node equivalent?
                     *
                    /// @param n1
                    /// @param n2
                    /// @return true if n1 and n2 have "equivalent labels"
        </member>
        <member name="M:Syn.Speech.Results.LatticeOptimizer.MergeNodesAndEdgesBackward(Syn.Speech.Results.Node,Syn.Speech.Results.Edge,Syn.Speech.Results.Edge)">
                    /// given edges e1 and e2 to node n from nodes n1 and n2
                    /// <p/>
                    /// merge e1 and e2, that is, merge the scores of e1 and e2 create n' that is a merge of n1 and n2 add n' add edge e'
                    /// from n' to n
                    /// <p/>
                    /// remove n1 and n2 and all associated edges
                     *
                    /// @param n
                    /// @param e1
                    /// @param e2
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.LatticeOptimizer.RemoveHangingNodes" -->
        <member name="M:Syn.Speech.Results.LatticeOptimizer.MergeAcousticScores(System.Double,System.Double)">
                    /// Provides a single method to merge acoustic scores, so that changes to how acoustic score are merged can be made
                    /// at one point only.
                     *
                    /// @param score1 the first acoustic score
                    /// @param score2 the second acoustic score
                    /// @return the merged acoustic score
        </member>
        <member name="M:Syn.Speech.Results.LatticeOptimizer.MergeLanguageScores(System.Double,System.Double)">
                    /// Provides a single method to merge language scores, so that changes to how language score are merged can be made
                    /// at one point only.
                     *
                    /// @param score1 the first language score
                    /// @param score2 the second language score
                    /// @return the merged language score
        </member>
        <member name="M:Syn.Speech.Results.LatticeOptimizer.Main(System.String[])">
                    /// Self test for LatticeOptimizer
                     *
                    /// @param args
        </member>
        <member name="T:Syn.Speech.Results.Nbest">
            <summary>
            NBest list with A*
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Results.Node" -->
        <member name="M:Syn.Speech.Results.Node.#ctor(Syn.Speech.Linguist.Dictionary.Word,System.Int32,System.Int32)">
                    /// Create a new Node
                     *
                    /// @param word      the word of this node
                    /// @param beginTime the start time of the word
                    /// @param endTime   the end time of the word
        </member>
        <member name="M:Syn.Speech.Results.Node.#ctor(System.String,Syn.Speech.Linguist.Dictionary.Word,System.Int64,System.Int64)">
                    /// Create a new Node with given ID. Used when creating a Lattice from a .LAT file
                     *
                    /// @param id
                    /// @param word
                    /// @param beginTime
                    /// @param endTime
        </member>
        <member name="M:Syn.Speech.Results.Node.GetNextNodeId">
                    /// Get a unique ID for a new Node. Used when creating a Lattice from a .LAT file
                     *
                    /// @return the unique ID for a new node
        </member>
        <member name="M:Syn.Speech.Results.Node.HasEdgeToNode(Syn.Speech.Results.Node)">
                    /// Test if a node has an Edge to a Node
                     *
                    /// @param n
                    /// @return unique Node ID
        </member>
        <member name="M:Syn.Speech.Results.Node.GetEdgeToNode(Syn.Speech.Results.Node)">
                    /// given a node find the edge to that node
                     *
                    /// @param n the node of interest
                    /// @return the edge to that node or <code> null</code>  if no edge could be found.
        </member>
        <member name="M:Syn.Speech.Results.Node.HasEdgeFromNode(Syn.Speech.Results.Node)">
                    /// Test is a Node has an Edge from a Node
                     *
                    /// @param n
                    /// @return true if this node has an Edge from n
        </member>
        <member name="M:Syn.Speech.Results.Node.GetEdgeFromNode(Syn.Speech.Results.Node)">
                    /// given a node find the edge from that node
                     *
                    /// @param n the node of interest
                    /// @return the edge from that node or <code> null</code>  if no edge could be found.
        </member>
        <member name="M:Syn.Speech.Results.Node.HasEquivalentEnteringEdges(Syn.Speech.Results.Node)">
                    /// Test if a Node has all Edges from the same Nodes and another Node.
                     *
                    /// @param n
                    /// @return true if this Node has Edges from the same Nodes as n
        </member>
        <member name="M:Syn.Speech.Results.Node.HasEquivalentLeavingEdges(Syn.Speech.Results.Node)">
                    /// Test if a Node has all Edges to the same Nodes and another Node.
                     *
                    /// @param n the node of interest
                    /// @return true if this Node has all Edges to the sames Nodes as n
        </member>
        <member name="M:Syn.Speech.Results.Node.GetCopyOfEnteringEdges">
                    /// Returns a copy of the Edges to this Node, so that the underlying data structure will not be modified.
                     *
                    /// @return a copy of the edges to this node
        </member>
        <member name="M:Syn.Speech.Results.Node.GetCopyOfLeavingEdges">
                    /// Returns a copy of the Edges from this Node, so that the underlying data structure will not be modified.
                     *
                    /// @return a copy of the edges from this node
        </member>
        <member name="M:Syn.Speech.Results.Node.AddEnteringEdge(Syn.Speech.Results.Edge)">
                    /// Add an Edge from this Node
                     *
                    /// @param e
        </member>
        <member name="M:Syn.Speech.Results.Node.AddLeavingEdge(Syn.Speech.Results.Edge)">
                    /// Add an Edge to this Node
                     *
                    /// @param e
        </member>
        <member name="M:Syn.Speech.Results.Node.RemoveEnteringEdge(Syn.Speech.Results.Edge)">
                    /// Remove an Edge from this Node
                     *
                    /// @param e
        </member>
        <member name="M:Syn.Speech.Results.Node.RemoveLeavingEdge(Syn.Speech.Results.Edge)">
                    /// Remove an Edge to this Node
                     *
                    /// @param e the edge to remove
        </member>
        <member name="M:Syn.Speech.Results.Node.ToString">
                    /// Returns a description of this Node that contains the word, the start time, and the end time.
                     *
                    /// @return a description of this Node
        </member>
        <member name="M:Syn.Speech.Results.Node.DumpAISee(System.IO.StreamWriter)">
                    /// Internal routine when dumping Lattices as AiSee files
                     *
                    /// @param f
                    /// @throws IOException
        </member>
        <member name="M:Syn.Speech.Results.Node.DumpDot(System.IO.StreamWriter)">
                    /// Internal routine when dumping Lattices as Graphviz files
                    /// 
                    /// @param f
                    /// @throws IOException
        </member>
        <member name="M:Syn.Speech.Results.Node.Dump(System.IO.StreamWriter)">
                    /// Internal routine used when dumping Lattices as .LAT files
                     *
                    /// @param f
                    /// @throws IOException
        </member>
        <member name="M:Syn.Speech.Results.Node.Load(Syn.Speech.Results.Lattice,Syn.Speech.Helper.StringTokenizer)">
                    /// Internal routine used when loading Lattices from .LAT files
                     *
                    /// @param lattice
                    /// @param tokens
        </member>
        <member name="M:Syn.Speech.Results.Node.GetHashCode">
            @see java.lang.Object#hashCode() 
        </member>
        <member name="M:Syn.Speech.Results.Node.Equals(System.Object)">
                    /// Assumes ids are unique node identifiers
                     *
                    /// @see java.lang.Object#equals(java.lang.Object)
        </member>
        <member name="M:Syn.Speech.Results.Node.CalculateBeginTime">
                    /// Calculates the begin time of this node, in the event that the begin time was not specified. The begin time is the
                    /// latest of the end times of its predecessor nodes.
        </member>
        <member name="M:Syn.Speech.Results.Node.GetChildNodes">
                    /// Get the nodes at the other ends of outgoing edges of this node.
                     *
                    /// @return a list of child nodes
        </member>
        <member name="M:Syn.Speech.Results.Node.IsAncestorOf(Syn.Speech.Results.Node)">
                    /// Check whether this node is an ancestor of another node.
                     *
                    /// @param node the Node to check
                    /// @return whether this node is an ancestor of the passed in node.
        </member>
        <member name="M:Syn.Speech.Results.Node.HasAncestralRelationship(Syn.Speech.Results.Node)">
                    /// Check whether this node has an ancestral relationship with another node (i.e. either this node is an ancestor of
                    /// the other node, or vice versa)
                     *
                    /// @param node the Node to check for a relationship
                    /// @return whether a relationship exists
        </member>
        <member name="M:Syn.Speech.Results.Node.IsEquivalent(Syn.Speech.Results.Node)">
                    /// Returns true if the given node is equivalent to this node. Two nodes are equivalent only if they have the same
                    /// word, the same number of entering and leaving edges, and that their begin and end times are the same.
                     *
                    /// @param other the Node we're comparing to
                    /// @return true if the Node is equivalent; false otherwise
        </member>
        <member name="M:Syn.Speech.Results.Node.FindEquivalentLeavingEdge(Syn.Speech.Results.Edge)">
                    /// Returns a leaving edge that is equivalent to the given edge. Two edges are eqivalent if Edge.isEquivalent()
                    /// returns true.
                     *
                    /// @param edge the Edge to compare the leaving edges of this node against
                    /// @return an equivalent edge, if any; or null if no equivalent edge
        </member>
        <member name="P:Syn.Speech.Results.Node.EnteringEdges">
                    /// Get the Edges to this Node
                     *
                    /// @return Edges to this Node
        </member>
        <member name="P:Syn.Speech.Results.Node.LeavingEdges">
                    /// Get the Edges from this Node
                     *
                    /// @return Edges from this Node
        </member>
        <member name="P:Syn.Speech.Results.Node.Id">
                    /// Get the ID associated with this Node
                     *
                    /// @return the ID
        </member>
        <member name="P:Syn.Speech.Results.Node.Word">
                    /// Get the word associated with this Node
                     *
                    /// @return the word
        </member>
        <member name="P:Syn.Speech.Results.Node.BeginTime">
                    /// Get the frame number when the word began
                     *
                    /// @return the begin frame number, or -1 if the frame number is unknown
        </member>
        <member name="P:Syn.Speech.Results.Node.EndTime">
                    /// Get the frame number when the word ends
                     *
                    /// @return the end time, or -1 if the frame number if is unknown
        </member>
        <member name="P:Syn.Speech.Results.Node.BackwardScore">
                    /// Returns the backward score, which is calculated during the computation of the posterior score for this node.
                     *
                    /// @return Returns the backwardScore.
        </member>
        <member name="P:Syn.Speech.Results.Node.ForwardScore">
                    /// Returns the forward score, which is calculated during the computation of the posterior score for this node.
                     *
                    /// @return Returns the forwardScore.
        </member>
        <member name="P:Syn.Speech.Results.Node.Posterior">
                    /// Returns the posterior probability of this node. Refer to the javadocs for this class for a description of
                    /// posterior probabilities.
                     *
                    /// @return Returns the posterior probability of this node.
        </member>
        <member name="P:Syn.Speech.Results.Node.BestPredecessor">
                    /// Returns the best predecessor for this node.
                     *
                    /// @return Returns the bestPredecessor.
        </member>
        <member name="P:Syn.Speech.Results.Node.ViterbiScore">
                    /// Returns the Viterbi score for this node. The Viterbi score is usually computed during the speech recognition
                    /// process.
                     *
                    /// @return Returns the viterbiScore.
        </member>
        <member name="T:Syn.Speech.Results.IPath">
            Represents a path of words through the recognition result lattice.
            <p/>
            All scores are maintained in the logMath log domain
        </member>
        <member name="M:Syn.Speech.Results.IPath.GetScore">
             Gets the total score for this path. Scores are in the LogMath log domain
            
             @return the score for the path in the LogMath log domaain.
        </member>
        <member name="M:Syn.Speech.Results.IPath.GetConfidence">
             Returns a log confidence score for this path. Use the getLogMath().logToLinear() method to convert the log
             confidence score to linear. The linear value should be between 0.0 and 1.0 (inclusive).
            
             @return a log confidence score which linear value is between 0.0 and 1.0 (inclusive)
        </member>
        <member name="M:Syn.Speech.Results.IPath.GetWords">
             Gets the ordered set of words for this path
            
             @return an array containing zero or more words
        </member>
        <member name="M:Syn.Speech.Results.IPath.GetTranscription">
             Gets the transcription of the path.
            
             @return the transcription of the path.
        </member>
        <member name="M:Syn.Speech.Results.IPath.GetTranscriptionNoFiller">
             Gets the transcription of the path skipping the filler words
            
             @return the transcription of the path without fillers.
        </member>
        <member name="M:Syn.Speech.Results.IPath.ToString">
            <summary>
            Returns a string representation of this object
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:Syn.Speech.Results.Result">
             <summary>
             Provides recognition results. Results can be partial or final. A result should not be modified
             before it is a final result. Note that a result may not contain all possible information.
            
             The following methods are not yet defined but should be:
            
            
             public Result getDAG(int compressionLevel);
            
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.#ctor(Syn.Speech.Decoders.Search.AlternateHypothesisManager,Syn.Speech.Decoders.Search.ActiveList,System.Collections.Generic.List{Syn.Speech.Decoders.Search.Token},System.Int32,System.Boolean,System.Boolean,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.#ctor(Syn.Speech.Decoders.Search.ActiveList,System.Collections.Generic.List{Syn.Speech.Decoders.Search.Token},System.Int32,System.Boolean,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.IsFinal" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.GetBestFinalToken" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.GetBestToken" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.GetBestActiveToken" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.FindToken(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.FindPartialMatchingTokens(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.GetBestActiveParitalMatchingToken(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.GetFrameStatistics" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.GetDataFrames" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.GetBestResultNoFiller" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.GetBestFinalResultNoFiller" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.GetBestPronunciationResult" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.GetTimedBestResult(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.GetTimedWordPath(Syn.Speech.Decoders.Search.Token,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.GetTimedWordTokenLastPath(Syn.Speech.Decoders.Search.Token,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.ToString" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.SetFinal(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Results.Result.Validate" -->
        <!-- Badly formed XML comment ignored for member "P:Syn.Speech.Results.Result.LogMath" -->
        <!-- Badly formed XML comment ignored for member "P:Syn.Speech.Results.Result.ActiveTokens" -->
        <!-- Badly formed XML comment ignored for member "P:Syn.Speech.Results.Result.ResultTokens" -->
        <!-- Badly formed XML comment ignored for member "P:Syn.Speech.Results.Result.AlternateHypothesisManager" -->
        <!-- Badly formed XML comment ignored for member "P:Syn.Speech.Results.Result.FrameNumber" -->
        <!-- Badly formed XML comment ignored for member "P:Syn.Speech.Results.Result.StartFrame" -->
        <!-- Badly formed XML comment ignored for member "P:Syn.Speech.Results.Result.EndFrame" -->
        <!-- Badly formed XML comment ignored for member "P:Syn.Speech.Results.Result.ReferenceText" -->
        <member name="P:Syn.Speech.Results.Result.WordTokenFirst">
            Getter for wordTokenFirst flag
            
            @return true if word tokens goes first, before data tokens 
        </member>
        <member name="F:Syn.Speech.Helper.StringTokenizer.DefaultDelimiters">
            <summary>
            string conatining the default set of delimiters which are <c>" \t\n\r\f"</c>:
            the space character, the tab character, the newline character, the carriage-return character, and the form-feed character.
            </summary>
        </member>
        <member name="M:Syn.Speech.Helper.StringTokenizer.#ctor(System.String)">
            <summary>
            Constructs a string tokenizer for the specified string using the <see cref="F:DefaultDelimiters">default delimiters</see>.
            </summary>
            <param name="str">The string to be tokenized.</param>
            <exception cref="T:System.NullReferenceException">Thrown when the passed string is <c>null</c></exception>
        </member>
        <member name="M:Syn.Speech.Helper.StringTokenizer.#ctor(System.String,System.String)">
            <summary>
            Constructs a string tokenizer for the specified string using the given delimiters.
            </summary>
            <param name="str">The string to be tokenized.</param>
            <param name="delims">The delimiters used to tokenize the string (each <see cref="!:char"/> will be used as a delimiter).</param>
            <exception cref="T:System.NullReferenceException">Thrown when the passed string is <c>null</c></exception>
        </member>
        <member name="M:Syn.Speech.Helper.StringTokenizer.#ctor(System.String,System.Char[])">
            <summary>
            Constructs a string tokenizer for the specified string using the given delimiters.
            </summary>
            <param name="str">The string to be tokenized.</param>
            <param name="delims">The delimiters used to tokenize the string.</param>
        </member>
        <member name="M:Syn.Speech.Helper.StringTokenizer.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Constructs a string tokenizer for the specified string using the given delimiters and optionally returning them as tokens.
            </summary>
            <param name="str">The string to be tokenized.</param>
            <param name="delims">The delimiters used to tokenize the string (each <see cref="!:char"/> will be used as a delimiter).</param>
            <param name="returnDelims">If set to <c>true</c> the encountered delimiters will also be returned as tokens.</param>
            <exception cref="T:System.NullReferenceException">Thrown when the passed string is <c>null</c></exception>
        </member>
        <member name="M:Syn.Speech.Helper.StringTokenizer.#ctor(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Constructs a string tokenizer for the specified string using the given delimiters,
            optionally returning them as tokens. Also empty tokens may be returned using the <see cref="!:String.Empty"/> string.
            </summary>
            <param name="str">The string to be tokenized.</param>
            <param name="delims">The delimiters used to tokenize the string (each <see cref="!:char"/> will be used as a delimiter).</param>
            <param name="returnDelims">If set to <c>true</c> the encountered delimiters will also be returned as tokens.</param>
            <param name="returnEmpty">If set to <c>true</c> empty tokens will also be returned.</param>
            <exception cref="T:System.NullReferenceException">Thrown when the passed string is <c>null</c></exception>
        </member>
        <member name="M:Syn.Speech.Helper.StringTokenizer.#ctor(System.String,System.String,System.Boolean,System.Boolean,System.String)">
            <summary>
            Constructs a string tokenizer for the specified string using the given delimiters,
            optionally returning them as tokens. Also empty tokens may be returned using the <paramref name="empty"/> string.
            </summary>
            <param name="str">The string to be tokenized.</param>
            <param name="delims">The delimiters used to tokenize the string (each <see cref="!:char"/> will be used as a delimiter).</param>
            <param name="returnDelims">If set to <c>true</c> the encountered delimiters will also be returned as tokens.</param>
            <param name="returnEmpty">If set to <c>true</c> empty tokens will also be returned.</param>
            <param name="empty">The string to be returned as an empty token.</param>
            <exception cref="T:System.NullReferenceException">Thrown when the passed string is <c>null</c></exception>
        </member>
        <member name="M:Syn.Speech.Helper.StringTokenizer.Reset">
            <summary>
            Resets the current position index so that the tokens can be extracted again.
            </summary>
            <remarks><see cref="!:Equivalent not available in Java!"/></remarks>
        </member>
        <member name="M:Syn.Speech.Helper.StringTokenizer.hasMoreTokens">
            <summary>
            Tests if there are more tokens available from this tokenizer's string.
            If this method returns <c>true</c>, then a subsequent call to <see cref="M:nextToken"/> will successfully return a token.
            </summary>
            <returns>
            	<c>true</c> if and only if there is at least one token in the string after the current position; otherwise <c>false</c>.
            </returns>
            <seealso cref="M:nextToken"/>
        </member>
        <member name="M:Syn.Speech.Helper.StringTokenizer.nextToken">
            <summary>
            Returns the next token from this string tokenizer.
            </summary>
            <returns>The next token from this string tokenizer.</returns>
        </member>
        <member name="M:Syn.Speech.Helper.StringTokenizer.countTokens">
            <summary>
            Calculates the number of times that this tokenizer's <see cref="M:nextToken"/> method can be called before it generates an exception. The current position is not advanced.
            </summary>
            <returns>The number of tokens remaining in the string using the current delimiter set.</returns>
        </member>
        <member name="M:Syn.Speech.Helper.StringTokenizer.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Syn.Speech.Helper.StringTokenizer.HasMoreTokens">
            <summary>
            Tests if there are more tokens available from this tokenizer's string.
            If this method returns <c>true</c>, then a subsequent
            use of the <see cref="P:NextToken"/> property will successfully return a token.
            </summary>
            <value>
            	<c>true</c> if more tokens are available; otherwise <c>false</c>.
            </value>
        </member>
        <member name="P:Syn.Speech.Helper.StringTokenizer.NextToken">
            <summary>
            Gets the next token.
            </summary>
            <value>The next token.</value>
            <exception cref="T:System.IndexOutOfRangeException">Thrown when trying to get a token which doesn't exist.
            Usually caused by not checking if the <see cref="P:HasMoreTokens"/> property returns <c>true</c> before trying to get the next token.</exception>
        </member>
        <member name="P:Syn.Speech.Helper.StringTokenizer.CountTokens">
            <summary>
            Counts the <see cref="!:remaining"/> tokens - the number of times the
            <see cref="P:NextToken"/> property can be used before it throws an exception.
            </summary>
            <value>The number of remaining tokens.</value>
            <seealso cref="P:Count"/>
        </member>
        <member name="P:Syn.Speech.Helper.StringTokenizer.Count">
            <summary>
            Gets the total number of tokens extracted.
            </summary>
            <remarks>
            <see cref="!:Equivalent not available in Java!"/>
            This property returns the total number of extracted tokens,
            contrary to <see cref="P:CountTokens"/>.
            </remarks>
            <value>The number of tokens extracted.</value>
            <seealso cref="P:StringTokenizer.CountTokens"/>
        </member>
        <member name="P:Syn.Speech.Helper.StringTokenizer.Item(System.Int32)">
            <summary>
            Gets the token with the specified index from the tokenizer without moving the current position index.
            </summary>
            <remarks><see cref="!:Equivalent not available in Java!"/></remarks>
            <param name="index">The index of the token to get.</param>
            <value>The token with the given index</value>
            <exception cref="T:System.IndexOutOfRangeException">Thrown when trying to get a token which doesn't exist, that is when <see cref="!:index"/> is equal or greater then <see cref="!:Count"/> or <see cref="!:index"/> is negative.</exception>
        </member>
        <member name="P:Syn.Speech.Helper.StringTokenizer.EmptyString">
            <summary>
            Gets the currently set string for empty tokens.
            </summary>
            <remarks>Default is <c>System.String.Empty</c></remarks>
            <value>The empty token string.</value>
        </member>
        <member name="T:Syn.Speech.Results.WordResult">
            <summary>
            Represents a word in a recognition result.
            This is designed specifically for obtaining confidence scores.
            All scores are maintained in LogMath log base.
            </summary>
        </member>
        <member name="M:Syn.Speech.Results.WordResult.#ctor(Syn.Speech.Linguist.Dictionary.Word,Syn.Speech.Util.TimeFrame,System.Double,System.Double)">
            <summary>
            Construct a word result with full information.
            @param w the word object to store
            @param timeFrame time frame
            @param ef word end time
            @param score score of the word
            @param confidence confidence (posterior) of the word
            </summary>
        </member>
        <member name="M:Syn.Speech.Results.WordResult.#ctor(Syn.Speech.Results.Node)">
            <summary>
            Construct a WordResult using a Node object and a confidence (posterior).
            This does not use the posterior stored in the Node object, just its
            word, start and end.
            TODO: score is currently set to zero
            @param node the node to extract information from
            @param confidence the confidence (posterior) to assign
            </summary>
        </member>
        <member name="M:Syn.Speech.Results.WordResult.GetConfidence">
            <summary>
            Returns a log confidence score for this WordResult.
            Use the getLogMath().logToLinear() method to convert the log confidence
            score to linear. The linear value should be between 0.0 and 1.0
            (inclusive) for this word.
            @return a log confidence score which linear value is in [0, 1]
            </summary>
        </member>
        <member name="M:Syn.Speech.Results.WordResult.GetPronunciation">
            <summary>
            Gets the pronunciation for this word.
            @return the pronunciation for the word
            </summary>
        </member>
        <member name="M:Syn.Speech.Results.WordResult.IsFiller">
            <summary>
            Does this word result represent a filler token?
            @return true if this is a filler
            </summary>
        </member>
        <member name="P:Syn.Speech.Results.WordResult.Score">
            <summary>
            Gets the total score for this word.
            @return the score for the word (in LogMath log base)
            </summary>
        </member>
        <member name="P:Syn.Speech.Results.WordResult.Word">
            <summary>
            Gets the word object associated with the given result.
            @return the word object
            </summary>
        </member>
        <member name="P:Syn.Speech.Results.WordResult.TimeFrame">
            <summary>
            Gets time frame for the word
            </summary>
        </member>
        <member name="T:Syn.Speech.Results.WordResultPath">
            <summary>
            An implementation of a result Path that computes scores and confidences on the fly.
            @author P. Gorniak
            </summary>
        </member>
        <member name="M:Syn.Speech.Results.WordResultPath.#ctor(System.Collections.Generic.List{Syn.Speech.Results.WordResult})">
             Constructs a WordResultPath with the given list of WordResults and LogMath.
            
             @param wordResults the list of WordResults
        </member>
        <member name="M:Syn.Speech.Results.WordResultPath.#ctor">
            Constructs an empty WordResultPath. 
        </member>
        <member name="M:Syn.Speech.Results.WordResultPath.GetScore">
            @see edu.cmu.sphinx.result.Path#getScore() 
        </member>
        <member name="M:Syn.Speech.Results.WordResultPath.GetConfidence">
            @see edu.cmu.sphinx.result.Path#getConfidence() 
        </member>
        <member name="M:Syn.Speech.Results.WordResultPath.GetWords">
            @see edu.cmu.sphinx.result.Path#getWords() 
        </member>
        <member name="M:Syn.Speech.Results.WordResultPath.GetTranscription">
            @see edu.cmu.sphinx.result.Path#getTranscription() 
        </member>
        <member name="M:Syn.Speech.Results.WordResultPath.GetTranscriptionNoFiller">
            @see edu.cmu.sphinx.result.Path#getTranscriptionNoFiller() 
        </member>
        <member name="M:Syn.Speech.SpeakerId.SpeakerCluster.GetSpeakerIntervals">
            Returns a 2 * n length array where n is the numbers of intervals assigned
            to the speaker modeled by this cluster every pair of elements with
            indexes (2 * i, 2 * i + 1) represents the start time and the length for
            each interval
            
            We may need a delay parameter to this function because the segments may
            not be exactly consecutive
        </member>
        <member name="T:Syn.Speech.SpeakerId.SpeakerIdentification">
            <summary>
            Provides method for detecting the number of speakers from a given input file
            </summary>
        </member>
        <member name="M:Syn.Speech.SpeakerId.SpeakerIdentification.GetFeatures">
            @return The list of feature vectors from the fileStream used by
                    audioSource
        </member>
        <member name="M:Syn.Speech.SpeakerId.SpeakerIdentification.GetLikelihoodRatio(System.Double,System.Int32,Syn.Speech.Helper.Mathematics.Linear.Array2DRowRealMatrix)">
            
            @param bicValue
                       The bicValue of the model represented by only one Gaussian.
                       This parameter it's useful when this function is called
                       repeatedly for different frame values and the same features
                       parameter
            @param frame
                       the frame which is tested for being a change point
            @param features
                       the feature vectors matrix
            @return the likelihood ratio
        </member>
        <member name="M:Syn.Speech.SpeakerId.SpeakerIdentification.GetPoint(System.Int32,System.Int32,System.Int32,Syn.Speech.Helper.Mathematics.Linear.Array2DRowRealMatrix)">
            @param start
                       The starting frame
            @param length
                       The length of the interval, as numbers of frames
            @param features
                       The matrix build with feature vectors as rows
            @return Returns the changing point in the input represented by features
            
        </member>
        <member name="M:Syn.Speech.SpeakerId.SpeakerIdentification.GetAllChangingPoints(Syn.Speech.Helper.Mathematics.Linear.Array2DRowRealMatrix)">
            
            @param features
                       Matrix with feature vectors as rows
            @return A list with all changing points detected in the file
        </member>
        <member name="M:Syn.Speech.SpeakerId.SpeakerIdentification.GetBICValue(Syn.Speech.Helper.Mathematics.Linear.Array2DRowRealMatrix)">
            @param mat
                       A matrix with feature vectors as rows.
            @return Returns the BICValue of the Gaussian model that approximates the
                    the feature vectors data samples
        </member>
        <member name="M:Syn.Speech.SpeakerId.SpeakerIdentification.Cluster(System.IO.Stream)">
            @param inputFileName The name of the file used for diarization
            @return A cluster for each speaker found in the input file
        </member>
        <member name="M:Syn.Speech.SpeakerId.SpeakerIdentification.Cluster(System.Collections.Generic.List{System.Single[]})">
            @param features The feature vectors to be used for clustering
            @return A cluster for each speaker detected based on the feature vectors provided
        </member>
        <member name="M:Syn.Speech.SpeakerId.SpeakerIdentification.UpdateDistances(System.Collections.Generic.List{Syn.Speech.SpeakerId.SpeakerCluster},System.Int32,System.Int32,Syn.Speech.Helper.Mathematics.Linear.Array2DRowRealMatrix)">
            @param Clustering
                       The array of clusters
            @param posi
                       The index of the merged cluster
            @param posj
                       The index of the cluster that will be eliminated from the
                       clustering
            @param distance
                       The distance matrix that will be updated
        </member>
        <member name="M:Syn.Speech.SpeakerId.SpeakerIdentification.UpdateDistances(System.Collections.Generic.List{Syn.Speech.SpeakerId.SpeakerCluster})">
            @param Clustering
                       The array of clusters
        </member>
        <member name="M:Syn.Speech.SpeakerId.SpeakerIdentification.ArrayToRealMatrix(System.Collections.Generic.List{System.Single[]},System.Int32)">
            @param lst
                       An ArrayList with all the values being vectors of the same
                       dimension
            @return The RealMatrix with the vectors from the ArrayList on columns
        </member>
        <member name="T:Syn.Speech.Tools.Bandwidth.BandDetector">
            A simple energy-based detector for upsampled audio. Could be used to detect
            bandwidth issues leading to the accuracy issues.
            
            The detector simply looks for energies in different mel bands and using the
            threshold it decides if we have cut of the frequencies signal. On every frame
            we find the maximum energy band, then we just control that energy doesn't
            fall too fast in upper bands.
            
            A paper on the subject is "DETECTING BANDLIMITED AUDIO IN BROADCAST TELEVISION SHOWS"
            by by Mark C. Fuhs, Qin Jin and Tanja Schultz where spline approximation is proposed
            for detection. However, the paper seems to contain a fundamental flaw. The
            decision is made on average spectrum, not per-frame. This probably leads
            to omission of the events in high frequency which might signal about wide band.
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Tools.Batch.BatchModeRecognizer" -->
        <member name="F:Syn.Speech.Tools.Batch.BatchModeRecognizer.PROP_SKIP">
                    /// The property or how many files to skip for every decode.
        </member>
        <member name="F:Syn.Speech.Tools.Batch.BatchModeRecognizer.PROP_COUNT">
                    /// The property for how many utterances to process
        </member>
        <member name="F:Syn.Speech.Tools.Batch.BatchModeRecognizer.PROP_WHICH_BATCH">
                    /// The property that specified which batch job is to be run.
        </member>
        <member name="F:Syn.Speech.Tools.Batch.BatchModeRecognizer.PROP_TOTAL_BATCHES">
                    /// The property for the total number of batch jobs the decoding run is being divided into.
                    /// <p/>
                    /// The BatchDecoder supports running a subset of a batch. This allows a test to be distributed among several
                    /// machines.
        </member>
        <member name="F:Syn.Speech.Tools.Batch.BatchModeRecognizer.PROP_USE_POOLED_BATCH_MANAGER">
                    /// The property that defines whether or not the decoder should use the pooled batch manager
        </member>
        <member name="F:Syn.Speech.Tools.Batch.BatchModeRecognizer.PROP_RECOGNIZER">
                    /// The property that specifies the recognizer to use
        </member>
        <member name="F:Syn.Speech.Tools.Batch.BatchModeRecognizer.PROP_INPUT_DATA_PROCESSORS">
                    /// The property that specifies the input source
        </member>
        <member name="M:Syn.Speech.Tools.Batch.BatchModeRecognizer.setBatchFile(System.String)">
                    /// Sets the batch file to use for this recognition
                     *
                    /// @param batchFile the name of the batch file
                    /// @throws IOException if the file could not be opened or read.
        </member>
        <member name="M:Syn.Speech.Tools.Batch.BatchModeRecognizer.decode(System.String)">
                    /// Decodes the batch of audio files
        </member>
        <member name="M:Syn.Speech.Tools.Batch.BatchModeRecognizer.setInputStream(System.String)">
                    /// Sets the input stream to the given filename
                     *
                    /// @param filename the filename to set the input stream to
                    /// @throws IOException if an error occurs
        </member>
        <member name="M:Syn.Speech.Tools.Batch.BatchModeRecognizer.shell(System.String)">
                    /// Add commands to the given interpreter to support shell mode
                     *
                    /// @param ci the interpreter
        </member>
        <member name="M:Syn.Speech.Tools.Batch.BatchModeRecognizer.main(System.String[])">
                    /// Main method of this BatchDecoder.
                     *
                    /// @param argv argv[0] : config.xml argv[1] : a file listing all the audio files to decode
        </member>
        <member name="T:Syn.Speech.Trainer.Edge">
            <summary>
            Defines the basic Edge for any graph A generic graph edge must have a destination Node and an identifier.
            </summary>
        </member>
        <member name="F:Syn.Speech.Trainer.Edge.id">
            The identifier for this edge 
        </member>
        <member name="F:Syn.Speech.Trainer.Edge.sourceNode">
            The source node for this edge 
        </member>
        <member name="F:Syn.Speech.Trainer.Edge.destinationNode">
            The destination node for this edge 
        </member>
        <member name="M:Syn.Speech.Trainer.Edge.setDestination(Syn.Speech.Trainer.Node)">
                    /// Sets the destination node for a given edge.
                     *
                    /// @param node the destination node for this edge
                    /// @see #getDestination
        </member>
        <member name="M:Syn.Speech.Trainer.Edge.setSource(Syn.Speech.Trainer.Node)">
                    /// Sets source node for a given edge.
                     *
                    /// @param node the source node for this edge
                    /// @see #getSource
        </member>
        <member name="M:Syn.Speech.Trainer.Edge.getDestination">
                    /// Gets the destination node for a given edge.
                     *
                    /// @return the destination node
                    /// @see #setDestination
        </member>
        <member name="M:Syn.Speech.Trainer.Edge.getSource">
                    /// Gets source node for a given edge.
                     *
                    /// @return the source node
                    /// @see #setSource
        </member>
        <member name="M:Syn.Speech.Trainer.Edge.validate">
                    /// Validate this edge. Checks if source and destination are non-null.
                     *
                    /// @return if true, edge passed validation
        </member>
        <member name="M:Syn.Speech.Trainer.Edge.print">
            Prints out this edge. 
        </member>
        <member name="T:Syn.Speech.Trainer.Node">
            <summary>
            Defines the basic Node for any graph A generic graph Node must have a list of outgoing edges and an identifier.
            </summary>
        </member>
        <member name="F:Syn.Speech.Trainer.Node.nodeId">
            <summary>
            The identifier for this Node 
            </summary>
        </member>
        <member name="F:Syn.Speech.Trainer.Node._object">
            <summary>
            Object contained in this mode. Typically, an HMM state, a senone. 
            </summary>
        </member>
        <member name="F:Syn.Speech.Trainer.Node.nodeType">
            The type of node, such as a dummy node or node represented by a specific type of symbol 
        </member>
        <member name="F:Syn.Speech.Trainer.Node.incomingEdges">
            The list of incoming edges to this node. 
        </member>
        <member name="F:Syn.Speech.Trainer.Node.outgoingEdges">
            The list of outgoing edges from this node 
        </member>
        <member name="M:Syn.Speech.Trainer.Node.#ctor(Syn.Speech.Trainer.NodeType,System.String)">
                    /// Constructor for node when a type and symbol are given.
                     *
                    /// @param nodeType   the type of node.
                    /// @param nodeSymbol the symbol for this type.
        </member>
        <member name="M:Syn.Speech.Trainer.Node.#ctor(Syn.Speech.Trainer.NodeType)">
                    /// Constructor for node when a type only is given.
                     *
                    /// @param nodeType the type of node.
        </member>
        <member name="M:Syn.Speech.Trainer.Node.setObject(System.Object)">
                    /// Assign an object to this node.
                     *
                    /// @param object the object to assign
        </member>
        <member name="M:Syn.Speech.Trainer.Node.getObject">
                    /// Retrieves the object associated with this node.
                     *
                    /// @return the object
        </member>
        <member name="M:Syn.Speech.Trainer.Node.addIncomingEdge(Syn.Speech.Trainer.Edge)">
                    /// Method to add an incoming edge. Note that we do not check if the destination node of the incoming edge is
                    /// identical to this node
                     *
                    /// @param edge the incoming edge
        </member>
        <member name="M:Syn.Speech.Trainer.Node.startIncomingEdgeIterator">
            Start iterator for incoming edges. 
        </member>
        <member name="M:Syn.Speech.Trainer.Node.hasMoreIncomingEdges">
                    /// Whether there are more incoming edges.
                     *
                    /// @return if true, there are more incoming edges
        </member>
        <member name="M:Syn.Speech.Trainer.Node.nextIncomingEdge">
                    /// Returns the next incoming edge to this node.
                     *
                    /// @return the next edge incoming edge
        </member>
        <member name="M:Syn.Speech.Trainer.Node.incomingEdgesSize">
                    /// Returns the size of the incoming edges list.
                     *
                    /// @return the number of incoming edges
        </member>
        <member name="M:Syn.Speech.Trainer.Node.addOutgoingEdge(Syn.Speech.Trainer.Edge)">
                    /// Method to add an outgoing edge. Note that we do not check if the source node of the outgoing edge is identical to
                    /// this node
                     *
                    /// @param edge the outgoing edge
        </member>
        <member name="M:Syn.Speech.Trainer.Node.startOutgoingEdgeIterator">
            Start iterator for outgoing edges. 
        </member>
        <member name="M:Syn.Speech.Trainer.Node.hasMoreOutgoingEdges">
                    /// Whether there are more outgoing edges.
                     *
                    /// @return if true, there are more outgoing edges
        </member>
        <member name="M:Syn.Speech.Trainer.Node.nextOutgoingEdge">
                    /// Returns the next outgoing edge from this node.
                     *
                    /// @return the next outgoing edge
        </member>
        <member name="M:Syn.Speech.Trainer.Node.outgoingEdgesSize">
                    /// Returns the size of the outgoing edges list.
                     *
                    /// @return the number of outgoing edges
        </member>
        <member name="M:Syn.Speech.Trainer.Node.isType(System.String)">
                    /// Method to check the type of a node.
                     *
                    /// @return if true, this node is of the type specified
        </member>
        <member name="M:Syn.Speech.Trainer.Node.getType">
                    /// Returns type of a node.
                     *
                    /// @return returns the type of this node
        </member>
        <member name="M:Syn.Speech.Trainer.Node.getID">
                    /// Returns the ID of a node. Typically, a string representing a word or a phoneme.
                     *
                    /// @return this node's ID
        </member>
        <member name="M:Syn.Speech.Trainer.Node.validate">
                    /// Validade node. Checks if all nodes have at least one incoming and one outgoing edge.
                     *
                    /// @return if true, node passed validation
        </member>
        <member name="M:Syn.Speech.Trainer.Node.print">
            Prints out this node. 
        </member>
        <member name="T:Syn.Speech.Trainer.NodeType">
            <summary>
            Indicates node types such as beginning, end, containing word etc.
            </summary>
        </member>
        <member name="F:Syn.Speech.Trainer.NodeType.DUMMY">
            NodeType to indicate dummy node. 
        </member>
        <member name="F:Syn.Speech.Trainer.NodeType.SILENCE_WITH_LOOPBACK">
            NodeType to indicate node containing silence with loopback. 
        </member>
        <member name="F:Syn.Speech.Trainer.NodeType.UTTERANCE_END">
            NodeType to indicate the end of a speech utterance. 
        </member>
        <member name="F:Syn.Speech.Trainer.NodeType.UTTERANCE_BEGIN">
            NodeType to indicate the start of am utterance. 
        </member>
        <member name="F:Syn.Speech.Trainer.NodeType.WORD">
            NodeType to indicate the node contains a word. 
        </member>
        <member name="F:Syn.Speech.Trainer.NodeType.PHONE">
            NodeType to indicate the node contains a word. 
        </member>
        <member name="F:Syn.Speech.Trainer.NodeType.STATE">
            NodeType to indicate the node contains a word. 
        </member>
        <member name="M:Syn.Speech.Trainer.NodeType.#ctor(System.String)">
            Constructs a NodeType with the given name. 
        </member>
        <member name="M:Syn.Speech.Trainer.NodeType.Equals(Syn.Speech.Trainer.NodeType)">
                    /// Returns true if the given NodeType is equal to this NodeType.
                     *
                    /// @param nodeType the NodeType to compare
                    /// @return true if they are the same, false otherwise
        </member>
        <member name="M:Syn.Speech.Trainer.NodeType.ToString">
                    /// Returns the name of this NodeType.
                     *
                    /// @return the name of this NodeType.
        </member>
        <member name="T:Syn.Speech.Util.BatchFile">
            <summary>
            Provides a set of utilities methods for manipulating batch files
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.BatchFile.GetLines(System.String)">
                    /// Returns a List of the lines in a batch file.
                     *
                    /// @param batchFile the batch file to read
                    /// @return a List of the lines in a batch file
        </member>
        <member name="M:Syn.Speech.Util.BatchFile.GetLines(System.String,System.Int32)">
                    /// Returns a List of the lines in a batch file.
                     *
                    /// @param batchFile the batch file to read
                    /// @param skip      the number of lines to skip between items
                    /// @return a List of the lines in a batch file
        </member>
        <member name="M:Syn.Speech.Util.BatchFile.GetFilename(System.String)">
                    /// Returns the file name portion of a line in a batch file. This is the portion of the line before the first space.
                     *
                    /// @return the file name portion of a line in a batch file.
        </member>
        <member name="M:Syn.Speech.Util.BatchFile.GetReference(System.String)">
                    /// Returns the reference string portion of a line in a batch file. This is the portion of the line after the first
                    /// space
                     *
                    /// @return the reference string portion of a line in a batch file.
        </member>
        <member name="T:Syn.Speech.Util.BatchItem">
            <summary>
             Provides a standard interface to for a single decode in a batch of decodes
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.BatchItem.#ctor(System.String,System.String)">
                    /// Creates a batch item
                     *
                    /// @param filename   the filename
                    /// @param transcript the transcript
        </member>
        <member name="P:Syn.Speech.Util.BatchItem.Filename">
                    /// Gets the filename for this batch
                     *
                    /// @return the file name
        </member>
        <member name="P:Syn.Speech.Util.BatchItem.Transcript">
                    /// Gets the transcript for the batch
                     *
                    /// @return the transcript (or null if there is no transcript)
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Util.Cache`1" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Util.Cache`1.cache(`0)" -->
        <member name="P:Syn.Speech.Util.Cache`1.Hits">
                    /// Returns the number of cache hits, which is the number of times {@link #cache} was called
                    /// and returned an object that already existed in the cache.
                     *
                    /// @return the number of cache hits
        </member>
        <member name="P:Syn.Speech.Util.Cache`1.Misses">
                    /// Returns the number of cache misses, which is the number of times {@link #cache} was called
                    /// and returned null (after caching the object), effectively representing the size of the cache. 
                     *
                    /// @return the number of cache misses
        </member>
        <member name="T:Syn.Speech.Util.ICommandInteface">
            <summary>
             An interface implemented by command functions typically added to a command interpreter
            </summary>
            
        </member>
        <member name="T:Syn.Speech.Util.ExtendedStreamTokenizer">
            <summary>
            A class that provides a mechanism for tokenizing a stream
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.#ctor(System.String)">
                    /// Creates and returns a stream tokenizer that has been properly configured to parse sphinx3 data This
                    /// ExtendedStreamTokenizer has no comment characters.
                     *
                    /// @param path the source of the data
                    /// @throws FileNotFoundException if a file cannot be found
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.#ctor(System.String,System.Boolean)">
                    /// Creates and returns a stream tokenizer that has been properly configured to parse sphinx3 data This
                    /// ExtendedStreamTokenizer has no comment characters.
                     *
                    /// @param path             the source of the data
                    /// @param eolIsSignificant if true eol is significant
                    /// @throws FileNotFoundException if a file cannot be found
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.#ctor(System.IO.StreamReader,System.Int32,System.Boolean)">
                    /// Constructs an ExtendedStreamTokenizer from the given InputStream
                     *
                    /// @param inputStream      the source of the data
                    /// @param commentChar      the comment character
                    /// @param eolIsSignificant true if EOL is significant, false otherwise
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.#ctor(System.IO.StreamReader,System.Boolean)">
                    /// Constructs an ExtendedStreamTokenizer from the given Reader. This ExtendedStreamTokenizer has no comment
                    /// characters.
                     *
                    /// @param reader           the source of the data
                    /// @param eolIsSignificant true if eol is significant
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.Close">
                    /// Closes the tokenizer
                     *
                    /// @throws IOException if an error occurs while closing the stream
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.WhitespaceChars(System.Int32,System.Int32)">
                    /// Specifies that all the characters between low and hi incluseive are whitespace characters
                     *
                    /// @param low the low end of the range
                    /// @param hi  the high end of the range
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.CommentChar(System.Int32)">
                    /// Specified that the character argument starts a single-line comment. All characters from the comment character to
                    /// the end of the line are ignored by this stream tokenizer.
                     *
                    /// @param ch the comment character
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.GetString">
            <summary>
            Gets the next word from the tokenizer
            @throws StreamCorruptedException if the word does not match
            @throws IOException              if an error occurs while loading the data
            </summary>
            <returns>the next word</returns>
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.Unget(System.String)">
                    /// Puts a string back, the next get will return this string
                     *
                    /// @param string the string to unget
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.IsEOF">
                    /// Determines if the stream is at the end of file
                     *
                    /// @return true if the stream is at EOF
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.Corrupt(System.String)">
                    /// Throws an error with the line and path added
                     *
                    /// @param msg the annotation message
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.GetLineNumber">
                    /// Gets the current line number
                     *
                    /// @return the line number
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.ExpectString(System.String)">
            <summary>
            Loads a word from the tokenizer and ensures that it matches 'expecting'
            @throws StreamCorruptedException if the word does not match
            @throws IOException              if an error occurs while loading the data
            </summary>
            <param name="expecting">expecting the word read must match this</param>
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.ExpectInt(System.String,System.Int32)">
                    /// Loads an integer  from the tokenizer and ensures that it matches 'expecting'
                     *
                    /// @param name      the name of the value
                    /// @param expecting the word read must match this
                    /// @throws StreamCorruptedException if the word does not match
                    /// @throws IOException              if an error occurs while loading the data
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.GetInt(System.String)">
                    /// gets an integer from the tokenizer stream
                     *
                    /// @param name the name of the parameter (for error reporting)
                    /// @return the next word in the stream as an integer
                    /// @throws StreamCorruptedException if the next value is not a
                    /// @throws IOException              if an error occurs while loading the data number
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.GetDouble(System.String)">
                    /// gets a double from the tokenizer stream
                     *
                    /// @param name the name of the parameter (for error reporting)
                    /// @return the next word in the stream as a double
                    /// @throws StreamCorruptedException if the next value is not a
                    /// @throws IOException              if an error occurs while loading the data number
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.GetFloat(System.String)">
                    /// gets a float from the tokenizer stream
                     *
                    /// @param name the name of the parameter (for error reporting)
                    /// @return the next word in the stream as a float
                    /// @throws StreamCorruptedException if the next value is not a
                    /// @throws IOException              if an error occurs while loading the data number
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.GetFloat(System.String,System.Single)">
                    /// gets a optional float from the tokenizer stream. If a float is not present, the default is returned
                     *
                    /// @param name         the name of the parameter (for error reporting)
                    /// @param defaultValue the default value
                    /// @return the next word in the stream as a float
                    /// @throws StreamCorruptedException if the next value is not a
                    /// @throws IOException              if an error occurs while loading the data number
        </member>
        <member name="M:Syn.Speech.Util.ExtendedStreamTokenizer.Skipwhite">
                    /// Skip any carriage returns.
                     *
                    /// @throws IOException if an error occurs while reading data from the stream.
        </member>
        <member name="T:Syn.Speech.Util.IBatchManager">
            <summary>
            Provides a standard interface to a batching mechanism
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.IBatchManager.Start">
                    /// Starts processing the batch
                     *
                    /// @throws IOException if an error occurs while processing the batch file
        </member>
        <member name="M:Syn.Speech.Util.IBatchManager.GetNextItem">
                    /// Gets the next available batch item or null if no more are available
                     *
                    /// @return the next available batch item
                    /// @throws IOException if an error occurs while processing the batch file
        </member>
        <member name="M:Syn.Speech.Util.IBatchManager.Stop">
                    /// Stops processing the batch
                     *
                    /// @throws IOException if an error occurs while processing the batch file
        </member>
        <member name="P:Syn.Speech.Util.IBatchManager.Filename">
                    /// Returns the name of the file
                     *
                    /// @return the filename
        </member>
        <member name="T:Syn.Speech.Util.LogMath">
            <summary>
            Provides a set of methods for performing simple math in the log domain.
            The logarithmic base can be set by the
            property: <code>LogMath.logBase</code>
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.LogMath.SetLogBase(System.Single)">
            <summary>
            Sets log base.
            According to forum discussions a value between 1.00001 and 1.0004 should
            be used for speech recognition. Going above 1.0005 will probably hurt.
            </summary>
            <param name="logBase"></param>
        </member>
        <member name="M:Syn.Speech.Util.LogMath.SetUseTable(System.Boolean)">
            <summary>
            The property that controls whether we use the old, slow (but correct)
            method of performing the LogMath.add by doing the actual computation. 
            </summary>
            <param name="useTable"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Util.LogMath.AddAsLinear(System.Single,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Util.LogMath.AddTableActualComputation(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Util.LogMath.AddTable(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Util.LogMath.SubtractAsLinear(System.Single,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Util.LogMath.LogToLog(System.Single,System.Single,System.Single)" -->
        <member name="M:Syn.Speech.Util.LogMath.LnToLog(System.Single)">
            <summary>
            Converts the source, which is a number in base Math.E, to a log value which base is the LogBase of this LogMath.
            </summary>
            <param name="logSource"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.LogMath.Log10ToLog(System.Single)">
            <summary>
            Converts the source, which is a number in base 10, to a log value which base is the LogBase of this LogMath.
            </summary>
            <param name="logSource"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.LogMath.LogToLn(System.Single)">
            <summary>
            Converts the source, whose base is the LogBase of this LogMath, to a log value which is a number in base Math.E.
            </summary>
            <param name="logSource"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Util.LogMath.LinearToLog(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Util.LogMath.LogToLinear(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Util.LogMath.Log10(System.Single)" -->
        <member name="M:Syn.Speech.Util.LogMath.LinearToLog(System.Single[])">
            <summary>
            Converts a vector from linear domain to log domain using a given <code>LogMath</code>-instance for conversion. 
            </summary>
            <param name="vector"></param>
        </member>
        <member name="M:Syn.Speech.Util.LogMath.LogToLinear(System.Single[],System.Single[])">
            <summary>
            Converts a vector from log to linear domain using a given <code>LogMath</code>-instance for conversion. 
            </summary>
            <param name="vector"></param>
            <param name="?"></param>
        </member>
        <member name="P:Syn.Speech.Util.LogMath.LogBase">
            <summary>
            Returns the actual log base. 
            </summary>
            <value></value>
        </member>
        <member name="T:Syn.Speech.Util.MatrixUtils">
            <summary>
            Some simple matrix and vector manipulation methods.
            </summary>
        </member>
        <member name="T:Syn.Speech.Util.NISTAlign">
            <summary>
            Implements a portion of the NIST align/scoring algorithm to compare a reference string to a hypothesis string.  
            It only keeps track of substitutions, insertions, and deletions.
            </summary>
        </member>
        <member name="F:Syn.Speech.Util.NISTAlign.Stars">
            <summary>
            Used for padding out aligned strings.
            </summary>
        </member>
        <member name="F:Syn.Speech.Util.NISTAlign._referenceAnnotation">
            The reference annotation; typically the name of the audio file for the reference string.  This is an optional
            part of the rawReference string.  If it is included, it is appended to the end of the string in parentheses.
            Updated with each call to 'align'.
        </member>
        <member name="F:Syn.Speech.Util.NISTAlign._referenceItems">
            Ordered list of words from rawReference after the annotation has been removed.  Updated with each call to
            'align'.
        </member>
        <member name="F:Syn.Speech.Util.NISTAlign._alignedReferenceWords">
            Aligned list of words from rawReference.  Created in alignWords.  Updated with each call to 'align'. 
        </member>
        <member name="F:Syn.Speech.Util.NISTAlign._rawHypothesis">
            The raw hypothesis string.  Updated with each call to 'align'. 
        </member>
        <member name="F:Syn.Speech.Util.NISTAlign._hypothesisItems">
            <summary>
            Ordered list of words from rawHypothesis after the annotation has been removed.  Updated with each call to'align'.
            </summary>
        </member>
        <member name="F:Syn.Speech.Util.NISTAlign._alignedHypothesisWords">
            <summary>
            Aligned list of words from rawHypothesis.  Created in alignWords.  Updated with each call to 'align'.
            </summary>
        </member>
        <member name="F:Syn.Speech.Util.NISTAlign.percentageFormat">
            Helpers to create percentage strings. 
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.#ctor(System.Boolean,System.Boolean)">
            Creates a new NISTAlign object. 
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.SetShowResults(System.Boolean)">
             Sets whether results are displayed
            
             @param showResults true if the results should be displayed
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.SetShowAlignedResults(System.Boolean)">
             Sets whether aligned results are displayed
            
             @param showAlignedResults true if the aligned results should be displayed
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.ResetTotals">
            Reset the total insertions, deletions, and substitutions counts for this class. 
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.Align(System.String,System.String)">
             Performs the NIST alignment on the reference and hypothesis strings.  This has the side effect of updating nearly
             all the fields of this class.
            
             @param reference  the reference string
             @param hypothesis the hypothesis string
             @return true if the reference and hypothesis match
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.GetReference">
             Returns the reference string.  This string will be filtered (all spurious whitespace removed and annotation
             removed) and set to all lower case.
            
             @return the reference string
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.GetHypothesis">
             Returns the hypothesis string.  This string will be filtered (all spurious whitespace removed and annotation
             removed) and set to all lower case.
            
             @return the hypothesis string
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.GetAlignedReference">
             Returns the aligned reference string.
            
             @return the aligned reference string
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.GetAlignedHypothesis">
             Returns the aligned hypothesis string.
            
             @return the aligned hypothesis string
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.GetTotalWordErrors">
             Gets the total number of word errors for all calls to align.
            
             @return the total number of word errors for all calls to align
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.GetTotalWordAccuracy">
             Returns the total word accuracy.
            
             @return the accuracy between 0.0 and 1.0
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.GetTotalWordErrorRate">
             Returns the total word accuracy.
            
             @return the accuracy between 0.0 and 1.0
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.GetTotalSentenceAccuracy">
             Returns the total sentence accuracy.
            
             @return the accuracy between 0.0 and 1.0
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.GetTotalWords">
             Gets the total number of words
            
             @return the total number of words
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.GetTotalSubstitutions">
             Gets the total number of substitution errors
            
             @return the total number of substitutions
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.GetTotalInsertions">
             Gets the total number of insertion errors
            
             @return the total number of insertion errors
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.GetTotalDeletions">
             Gets the total number of deletions
            
             @return the total number of deletions
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.GetTotalSentences">
             Gets the total number of sentences
            
             @return the total number of sentences
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.GetTotalSentencesWithErrors">
             Gets the total number of sentences with errors
            
             @return the total number of sentences with errors
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.PrintSentenceSummary">
             Prints the results for this sentence to System.out.  If you want the output to match the NIST output, see
             printNISTSentenceSummary.
            
             @see #printNISTSentenceSummary
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.PrintTotalSummary">
             Prints the total summary for all calls.  If you want the output to match the NIST output, see
             printNISTTotalSummary.
            
             @see #printNISTTotalSummary
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.PrintNistSentenceSummary">
            Prints the results for this sentence to System.out.  This matches the output from the NIST aligner. 
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.PrintNistTotalSummary">
            Prints the summary for all calls to align to System.out.  This matches the output from the NIST aligner. 
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.CreateBacktraceTable``1(System.Collections.Generic.LinkedList{``0},System.Collections.Generic.LinkedList{``0},Syn.Speech.Util.NISTAlign.IComparator)">
             Creates the backtrace table.  This is magic.  The basic idea is that the penalty table contains a set of penalty
             values based on some strategically selected numbers.  I'm not quite sure what they are, but they help determine
             the backtrace table values.  The backtrace table contains information used to help determine if words matched
             (OK), were inserted (INSERTION), substituted (SUBSTITUTION), or deleted (DELETION).
            
             @param referenceItems  the ordered list of reference words
             @param hypothesisItems the ordered list of hypothesis words
             @return the backtrace table
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.Backtrace(System.Int32[0:,0:])">
             Backtraces through the penalty table.  This starts at the "lower right" corner (i.e., the last word of the longer
             of the reference vs. hypothesis strings) and works its way backwards.
            
             @param backtraceTable created from call to createBacktraceTable
             @return a linked list of Integers representing the backtrace
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.AlignWords(System.Collections.Generic.LinkedList{Syn.Speech.Helper.Integer},Syn.Speech.Util.NISTAlign.IStringRenderer)">
             Based on the backtrace information, words are aligned as appropriate with insertions and deletions causing
             asterisks to be placed in the word lists.  This generates the alignedReferenceWords and alignedHypothesisWords
             lists.
            
             @param backtrace the backtrace list created in backtrace
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.UpdateTotals">
            Updates the total counts based on the current alignment. 
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.ToPercentage(System.String,System.Int32,System.Int32)">
             Turns the numerator/denominator into a percentage.
            
             @param pattern     percentage pattern (ala DecimalFormat)
             @param numerator   the numerator
             @param denominator the denominator
             @return a string that represents the percentage value.
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.ToPercentage(System.String,System.Single)">
             Turns the float into a percentage.
            
             @param pattern percentage pattern (ala DecimalFormat)
             @param value   the floating point value
             @return a string that represents the percentage value.
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.PadLeft(System.Int32,System.Int32)">
             Turns the integer into a left-padded string.
            
             @param width the total width of string, including spaces
             @param i     the integer
             @return a string padded left with spaces
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.PadLeft(System.Int32,System.String)">
             Pads a string to the left with spaces (i.e., prepends spaces to the string so it fills out the given width).
            
             @param width  the total width of string, including spaces
             @param string the string to pad
             @return a string padded left with spaces
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.ToList(System.String)">
             Converts the given string or words to a LinkedList.
            
             @param s the string of words to parse to a LinkedList
             @return a list, one word per item
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.Tostring``1(System.Collections.Generic.LinkedList{``0})">
             convert the list of words back to a space separated string
            
             @param list the list of words
             @return a space separated string
        </member>
        <member name="M:Syn.Speech.Util.NISTAlign.Main(System.String[])">
            Take two filenames -- the first contains a list of reference sentences, the second contains a list of hypothesis
            sentences. Aligns each pair of sentences and outputs the individual and total results.
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Fsts.Utils.Pair`2" -->
        <member name="M:Syn.Speech.Fsts.Utils.Pair`2.#ctor(`0,`1)">
                    /// Constructor specifying the left and right elements of the Pair.
        </member>
        <member name="M:Syn.Speech.Fsts.Utils.Pair`2.SetLeft(`0)">
                    /// Set the left element of the Pair
        </member>
        <member name="M:Syn.Speech.Fsts.Utils.Pair`2.SetRight(`1)">
                    /// Set the right element of the Pair
        </member>
        <member name="M:Syn.Speech.Fsts.Utils.Pair`2.GetLeft">
                    /// Get the left element of the Pair
        </member>
        <member name="M:Syn.Speech.Fsts.Utils.Pair`2.GetRight">
                    /// Get the right element of the Pair
        </member>
        <member name="T:Syn.Speech.Util.PooledBatchManager">
            <summary>
            A simple implementation of the batch manager suitable for single threaded batch processing
            </summary>
        </member>
        <member name="P:Syn.Speech.Util.PooledBatchManager.Filename">
                    /// Returns the name of the file
                     *
                    /// @return the filename
        </member>
        <member name="T:Syn.Speech.Util.Props.ConfigHandler">
            <summary>
            A SAX XML Handler implementation that builds up the map of raw property data objects
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigHandler.Characters(System.Char[],System.Int32,System.Int32)">
            <summary>
            Receive notification of character data inside an element.
            By default, do nothing. Application writers may override this method to take specific actions for each chunk of character data (such as adding the data to a node or buffer, or printing it to a file).
            </summary>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="len"></param>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigHandler.EndElement(Syn.Speech.Helper.URL,System.String,System.String)">
            <summary>
             Receive notification of the end of an element.
             By default, do nothing. Application writers may override this method in a subclass to take specific actions at the end of each element (such as finalising a tree node or writing output to a file).
            </summary>
            <param name="uri"></param>
            <param name="localName"></param>
            <param name="qName"></param>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigHandler.SetDocumentLocator(Syn.Speech.Helper.ILocator)">
            <summary>
            Receive a Locator object for document events. 
            </summary>
            <param name="locator"></param>
        </member>
        <member name="T:Syn.Speech.Util.Props.ConfigurationManager">
            <summary>
            Manages a set of <code>IConfigurable</code>s, their parameterization and the relationships between them. Configurations
            can be specified either by xml or on-the-fly during runtime. 
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManager.#ctor">
            <summary>
            Creates a new empty configuration manager. This constructor is only of use in cases when a system configuration
            is created during runtime.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManager.#ctor(Syn.Speech.Helper.URL)">
            <summary>
            Creates a new configuration manager. Initial properties are loaded from the given URL. No need to keep the notion
            of 'context' around anymore we will just pass around this property manager.
            </summary>
            <param name="url">Path to config file.</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManager.GetPropertySheet(System.String)">
            <summary>
            Returns the property sheet for the given object instance
            </summary>
            <param name="instanceName"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManager.GetInstanceNames(System.Type)">
                 /// Gets all instances that are of the given type.
                  *
                 /// @param type the desired type of instance
                 /// @return the set of all instances
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManager.GetComponentNames">
            <summary>
            Returns all names of configurables registered to this instance. The resulting set includes instantiated and
            non-instantiated components.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManager.GetGlobalProperties">
            Returns a copy of the map of global properties set for this configuration manager. 
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManager.GetGlobalProperty(System.String)">
            <summary>
            Returns a global property.
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManager.GetInstance``1(System.Type)">
            <summary>
            Creates an instance of the given <code>Configurable</code> by using the default parameters as defined by the
            class annotations to parameterize the component.
            </summary>
            <param name="targetClass"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManager.GetInstance``1(System.Type,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Creates an instance of the given <code>Configurable</code> by using the default parameters as defined by the
            class annotations to parameterize the component. Default parameters will be overridden if a their names are
            contained in the given <code>props</code>-map
            </summary>
            <param name="targetClass"></param>
            <param name="props"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManager.GetInstance``1(System.Type,System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>
            Creates an instance of the given <code>Configurable</code> by using the default parameters as defined by the
            class annotations to parameterize the component. Default parameters will be overridden if a their names are
            contained in the given <code>props</code>-map. The component is used to create a parameterized logger for the
            Configurable being created.
            </summary>
            <param name="targetClass"></param>
            <param name="props"></param>
            <param name="compName"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManager.FireConfChanged(System.String,System.String)">
            <summary>
            Informs all registered <code>ConfigurationChangeListener</code>s about a configuration changes the component
            named <code>configurableName</code>.
            </summary>
            <param name="configurableName"></param>
            <param name="propertyName"></param>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManager.SetGlobalProperty(System.String,System.String)">
                    /// Sets a global property.
                     *
                    /// @param propertyName The name of the global property.
                    /// @param value        The new value of the global property. If the value is <code>null</code> the property becomes
                    ///                     removed.
        </member>
        <member name="P:Syn.Speech.Util.Props.ConfigurationManager.ConfigUrl">
            <summary>
            Returns the URL of the XML configuration which defined this configuration or <code>null</code>  if it was created
            dynamically.
            </summary>
            <value></value>
        </member>
        <member name="T:Syn.Speech.Util.Props.ConfigurationManagerUtils">
            <summary>
            Some static utility methods which ease the handling of system configurations.
            </summary>
        </member>
        <member name="F:Syn.Speech.Util.Props.ConfigurationManagerUtils._globalSymbolPattern">
            <summary>
            this pattern matches strings of the form '${word}' 
            </summary>
        </member>
        <member name="F:Syn.Speech.Util.Props.ConfigurationManagerUtils.GlobalCommonLoglevel">
            <summary>
            A common property (used by all components) that sets the log level for the component.
            </summary>
        </member>
        <member name="F:Syn.Speech.Util.Props.ConfigurationManagerUtils.CMFileSuffix">
            <summary>
            The default file suffix of configuration files.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManagerUtils.#ctor">
            <summary>
            disabled constructor because the class is just a collection of utilities for handling system configurations
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManagerUtils.ValidateConfiguration(Syn.Speech.Util.Props.ConfigurationManager)">
            <summary>
            Validates that only annotated property names have been used to setup this instance of {@code
            util.props.ConfigurationManager}
            </summary>
            <param name="cm"></param>
            <returns>{@code true} if it is a valid configuration.</returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManagerUtils.StripGlobalSymbol(System.String)">
            <summary>
            Strips the ${ and } off of a global symbol of the form ${symbol}.
            </summary>
            <param name="symbol"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManagerUtils.GetLogPrefix(Syn.Speech.Util.Props.ConfigurationManager)">
            <summary>
            the replacement of xml/sxl suffix is not necessary and just done to improve readability
            </summary>
            <param name="cm"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManagerUtils.ShowConfig(Syn.Speech.Util.Props.ConfigurationManager)">
            <summary>
             Shows the current configuration
            </summary>
            <param name="cm">The cm.</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManagerUtils.ShowConfig(Syn.Speech.Util.Props.ConfigurationManager,System.String)">
            <summary>
            Show the configuration for the component with the given name.
            </summary>
            <param name="cm">The Configuration Manager.</param>
            <param name="name">The component name.</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManagerUtils.ApplySystemProperties(System.Collections.Generic.Dictionary{System.String,Syn.Speech.Util.Props.RawPropertyData},System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Applies the system properties to the raw property map. System properties should be of the form
            compName[paramName]=paramValue
            </summary>
            <param name="rawMap"></param>
            <param name="global"></param>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManagerUtils.GetResource(System.String,Syn.Speech.Util.Props.PropertySheet,System.Boolean)">
            <summary>
            Gets a resource associated with the given parameter name given an property sheet.
            </summary>
            <param name="name">The parameter name.</param>
            <param name="ps">The property sheet which contains the property.</param>
            <param name="fillWithLocalPath">if set to <c>true</c> [fill with local path].</param>
            <returns>The resource associated with the name or NULL if it doesn't exist.</returns>//TODO: CHANGE TO RETURN URL TYPE
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManagerUtils.GetPropertyManager(Syn.Speech.Util.Props.PropertySheet)">
            <summary>
            Why do we need this method? The reason is, that we would like to avoid this method to be part of the
            <code>PropertySheet</code>-API. In some circumstances it is nevertheless required to get access to the managing
            <code>ConfigurationManager</code>.
            </summary>
            <param name="ps">The ps.</param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManagerUtils.IsDerivedClass(System.Type,System.Type)">
            <summary>
             <code>true</code> if <code>aClass</code> is either equal to <code>poosibleParent</code>, 
            a subclass of it, or implements it if <code>possibleParent</code> is an interface.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Props.ConfigurationManagerUtils.ToXML(Syn.Speech.Util.Props.ConfigurationManager)">
             <summary>
             Converts a configuration manager instance into a xml-string .
             </summary>
             <param name="cm">The cm.</param>
            <remarks>This methods will not instantiate configurables.</remarks>
        </member>
        <member name="T:Syn.Speech.Util.Props.IConfigurationChangeListener">
            <summary>
            Describes all methods necessary to process change events of a <code>ConfigurationManager</code>.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Props.IConfigurationChangeListener.ConfigurationChanged(System.String,System.String,Syn.Speech.Util.Props.ConfigurationManager)">
            <summary>
            Called if the configuration of a registered compoenent named <code>configurableName</code> was changed.
            </summary>
            <param name="configurableName">The name of the changed configurable.</param>
            <param name="propertyName">The name of the property which was changed</param>
            <param name="cm">The <code>ConfigurationManager</code>-instance this component is registered to</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.IConfigurationChangeListener.ComponentAdded(Syn.Speech.Util.Props.ConfigurationManager,Syn.Speech.Util.Props.PropertySheet)">
            <summary>
            Called if a new compoenent defined by <code>ps</code> was registered to the ConfigurationManager
            <code>cm</code>.
            </summary>
            <param name="cm"></param>
            <param name="ps"></param>
        </member>
        <member name="M:Syn.Speech.Util.Props.IConfigurationChangeListener.ComponentRemoved(Syn.Speech.Util.Props.ConfigurationManager,Syn.Speech.Util.Props.PropertySheet)">
            <summary>
            Called if a compoenent defined by <code>ps</code> was unregistered (removed) from the ConfigurationManager
            <code>cm</code>.
            </summary>
            <param name="cm"></param>
            <param name="ps"></param>
        </member>
        <member name="M:Syn.Speech.Util.Props.IConfigurationChangeListener.ComponentRenamed(Syn.Speech.Util.Props.ConfigurationManager,Syn.Speech.Util.Props.PropertySheet,System.String)">
            <summary>
            Called if a compoenent was renamed.
            </summary>
            <param name="cm"></param>
            <param name="ps"></param>
            <param name="oldName"></param>
        </member>
        <member name="T:Syn.Speech.Util.Props.InternalConfigurationException">
             <summary>
             ndicates that a problem occurred while setting one or more properties for this component. This includes errors as
             improper type for component(-lists) properties, out-of-range-problems for double-, int- and ranged string-properties,
             instantiation errors and undefined mandatory properties.
             
             This exception is instantiable only by the configuration management classes itself. In order to indicate problems
             within Configurable.newProperties which are not coped by types or ranges (eg file-not-found, complex configuration
             logic problems, etc.) <code>PropertyException</code> (which superclasses this class) can be used.
            
             The intention of the class is to make a clear distinction between core configuration errors and high level user
             specific problems.
             </summary>
             @SuppressWarnings("serial")
        </member>
        <member name="T:Syn.Speech.Util.Props.PropertyException">
            <summary>
            Indicates that a problem occurred while setting one or more properties for this component
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertyException.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new property exception.
            </summary>
            <param name="instanceName">The component this exception is related to.  (or <code>null</code> if unknown)</param>
            <param name="propertyName">The name of the component-property which the problem is related. (or <code>null</code> if unknown)</param>
            <param name="msg">a description of the problem.</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertyException.#ctor(System.Exception,System.String,System.String,System.String)">
            <summary>
            Creates a new property exception.
            </summary>
            <param name="cause">The cause of exception. (or <code>null</code> if unknown)</param>
            <param name="instanceName">The component this exception is related to.  (or <code>null</code> if unknown)</param>
            <param name="propertyName">The name of the component-property which the problem is related. (or <code>null</code> if unknown)</param>
            <param name="msg">a description of the problem.</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertyException.GetProperty">
            <summary>
            Retrieves the name of the offending property
            </summary>
            <returns>the name of the offending property</returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertyException.ToString">
            <summary>
            Returns a string representation of this object
            </summary>
            <returns>the string representation of the object.</returns>
        </member>
        <member name="T:Syn.Speech.Util.Props.PropertySheet">
            <summary>
            A property sheet which defines a collection of properties for a single component
            in the system.
            </summary>
        </member>
        <member name="F:Syn.Speech.Util.Props.PropertySheet._rawProps">
            <summary>
            Maps the names of the component properties to their (possibly unresolved) values.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.RegisterProperty(System.String,Syn.Speech.Util.Props.S4PropWrapper)">
            <summary>
            Registers a new property which type and default value are defined by the given sphincs property.
            </summary>
            <param name="propName">The name of the property to be registered.</param>
            <param name="property">The property annotation masked by a proxy.</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetProperty``1(System.String)">
            <summary>
            Returns the property names <code>name</code> which is still wrapped into the annotation instance.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetString(System.String)">
            <summary>
            Gets the value associated with this name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetInt(System.String)">
            <summary>
            Gets the value associated with this name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetFloat(System.String)">
            <summary>
            Gets the value associated with this name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetDouble(System.String)">
            <summary>
            Gets the value associated with this name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetBoolean(System.String)">
            <summary>
            Gets the value associated with this name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetComponent(System.String)">
            <summary>
            Gets a component associated with the given parameter name. First search
            the component in property table, then try to get component by name from
            the manager, then creates component with default properties.
            </summary>
            <param name="name">the parameter name</param>
            <returns>the component associated with the name</returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetComponentClass(System.String)">
            <summary>
            Returns the Type of of a registered component property without instantiating it.
            </summary>
            <param name="propName"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetstringList(System.String)">
            <summary>
            Gets a list of float numbers associated with the given parameter name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetComponentList``1(System.String)">
            <summary>
            Gets a list of components associated with the given parameter name
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">the parameter name</param>
            <returns>the component associated with the name</returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetResourceList(System.String)">
            <summary>
            arses the string with multiple URL's separated by ;. Return the list of
            resources to load
            </summary>
            <param name="name">list with URL's</param>
            <returns>ist of resources</returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetResourceStringList(System.String)">
            <summary>
            arses the string with multiple URL's separated by ;. Return the list of
            resources to load
            </summary>
            <param name="name">list with URL's</param>
            <returns>ist of resources</returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetOwner">
            <summary>
            Returns the owner of this property sheet. In most cases this will be the configurable instance which was
            instrumented by this property sheet.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetUndefinedMandatoryProps">
            <summary>
            Returns the set of all component properties which were tagged as mandatory but which are not set (or no default
            value is given).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetRegisteredProperties">
            <summary>
            Returns the names of registered properties of this PropertySheet object. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetConfigurableClass">
            <summary>
            Returns the class of the owner configurable of this property sheet.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.SetConfigurableClass(System.Type)">
            <summary>
            Sets the configurable class of this object.
            RuntimeException if the the <code>IConfigurable</code> is already instantiated.
            </summary>
            <param name="confClass"></param>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.ApplyConfigurationChange(System.String,System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="propName"></param>
            <param name="cmName"></param>
            <param name="value"></param>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.SetString(System.String,System.String)">
            <summary>
            Sets the given property to the given name
            </summary>
            <param name="name">the simple property name</param>
            <param name="value"></param>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.SetInt(System.String,System.Int32)">
            <summary>
            Sets the given property to the given name
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.SetDouble(System.String,System.Double)">
            <summary>
            Sets the given property to the given name
            </summary>
            <param name="name">the simple property name</param>
            <param name="value">the value for the property</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.SetBoolean(System.String,System.Boolean)">
            <summary>
            Sets the given property to the given name
            </summary>
            <param name="name">the simple property name</param>
            <param name="value">the value for the property</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.SetComponent(System.String,System.String,Syn.Speech.Util.Props.IConfigurable)">
            <summary>
            Sets the given property to the given name
            </summary>
            <param name="name">the simple property name</param>
            <param name="cmName">the name of the configurable within the configuration manager (required for serialization only)</param>
            <param name="value">the value for the property</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.SetComponentList(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Syn.Speech.Util.Props.IConfigurable})">
            <summary>
            Sets the given property to the given name
            </summary>
            <param name="name">the simple property name</param>
            <param name="valueNames">the list of names of the configurables within the configuration manager (required for
                              serialization only)</param>
            <param name="value">the value for the property</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.SetRaw(System.String,System.Object)">
            <summary>
            Sets the raw property to the given name
            </summary>
            <param name="key">the simple property name</param>
            <param name="val">the value for the property</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetRaw(System.String)">
            <summary>
            Gets the raw value associated with this name
            </summary>
            <param name="name"> name the name</param>
            <returns>the value as an object (it could be a string or a string[] depending upon the property type)</returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetRawNoReplacement(System.String)">
            <summary>
            Gets the raw value associated with this name, no global symbol replacement is performed.
            </summary>
            <param name="name">the name</param>
            <returns>the value as an object (it could be a string or a string[] depending upon the property type)</returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetType(System.String)">
            <summary>
            Returns the type of the given property.
            </summary>
            <param name="propName"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.GetPropertyManager">
            <summary>
            Gets the owning property manager
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.Equals(System.Object)">
            <summary>
            Returns true if two property sheet define the same object in terms of configuration. The owner (and the parent
            configuration manager) are not expected to be the same.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.PropertySheet.Validate">
            <summary>
            Validates a configuration, by ensuring that only valid property-names have been used to configure the component.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Syn.Speech.Util.Props.RawPropertyData">
            <summary>
            Holds the raw property data just as it has come in from the properties file.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Props.RawPropertyData.#ctor(System.String,System.String)">
            <summary>
            Creates a raw property data item.
            </summary>
            <param name="name">the name of the item</param>
            <param name="className">the class name of the item</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.RawPropertyData.#ctor(System.String,System.String,Syn.Speech.Helper.HashMap{System.String,System.Object})">
            <summary>
            Creates a raw property data item, using a given property map.
            </summary>
            <param name="name">the name of the item</param>
            <param name="className">the class name of the item</param>
            <param name="properties">existing property map to use</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.RawPropertyData.Add(System.String,System.String)">
            <summary>
            Adds a new property with a {@code String} value.
            </summary>
            <param name="propName">the name of the property</param>
            <param name="propValue">the value of the property</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.RawPropertyData.Add(System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Adds a new property with a List of string value.
            </summary>
            <param name="propName"></param>
            <param name="propValue"></param>
        </member>
        <member name="M:Syn.Speech.Util.Props.RawPropertyData.Remove(System.String)">
            <summary>
            Removes an existing property.
            </summary>
            <param name="propName">the name of the property</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.RawPropertyData.GetProperties">
            <summary>
            Returns the properties.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.RawPropertyData.Contains(System.String)">
            <summary>
            Determines if the map already contains an entry for a property.
            </summary>
            <param name="propName">the property of interest</param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.RawPropertyData.Flatten(Syn.Speech.Util.Props.ConfigurationManager)">
            <summary>
            Returns a copy of this property data instance with all ${}-fields resolved.
            </summary>
            <param name="cm"></param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.RawPropertyData.GetGlobalProperty(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Lookup a global symbol with a given name (and resolves)
            </summary>
            <param name="key">the name of the property</param>
            <param name="globalProperties"></param>
            <returns>the property value or null if it doesn't exist.</returns>
        </member>
        <member name="M:Syn.Speech.Util.Props.RawPropertyData.ToString">
            <summary>
             Provide information stored inside this Object, used mainly for debugging/testing.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Syn.Speech.Util.Props.RawPropertyData.ClassName">
            <summary>
            Returns the className.
            </summary>
            <value></value>
        </member>
        <member name="P:Syn.Speech.Util.Props.RawPropertyData.Name">
            <summary>
            Returns the name.
            </summary>
            <value></value>
        </member>
        <member name="T:Syn.Speech.Util.Props.S4Boolean">
            <summary>
            A logical property.
            </summary>
        </member>
        <member name="T:Syn.Speech.Util.Props.S4Component">
             <summary>
             A component property.
             </summary>
            
        </member>
        <member name="T:Syn.Speech.Util.Props.S4ComponentList">
            <summary>
            A list property.
            </summary>
        </member>
        <member name="T:Syn.Speech.Util.Props.S4Double">
            <summary>
            A double property.
            </summary>
        </member>
        <member name="F:Syn.Speech.Util.Props.S4Double.NotDefined">
            <summary>
            Default value to return
            </summary>
        </member>
        <member name="T:Syn.Speech.Util.Props.S4Integer">
            <summary>
            An integer property.
            </summary>
        </member>
        <member name="F:Syn.Speech.Util.Props.S4Integer.NotDefined">
            <summary>
            Default value to return
            </summary>
        </member>
        <member name="T:Syn.Speech.Util.Props.S4Property">
            <summary>
            A tag which superclasses all sphinx property annotations. Because there is no real inheritance for annotations all
            child classes are annotated by this general property annotation.
            @author Holger Brandl
            </summary>
        </member>
        <member name="T:Syn.Speech.Util.Props.S4PropWrapper">
            <summary>
            Wraps annotations
            </summary>
        </member>
        <member name="T:Syn.Speech.Util.Props.S4String">
            <summary>
            A string property.
            @author Holger Brandl
            </summary>
        </member>
        <member name="F:Syn.Speech.Util.Props.S4String.NotDefined">
            <summary>
            Default value to return
            </summary>
        </member>
        <member name="T:Syn.Speech.Util.Props.S4StringList">
            <summary>
            A List containing float numbers.
            </summary>
        </member>
        <member name="T:Syn.Speech.Util.Props.SaxLoader">
            <summary>
            Loads configuration from an XML file
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Props.SaxLoader.#ctor(Syn.Speech.Helper.URL,Syn.Speech.Helper.HashMap{System.String,System.String},Syn.Speech.Helper.HashMap{System.String,Syn.Speech.Util.Props.RawPropertyData},System.Boolean)">
            <summary>
            Creates a loader that will load from the given location 
            </summary>
            <param name="url">the location to load</param>
            <param name="globalProperties">the map of global properties</param>
            <param name="initRPD"></param>
            <param name="replaceDuplicates"></param>
        </member>
        <member name="M:Syn.Speech.Util.Props.SaxLoader.#ctor(Syn.Speech.Helper.URL,Syn.Speech.Helper.HashMap{System.String,System.String})">
            <summary>
            Creates a loader that will load from the given location 
            </summary>
            <param name="url">the location to load</param>
            <param name="globalProperties">the map of global properties</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.SaxLoader.Load">
            <summary>
            Loads a set of configuration data from the location 
            </summary>
            <returns>A map keyed by component name containing RawPropertyData objects.</returns>
        </member>
        <member name="T:Syn.Speech.Util.Props.Tools.GDLDumper">
            <summary>
            Dumps a given configuration manager as GDL.
            @author Holger Brandl
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Props.Tools.GDLDumper.DumpComponentAsGDL(Syn.Speech.Util.Props.ConfigurationManager,System.IO.StreamWriter,System.String)">
            <summary>
            Dumps the given component as GDL to the given stream.
            </summary>
            <param name="cm">The cm.</param>
            <param name="out">Where to dump the GDL.</param>
            <param name="name">The name of the component to dump.</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.Tools.GDLDumper.ShowConfigAsGDL(Syn.Speech.Util.Props.ConfigurationManager,System.String)">
            <summary>
            Dumps the config as a GDL plot.
            </summary>
            <param name="configurationManager">The configuration manager.</param>
            <param name="path">Where to output the GDL.</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.Tools.GDLDumper.DumpGDLHeader(System.IO.StreamWriter)">
            <summary>
            Outputs the GDL header
            </summary>
            <param name="streamWriter">The output stream.</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.Tools.GDLDumper.GetColor(Syn.Speech.Util.Props.ConfigurationManager,System.String)">
             Gets the color for the given component
            
             @param ConfigurationManager
             @param componentName        the name of the component @return the color name for the component
        </member>
        <member name="M:Syn.Speech.Util.Props.Tools.GDLDumper.DumpGDLFooter(System.IO.StreamWriter)">
            <summary>
            Dumps the footer for GDL output.
            </summary>
            <param name="streamWriter">The output stream.</param>
        </member>
        <member name="T:Syn.Speech.Util.Props.Tools.HTMLDumper">
            <summary>
            Dumps a given configuration manager to HTML.
            @author Holger Brandl
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Props.Tools.HTMLDumper.ShowConfigAsHTML(Syn.Speech.Util.Props.ConfigurationManager,System.String)">
            <summary>
            Dumps the config as a set of HTML tables.
            </summary>
            <param name="configurationManager">The configuration manager.</param>
            <param name="path">where to output the HTML.</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.Tools.HTMLDumper.DumpFooter(System.IO.StreamWriter)">
            <summary>
            Dumps the footer for HTML output.
            </summary>
            <param name="streamWriter">The output stream.</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.Tools.HTMLDumper.DumpHeader(System.IO.StreamWriter)">
            <summary>
            Dumps the header for HTML output.
            </summary>
            <param name="streamWriter">The output stream.</param>
        </member>
        <member name="M:Syn.Speech.Util.Props.Tools.HTMLDumper.DumpComponentAsHTML(System.IO.StreamWriter,System.String,Syn.Speech.Util.Props.PropertySheet)">
            <summary>
            Dumps the given component as HTML to the given stream.
            </summary>
            <param name="streamWriter">Where to dump the HTML.</param>
            <param name="name">The name of the component to dump.</param>
            <param name="properties">The properties.</param>
        </member>
        <member name="T:Syn.Speech.Util.SimpleBatchManager">
            <summary>
            A simple implementation of the batch manager suitable for single threaded batch processing 
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.SimpleBatchManager.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
                    /// Constructs a SimpleBatchManager object.
                     *
                    /// @param filename     the name of the batch file
                    /// @param skip         number of records to skip between items
                    /// @param whichBatch   which chunk of the batch should we process
                    /// @param totalBatches the total number of chuncks that the batch is divided into.
        </member>
        <member name="M:Syn.Speech.Util.SimpleBatchManager.Start">
            Starts processing the batch 
        </member>
        <member name="M:Syn.Speech.Util.SimpleBatchManager.GetNextItem">
                    /// Gets the next available batch item or null if no more are available
                     *
                    /// @return the next available batch item
                    /// @throws IOException if an I/O error occurs while getting the next item from the batch file.
        </member>
        <member name="M:Syn.Speech.Util.SimpleBatchManager.Stop">
            Stops processing the batch 
        </member>
        <member name="M:Syn.Speech.Util.SimpleBatchManager.GetBatchItems(System.String)">
                    /// Gets the set of lines from the file
                     *
                    /// @param file the name of the file
        </member>
        <member name="P:Syn.Speech.Util.SimpleBatchManager.Filename">
                    /// Returns the name of the file
                     *
                    /// @return the filename
        </member>
        <member name="T:Syn.Speech.Util.StatisticsVariable">
            <summary>
            Represents a named value. A StatisticsVariable may be used to track data in a fashion that will allow the data to be
            viewed or dumped at any time.  Statistics are kept in a pool and are grouped in contexts. Statistics can be dumped
            as a whole or by context.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.StatisticsVariable.GetStatisticsVariable(System.String)">
            <summary>
            Gets the StatisticsVariable with the given name from the given context. If the statistic does not currently
            exist, it is created. If the context does not currently exist, it is created. 
            </summary>
            <param name="statName">the name of the StatisticsVariable</param>
            <returns>the StatisticsVariable with the given name and context</returns>
        </member>
        <member name="M:Syn.Speech.Util.StatisticsVariable.GetStatisticsVariable(System.String,System.String)">
            <summary>
             Gets the StatisticsVariable with the given name for the given instance and context. This is a convenience function.
            </summary>
            <param name="instanceName">The instance name of creator.</param>
            <param name="statName">Name of the StatisticsVariable.</param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.StatisticsVariable.DumpAll">
            <summary>
            Dump all of the StatisticsVariable in the given context.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.StatisticsVariable.ResetAll">
            <summary>
             Resets all of the StatisticsVariables in the given context.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.StatisticsVariable.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Syn.Speech.Util.StatisticsVariable"/> class.
            </summary>
            <param name="statName">Name  of this StatisticsVariable.</param>
        </member>
        <member name="M:Syn.Speech.Util.StatisticsVariable.Reset">
            <summary>
            Resets this StatisticsVariable. The value is set to zero.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.StatisticsVariable.Dump">
            <summary>
            Dumps this StatisticsVariable.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.StatisticsVariable.Main(System.String[])">
            <summary>
            Some simple tests for the StatisticsVariable
            </summary>
            <param name="args"></param>
        </member>
        <member name="P:Syn.Speech.Util.StatisticsVariable.Name">
            <summary>
             Retrieves the name of this StatisticsVariable.
            </summary>
            <value>
            The name of this StatisticsVariable.
            </value>
        </member>
        <member name="P:Syn.Speech.Util.StatisticsVariable.Value">
            <summary>
            Retrieves the value for this StatisticsVariable.
            </summary>
            <value>
            The current value for this StatisticsVariable.
            </value>
        </member>
        <member name="P:Syn.Speech.Util.StatisticsVariable.IsEnabled">
            <summary>
            Gets a value indicating whether this instance is enabled.
            </summary>
            <value>
            <c>true</c> if this instance is enabled; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Syn.Speech.Util.StatisticsVariable.Enabled">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Syn.Speech.Util.StatisticsVariable"/> is enabled.
            </summary>
            <value>
              <c>true</c> if enabled; otherwise, <c>false</c>.
            </value>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Syn.Speech.Helper.StreamTokenizer" -->
        <member name="F:Syn.Speech.Helper.StreamTokenizer.TtEOF">
                    /// A constant indicating that the end of the stream has been Read.
        </member>
        <member name="F:Syn.Speech.Helper.StreamTokenizer.TtEol">
                    /// A constant indicating that the end of the line has been Read.
        </member>
        <member name="F:Syn.Speech.Helper.StreamTokenizer.TtNumber">
                    /// A constant indicating that a number token has been Read.
        </member>
        <member name="F:Syn.Speech.Helper.StreamTokenizer.TtWord">
                    /// A constant indicating that a word token has been Read.
        </member>
        <member name="F:Syn.Speech.Helper.StreamTokenizer._peekc">
                    /// The next character to be considered by the nextToken method.  May also
                    /// be NEED_CHAR to indicate that a new character should be Read, or SKIP_LF
                    /// to indicate that a new character should be Read and, if it is a '\n'
                    /// character, it should be discarded and a second new character should be
                    /// Read.
        </member>
        <member name="F:Syn.Speech.Helper.StreamTokenizer._eolIsSignificantP">
            The line number of the last token Read 
        </member>
        <!-- Badly formed XML comment ignored for member "F:Syn.Speech.Helper.StreamTokenizer.Ttype" -->
        <member name="M:Syn.Speech.Helper.StreamTokenizer.#ctor">
            Private constructor that initializes everything except the streams. 
        </member>
        <member name="M:Syn.Speech.Helper.StreamTokenizer.#ctor(System.IO.StreamReader)">
                    /// Create a tokenizer that parses the given character stream.
                     *
                    /// @param r  a Reader object providing the input stream.
        </member>
        <member name="M:Syn.Speech.Helper.StreamTokenizer.ResetSyntax">
                    /// Resets this tokenizer's syntax table so that all characters are
                    /// "ordinary." See the <code>ordinaryChar</code> method
                    /// for more information on a character being ordinary.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.StreamTokenizer.WordChars(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.StreamTokenizer.WhitespaceChars(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.StreamTokenizer.OrdinaryChars(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.StreamTokenizer.OrdinaryChar(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.StreamTokenizer.CommentChar(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.StreamTokenizer.QuoteChar(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.StreamTokenizer.ParseNumbers" -->
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.StreamTokenizer.EolIsSignificant(System.Boolean)" -->
        <member name="M:Syn.Speech.Helper.StreamTokenizer.Read">
            Read the next character 
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.StreamTokenizer.NextToken" -->
        <member name="M:Syn.Speech.Helper.StreamTokenizer.PushBack">
                    /// Causes the next call to the <code>nextToken</code> method of this
                    /// tokenizer to return the current value in the <code>ttype</code>
                    /// field, and not to modify the value in the <code>nval</code> or
                    /// <code>sval</code> field.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Helper.StreamTokenizer.ToString" -->
        <!-- Badly formed XML comment ignored for member "P:Syn.Speech.Helper.StreamTokenizer.StringValue" -->
        <!-- Badly formed XML comment ignored for member "P:Syn.Speech.Helper.StreamTokenizer.NumberValue" -->
        <!-- Badly formed XML comment ignored for member "P:Syn.Speech.Helper.StreamTokenizer.SlashStarComments" -->
        <!-- Badly formed XML comment ignored for member "P:Syn.Speech.Helper.StreamTokenizer.SlashSlashComments" -->
        <!-- Badly formed XML comment ignored for member "P:Syn.Speech.Helper.StreamTokenizer.LowerCaseMode" -->
        <member name="T:Util.Strings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Util.Strings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Util.Strings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Util.Strings.MANDATORY_PROPERTY_NOT_DEFINED">
            <summary>
              Looks up a localized string similar to not all mandatory properties are defined.
            </summary>
        </member>
        <member name="P:Util.Strings.MANDATORY_PROPERTY_NOT_SET">
            <summary>
              Looks up a localized string similar to mandatory property is not set!.
            </summary>
        </member>
        <member name="T:Syn.Speech.Util.Timer">
            <summary>
            Keeps track of execution times. This class provides methods that can be used for timing processes. The process to be
            timed should be bracketed by calls to timer.start() and timer.stop().  Repeated operations can be timed more than
            once. The timer will report the minimum, maximum, average and last time executed for all start/stop pairs when the
            timer.dump is called.
            Timer instances can be obtained from a global cache implemented in {@code TimerPool}.
            </summary>
            <see cref="T:Syn.Speech.Util.TimerPool"/>
        </member>
        <member name="M:Syn.Speech.Util.Timer.#ctor(System.String)">
            <summary>
            Creates a timer.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Syn.Speech.Util.Timer.GetName">
            <summary>
            Retrieves the name of the timer
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Timer.Reset">
            <summary>
            Resets the timer as if it has never run before.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Timer.IsStarted">
            <summary>
            Returns true if the timer has started.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.Timer.Start">
            <summary>
            Starts the timer running. 
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Timer.Start(System.Int64)">
            <summary>
            Starts the timer at the given time.
            </summary>
            <param name="time"></param>
        </member>
        <member name="M:Syn.Speech.Util.Timer.Stop">
            <summary>
            Stops the timer.
            </summary>
            <returns>the duration since start in milliseconds</returns>
        </member>
        <member name="M:Syn.Speech.Util.Timer.Dump">
            <summary>
            Dump the timer. Shows the timer details.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Timer.GetAverageTime">
                    /// Gets the average time for this timer in milliseconds
                     *
                    /// @return the average time
        </member>
        <member name="M:Syn.Speech.Util.Timer.FmtTime(System.Double)">
            <summary>
            Formats times into a standard format.
            </summary>
            <param name="time">The time (in seconds) to be formatted.</param>
            <returns>A string representation of the time.</returns>
        </member>
        <member name="M:Syn.Speech.Util.Timer.ShowTimesShort">
            <summary>
             Shows brief timing statistics.
            </summary>
        </member>
        <member name="P:Syn.Speech.Util.Timer.Count">
                    /// Gets the count of starts for this timer
                     *
                    /// @return the count
        </member>
        <member name="P:Syn.Speech.Util.Timer.CurTime">
                    /// Returns the latest time gathered
                     *
                    /// @return the time in milliseconds
        </member>
        <member name="P:Syn.Speech.Util.Timer.MinTime">
            <summary>
            Gets the min time for this timer in milliseconds.
            </summary>
            <value>
            The min time
            </value>
        </member>
        <member name="P:Syn.Speech.Util.Timer.MaxTime">
            <summary>
            Gets the max time for this timer in milliseconds.
            </summary>
            <value>
            The max time in milliseconds.
            </value>
        </member>
        <member name="T:Syn.Speech.Util.TimerPool">
            <summary>
            Keeps references to a list of timers which can be referenced by a key-pair consisting of an owner and a timer name.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.TimerPool.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:Syn.Speech.Util.TimerPool"/> class from being created.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.TimerPool.GetTimer(System.Object,System.String)">
            <summary>
            Retrieves (or creates) a timer with the given name
            </summary>
            <param name="owner">The owner.</param>
            <param name="timerName">The name of the particular timer to retrieve. If the timer does not already exist, it will be created  @return the timer.</param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Util.TimerPool.GetNumCachedTimers">
            <summary>
            Returns the number of currently caches {@code Timer} instances.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.TimerPool.DumpAll">
            <summary>
            Dump all timers.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.TimerPool.ShowTimesShortTitle">
            <summary>
            Shows the timing stats title.
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.TimerPool.ResetAll">
            <summary>
            Resets all timers.
            </summary>
        </member>
        <member name="T:Syn.Speech.Util.Utilities">
            <summary>
            Provides a set of generic utilities
            </summary>
        </member>
        <member name="M:Syn.Speech.Util.Utilities.Pad(System.Int32)">
                    /// Returns a string with the given number of spaces.
                     *
                    /// @param padding the number of spaces in the string
                    /// @return a string of length 'padding' containing only the SPACE char.
        </member>
        <member name="M:Syn.Speech.Util.Utilities.Pad(System.String,System.Int32)">
                    /// Pads with spaces or truncates the given string to guarantee that it is exactly the desired length.
                     *
                    /// @param string    the string to be padded
                    /// @param minLength the desired length of the string
                    /// @return a string of length containing string padded with whitespace or truncated
        </member>
        <member name="M:Syn.Speech.Util.Utilities.Pad(System.Int32,System.Int32)">
                    /// Pads with spaces or truncates the given int to guarantee that it is exactly the desired length.
                     *
                    /// @param val       the value to be padded
                    /// @param minLength the desired length of the string
                    /// @return a string of length containing string padded with whitespace or truncated
        </member>
        <member name="M:Syn.Speech.Util.Utilities.Pad(System.Double,System.Int32)">
                    /// Pads with spaces or truncates the given double to guarantee that it is exactly the desired length.
                     *
                    /// @param val       the value to be padded
                    /// @param minLength the desired length of the string
                    /// @return a string of length containing string padded with whitespace or truncated
        </member>
        <member name="M:Syn.Speech.Util.Utilities.Dump(System.Int32,System.String)">
                    /// Dumps padded text. This is a simple tool for helping dump text with padding to a Writer.
                     *
                    /// @param pw      the stream to send the output
                    /// @param padding the number of spaces in the string
                    /// @param string  the string to output
        </member>
        <member name="M:Syn.Speech.Util.Utilities.ObjectTracker(System.String,System.Int32)">
                    /// utility method for tracking object counts
                     *
                    /// @param name  the name of the object
                    /// @param count the count of objects
        </member>
        <member name="M:Syn.Speech.Util.Utilities.DumpMemoryInfo(System.String)">
                    /// Dumps  out memory information
                     *
                    /// @param msg addditional text for the dump
        </member>
        <member name="M:Syn.Speech.Util.Utilities.DoubleToScientificString(System.Double,System.Int32)">
                    /// Returns the string representation of the given double value in normalized scientific notation. The
                    /// <code>fractionDigits</code> argument gives the number of decimal digits in the fraction portion. For example, if
                    /// <code>fractionDigits</code> is 4, then the 123450 will be "1.2345e+05". There will always be two digits in the
                    /// exponent portion, and a plus or minus sign before the exponent.
                     *
                    /// @param number         the double to convert
                    /// @param fractionDigits the number of digits in the fraction part, e.g., 4 in "1.2345e+05".
                    /// @return the string representation of the double in scientific notation
        </member>
        <member name="M:Syn.Speech.Util.Utilities.ReadLittleEndianFloat(System.IO.Stream)">
                    /// Reads the next float from the given DataInputStream, where the data is in little endian.
                     *
                    /// @param dataStream the DataInputStream to read from
                    /// @return a float
        </member>
        <member name="M:Syn.Speech.Util.Utilities.ReadLittleEndianInt(System.IO.Stream)">
                    /// Reads the next little-endian integer from the given DataInputStream.
                     *
                    /// @param dataStream the DataInputStream to read from
                    /// @return an integer
        </member>
        <member name="M:Syn.Speech.Util.Utilities.SwapInteger(System.Int32)">
                    /// Byte-swaps the given integer to the other endian. That is, if this integer is big-endian, it becomes
                    /// little-endian, and vice-versa.
                     *
                    /// @param integer the integer to swap
        </member>
        <member name="M:Syn.Speech.Util.Utilities.floorData(System.Single[],System.Single)">
                    /// If a data point is below 'floor' make it equal to floor.
                     *
                    /// @param data  the data to floor
                    /// @param floor the floored value
        </member>
        <member name="M:Syn.Speech.Util.Utilities.NonZeroFloor(System.Single[],System.Single)">
                    /// If a data point is non-zero and below 'floor' make it equal to floor
                    /// (don't floor zero values though).
                    /// 
                    /// @param data the data to floor
                    /// @param floor the floored value
        </member>
        <member name="M:Syn.Speech.Util.Utilities.Normalize(System.Single[])">
                    /// Normalize the given data.
                    /// 
                    /// @param data the data to normalize
        </member>
        <member name="T:Syn.Speech.Wave.WaveFile">
            <summary>
            WAV file class: Allows manipulation of WAV audio files
            </summary>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.#cctor">
            <summary>
            WAVFile class: Static constructor
            </summary>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.#ctor">
            <summary>
            WAVFile class: Default constructor
            </summary>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.Finalize">
            <summary>
            Destructor - Makes sure the file is closed.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Syn.Speech.Wave.WaveFile.Open(System.String,Syn.Speech.Wave.WaveFile.WavFileMode)" -->
        <member name="M:Syn.Speech.Wave.WaveFile.Open(Syn.Speech.Wave.WaveFile.WavFileMode)">
            <summary>
            Opens the file specified by mFilename and reads the file header and audio information.  Does not read any of the audio data.
            </summary>
            /// <param name="pMode">The file opening mode.  Only READ and READ_WRITE are valid.  If you want to write only, then use Create().</param>
            <returns>A blank string on success, or a message on failure.</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.Close">
            <summary>
            Closes the file
            </summary>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.GetNextSample_ByteArray">
            <summary>
            When in read mode, returns the next audio sample from the
            file.  The return value is a byte array and will contain one
            byte if the file contains 8-bit audio or 2 bytes if the file
            contains  16-bit audio.  The return value will be null if no
            next sample can be read.  For 16-bit samples, the byte array
            can be converted to a 16-bit integer using BitConverter.ToInt16().
            If there is an error, this method will throw a WAVFileReadException.
            </summary>
            <returns>A byte array containing the audio sample</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.GetNextSample_8bit">
            <summary>
            When in read mode, returns the next audio sample from the loaded audio
            file.  This is a convenience method that can be used when it is known
            that the audio file contains 8-bit audio.  If the audio file is not
            8-bit, this method will throw a WAVFileReadException. 
            </summary>
            <returns>The next audio sample from the loaded audio file.</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.GetNextSample_16bit">
            <summary>
            When in read mode, returns the next audio sample from the loaded audio
            file.  This is a convenience method that can be used when it is known
            that the audio file contains 16-bit audio.  If the audio file is not
            16-bit, this method will throw a WAVFileReadException. 
            </summary>
            <returns>The next audio sample from the loaded audio file.</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.GetNextSampleAs16Bit">
            <summary>
            When in read mode, returns the next audio sample from the loaded audio
            file.  This returns the value as a 16-bit value regardless of whether the
            audio file is 8-bit or 16-bit.  If the audio is 8-bit, then the 8-bit sample
            value will be scaled to a 16-bit value.
            </summary>
            <returns>The next audio sample from the loaded audio file, as a 16-bit value, scaled if necessary.</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.GetNextSampleAs8Bit">
            <summary>
            When in read mode, returns the next audio sample from the loaded audio
            file.  This returns the value as an 8-bit value regardless of whether the
            audio file is 8-bit or 16-bit.  If the audio is 16-bit, then the 16-bit sample
            value will be scaled to an 8-bit value.
            </summary>
            <returns>The next audio sample from the loaded audio file, as an 8-bit value, scaled if necessary.</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.AddSample_ByteArray(System.Byte[])">
            <summary>
            When in write mode, adds a new sample to the audio file.  Takes
            an array of bytes representing the sample.  The array should
            contain the correct number of bytes to match the sample size.
            If there are any errors, this method will throw a WAVFileWriteException.
            </summary>
            <param name="pSample">An array of bytes representing the audio sample</param>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.AddSample_8bit(System.Byte)">
            <summary>
            When in write mode, adds an 8-bit sample to the audio file.
            Takes a byte containing the sample.  If the audio file is
            not 8-bit, this method will throw a WAVFileWriteException.
            </summary>
            <param name="pSample">The audio sample to add</param>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.AddSample_16bit(System.Int16)">
            <summary>
            When in write mode, adds a 16-bit sample to the audio file.
            Takes an Int16 containing the sample.  If the audio file is
            not 16-bit, this method will throw a WAVFileWriteException.
            </summary>
            <param name="pSample">The audio sample to add</param>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.Create(System.String,System.Boolean,System.Int32,System.Int16,System.Boolean)">
            <summary>
            Creates a new WAV audio file.
            </summary>
            <param name="pFilename">The name of the audio file to create</param>
            <param name="pStereo">Whether or not the audio file should be stereo (if this is false, the audio file will be mono).</param>
            <param name="pSampleRate">The sample rate of the audio file (in Hz)</param>
            <param name="pBitsPerSample">The number of bits per sample (8 or 16)</param>
            <param name="pOverwrite">Whether or not to overwrite the file if it exists.  If this is false, then a System.IO.IOException will be thrown if the file exists.</param>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.Create(System.String,System.Boolean,System.Int32,System.Int16)">
            <summary>
            Creates a new WAV audio file.  This is an overload that always overwrites the file if it exists.
            </summary>
            <param name="pFilename">The name of the audio file to create</param>
            <param name="pStereo">Whether or not the audio file should be stereo (if this is false, the audio file will be mono).</param>
            <param name="pSampleRate">The sample rate of the audio file (in Hz)</param>
            <param name="pBitsPerSample">The number of bits per sample (8 or 16)</param>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.FormatMatches(Syn.Speech.Wave.WaveFile)">
            <summary>
            Returns whether or not the WAV file format (mono/stereo,
            sample rate, and bits per sampe) match another WAV file's
            format.
            </summary>
            <param name="pWaveFile">Another WAVFile object to compare with</param>
            <returns></returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.GetAudioFormat(System.String)">
            <summary>
            Returns a WAVFormat struct containing audio format information
            (# channels, sample rate, and bits per sample) for a WAV file.
            </summary>
            <param name="pFilename">The name of the file about which to retrieve format information</param>
            <returns>A WAVFormat struct object containing the audio format information for the open file</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.IsWaveFile(System.String)">
            <summary>
            Returns whether or not a file is a WAV audio file.
            </summary>
            <param name="pFilename">The name of the file to check</param>
            <returns>true if the file is a wave audio file, or false if not</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.HighestSampleValue(System.String,System.Int16@)">
            <summary>
            Returns the highest sample value in a WAV audio file.
            The return value is a byte array and will contain one
            byte if the file contains 8-bit audio or 2 bytes if the file
            contains  16-bit audio.  The return value will be null if
            the file cannot be opened.  If it is known that the audio
            file contains 16-bit samples, the byte array can be converted
            to a 16-bit integer using BitConverter.ToInt16().
            </summary>
            <param name="pFilename">The name of the WAV file</param>
            <param name="pBitsPerSample">This will contain the number of bits per sample, or 0 if the file wasn't loaded.</param>
            <returns>A byte array containing the highest audio sample, or null if the file wasn't loaded.</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.HighestSampleValue_8bit(System.String)">
            <summary>
            Returns the highest sample value in a WAV audio file.  This is
            a convenience method that can be used when it is known that the
            audio file contains 8-bit audio.  If the audio file does not
            contain 8-bit audio, this will throw a WAVFileException.
            </summary>
            <param name="pFilename">The name of the WAV file</param>
            <returns>The highest audio sample from the file, or 0 if the file wasn't loaded.</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.HighestSampleValue_8bit(System.String[])">
            <summary>
            Returns the highest sample value from multiple audio files, when it is known that
            they contain 8-bit audio.
            </summary>
            <param name="pFilenames">An array containing the names of the files to check</param>
            <returns>The highest sample value of all the WAV files</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.HighestSampleValueAs16Bit(System.String)">
            <summary>
            Returns the highest sample value in a WAV file, as a 16-bit value, regardless of
            whether the file contains 8-bit or 16-bit audio.  If the sample is coming from
            an 8-bit audio file, the sample will be scaled up from 8-bit to 16-bit.
            </summary>
            <param name="pFilename">The audio file name</param>
            <returns>The highest sample value from the file, as a 16-bit value</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.HighestSampleValueAs16Bit(System.String[])">
            <summary>
            Returns the highest sample value in a set of WAV files, as a 16-bit value, regardless of
            whether the file contains 8-bit or 16-bit audio.
            </summary>
            <param name="pFilenames">An array containing the filenames</param>
            <returns>The highest sample value from the WAV files</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.HighestBitsPerSample(System.String[])">
            <summary>
            Returns the highest number of bits per sample in a set of audio files.
            </summary>
            <param name="pFilenames">An array containing the audio file names</param>
            <returns>The highest number of bits per sample in the set of audio files</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.HighestNumChannels(System.String[])">
            <summary>
            Returns the highest number of channels in a set of audio files.
            </summary>
            <param name="pFilenames">An array containing the audio file names</param>
            <returns>The highest number of channels in the set of audio files</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.AdjustVolume_Copy(System.String,System.String,System.Double)">
            <summary>
            Adjusts the volume level of a WAV file, saving the adjusted file as a separate file.
            </summary>
            <param name="pSrcFilename">The name of the WAV file to adjust</param>
            <param name="pDestFilename">The name to use for the volume-adjusted WAV file</param>
            <param name="pMultiplier">The value by which to multiply the audio samples</param>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.AdjustVolumeInPlace(System.String,System.Double)">
            <summary>
            Changes the volume of a WAV file.
            </summary>
            <param name="pFilename">The name of the WAV file to adjust</param>
            <param name="pMultiplier">The volume multiplier</param>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.AdjustVolume_Copy_8BitTo16Bit(System.String,System.String,System.Double)">
            <summary>
            For 8-bit WAV files: Adjusts the volume level and converts it to a 16-bit audio file.
            The converted data is saved to a separate file.
            </summary>
            <param name="pSrcFilename">The name of the WAV file to convert</param>
            <param name="pDestFilename">The name to use for the converted WAV file</param>
            <param name="pMultiplier">The volume multiplier</param>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.Convert_8BitTo16Bit_Copy(System.String,System.String)">
            <summary>
            Converts an 8-bit audio file to a separte 16-bit audio file.
            </summary>
            <param name="pSrcFilename">The name of the file to convert</param>
            <param name="pDestFilename">The name to use for the converted audio file</param>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.CopyAndConvert(System.String,System.String,System.Int16,System.Boolean)">
            <summary>
            Converts a WAV file's bits/sample and number of channels to a separate WAV file.
            </summary>
            <param name="pSrcFilename">The name of the file to convert</param>
            <param name="pDestFilename">The destination file name</param>
            <param name="pBitsPerSample">The destination's number of bits/sample</param>
            <param name="pStereo">Whether or not the destination should be stereo</param>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.CopyAndConvert(System.String,System.String,System.Int16,System.Boolean,System.Double)">
            <summary>
            Converts a WAV file's bits/sample and number of channels to a separate WAV file.
            </summary>
            <param name="pSrcFilename">The name of the file to convert</param>
            <param name="pDestFilename">The destination file name</param>
            <param name="pBitsPerSample">The destination's number of bits/sample</param>
            <param name="pStereo">Whether or not the destination should be stereo</param>
            <param name="pVolumeMultiplier">A multiplier that can be used to adjust the volume of the output audio file</param>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.SupportedSampleRate(System.Int32)">
            <summary>
            Returns whether or not a sample rate is supported by this class.
            </summary>
            <param name="pSampleRateHz">A sample rate (in Hz)</param>
            <returns>true if the sample rate is supported, or false if not.</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.SupportedBitsPerSample(System.Int16)">
            <summary>
            Returns whether or not a number of bits per sample is supported by this class.
            </summary>
            <param name="pBitsPerSample">A number of bits per sample</param>
            <returns>true if the bits/sample is supported by this class, or false if not.</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.MergeAudioFiles(System.String[],System.String,System.String)">
            <summary>
            Merges a set of WAV file sinto a single WAV file in such a way that the audio will be overlayed.
            This method will throw a WAVFileException upon error.
            </summary>
            <param name="pFileList">An array containing the audio filenames</param>
            <param name="pOutputFilename">The name of the file to contain the resulting audio</param>
            <param name="pTempDir">The full path to the temporary directory to use for the work.  If this directory does not exist, it will be created and then deleted when this method no longer needs it.</param>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.SeekToAudioDataStart">
            <summary>
            Moves the file pointer back to the start of the audio data.
            </summary>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.SeekToAudioSample(System.Int64)">
            <summary>
            Moves the file pointer to a given audio sample number.
            </summary>
            <param name="pSampleNum">The sample number to which to move the file pointer</param>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.WavFileModeStr(Syn.Speech.Wave.WaveFile.WavFileMode)">
            <summary>
            Returns a string representation of a WAVFileMode enumeration value.
            </summary>
            <param name="pMode">A value of the WAVFileMode enumeration</param>
            <returns>A string representation of pMode</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.InitMembers">
            <summary>
            Initializes the data members (for the constructors).
            </summary>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.SampleRatesEqual(System.String[])">
            <summary>
            Returns whether or not the sample rates in a set of WAV files are equal.
            </summary>
            <param name="pFileList">An array containing the names of the files to check</param>
            <returns>Whether or not all WAV files have the same sample rate</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.SamplesRemain(Syn.Speech.Wave.WaveFile[])">
            <summary>
            Returns whether or not any audio samples are remaining to be read from an array of WAV files.
            </summary>
            <param name="waveFileArray">An array of WAVFile objects that are currently open</param>
            <returns>true if there are samples that can still be read from any of the files, or false if not.</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.DeleteDir(System.String)">
            <summary>
            Removes a directory, including all the files in it.  This is used by MergeAudioFiles().
            </summary>
            <param name="pPath">The directory to remove</param>
            <returns>A blank string upon success, or a warning upon error.  If the directory does not exist, that is not an error.</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.StrToByteArray(System.String)">
            <summary>
            Converts a string to a byte array.  The source for this came
            from http://www.chilkatsoft.com/faq/DotNetStrToBytes.html .
            </summary>
            <param name="pStr">A String object</param>
            <returns>A byte array containing the data from the String object</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.ScaleByteToShort(System.Byte)">
            <summary>
            Scales a byte value to a 16-bit (short) value by calculating the value's percentage of
            maximum for 8-bit values, then calculating the 16-bit value with that
            percentage.
            </summary>
            <param name="pByteVal">A byte value to convert</param>
            <returns>The 16-bit scaled value</returns>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFile.ScaleShortToByte(System.Int16)">
            <summary>
            Scales a 16-bit (short) value to an 8-bit (byte) value by calculating the
            value's percentage of maximum for 16-bit values, then calculating the 8-bit
            value with that percentage.
            </summary>
            <param name="pShortVal">A 16-bit value to convert</param>
            <returns>The 8-bit scaled value</returns>
        </member>
        <member name="P:Syn.Speech.Wave.WaveFile.Filename">
            <summary>
            Gets the name of the file that was opened.
            </summary>
        </member>
        <member name="P:Syn.Speech.Wave.WaveFile.WAVHeader">
            <summary>
            Gets the WAV file header as read from the file (array of 4 chars)
            </summary>
        </member>
        <member name="P:Syn.Speech.Wave.WaveFile.WavHeaderString">
            <summary>
            Gets the WAV file header as read from the file, as a String object
            </summary>
        </member>
        <member name="P:Syn.Speech.Wave.WaveFile.RIFFType">
            <summary>
            Gets the RIFF type as read from the file (array of chars)
            </summary>
        </member>
        <member name="P:Syn.Speech.Wave.WaveFile.RiffTypeString">
            <summary>
            Gets the RIFF type as read from the file, as a String object
            </summary>
        </member>
        <member name="P:Syn.Speech.Wave.WaveFile.NumChannels">
            <summary>
            Gets the audio file's number of channels
            </summary>
        </member>
        <member name="P:Syn.Speech.Wave.WaveFile.IsStereo">
            <summary>
            Gets whether or not the file is stereo.
            </summary>
        </member>
        <member name="P:Syn.Speech.Wave.WaveFile.SampleRateHz">
            <summary>
            Gets the audio file's sample rate (in Hz)
            </summary>
        </member>
        <member name="P:Syn.Speech.Wave.WaveFile.BytesPerSec">
            <summary>
            Gets the number of bytes per second for the audio file
            </summary>
        </member>
        <member name="P:Syn.Speech.Wave.WaveFile.BytesPerSample">
            <summary>
            Gets the number of bytes per sample for the audio file
            </summary>
        </member>
        <member name="P:Syn.Speech.Wave.WaveFile.BitsPerSample">
            <summary>
            Gets the number of bits per sample for the audio file
            </summary>
        </member>
        <member name="P:Syn.Speech.Wave.WaveFile.DataSizeBytes">
            <summary>
            Gets the data size (in bytes) for the audio file.  This is read from a field
            in the WAV file header.
            </summary>
        </member>
        <member name="P:Syn.Speech.Wave.WaveFile.FileSizeBytes">
            <summary>
            Gets the file size (in bytes).  This is read from a field in the WAV file header.
            </summary>
        </member>
        <member name="P:Syn.Speech.Wave.WaveFile.NumSamples">
            <summary>
            Gets the number of audio samples in the WAV file.  This is calculated based on
            the data size read from the file and the number of bits per sample.
            </summary>
        </member>
        <member name="P:Syn.Speech.Wave.WaveFile.NumSamplesRemaining">
            <summary>
            Gets the number of samples remaining (when in read mode).
            </summary>
        </member>
        <member name="P:Syn.Speech.Wave.WaveFile.FileOpenMode">
            <summary>
            Gets the mode of the open file (read, write, or read/write)
            </summary>
        </member>
        <member name="P:Syn.Speech.Wave.WaveFile.Format">
            <summary>
            Gets a WAVFormat object containing the audio format information
            for the file (# channels, sample rate, and bits per sample).
            </summary>
        </member>
        <member name="P:Syn.Speech.Wave.WaveFile.FilePosition">
            <summary>
            Gets the current file byte position.
            </summary>
        </member>
        <member name="T:Syn.Speech.Wave.WaveFile.WavFileMode">
            <summary>
            This enumeration specifies file modes supported by the
            class.
            </summary>
        </member>
        <member name="T:Syn.Speech.Wave.WaveFileException">
            <summary>
            Class for exception objects thrown by the WAVFile class when an error occurs
            </summary>
        </member>
        <member name="T:Syn.Speech.Wave.WaveFileAudioMergeException">
            <summary>
            This exception is thrown by the WAVFile class during audio file merging.
            </summary>
        </member>
        <member name="T:Syn.Speech.Wave.WaveFileReadException">
            <summary>
            This exception is thrown by the WAVFile class for read errors.
            </summary>
        </member>
        <member name="T:Syn.Speech.Wave.WaveFileWriteException">
            <summary>
            This exception is thrown by the WAVFile class for write errors.
            </summary>
        </member>
        <member name="T:Syn.Speech.Wave.WaveFileIoException">
            <summary>
            Represents an exception for general WAV file I/O
            </summary>
        </member>
        <member name="T:Syn.Speech.Wave.WaveFileBitsPerSampleException">
            <summary>
            This exception is thrown by the WAVFile class for an unsupported number of bits per sample.
            </summary>
        </member>
        <member name="T:Syn.Speech.Wave.WaveFileSampleRateException">
            <summary>
            This exception is thrown by the WAVFile class for an unsupported sample rate.
            </summary>
        </member>
        <member name="T:Syn.Speech.Wave.WaveFormat">
            <summary>
            This struct contains audio format information and is used by the WAVFile class.
            </summary>
        </member>
        <member name="M:Syn.Speech.Wave.WaveFormat.#ctor(System.Byte,System.Int32,System.Int16)">
            <summary>
            Constructor
            </summary>
            <param name="pChannels">The number of channels</param>
            <param name="pSampleRate">The sample rate (Hz)</param>
            <param name="pBitsPerSample">The number of bits per sample</param>
        </member>
    </members>
</doc>
